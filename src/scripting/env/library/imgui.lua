local ffi = require"ffi"
local cdecl = require"imguicdecl"

local ffi_cdef = function(code)
    local ret,err = pcall(ffi.cdef,code)
    if not ret then
        local lineN = 1
        for line in code:gmatch("([^\n\r]*)\r?\n") do
            print(lineN, line)
            lineN = lineN + 1
        end
        print(err)
        error"bad cdef"
    end
end


ffi.cdef(cdecl)


--load dll
local lib = ffi.load(CURRENT_DLL_PATH)

-----------ImStr definition
local ImStrv
if pcall(function() local a = ffi.new("ImStrv")end) then

ImStrv= {}
function ImStrv.__new(ctype,a,b)
	b = b or ffi.new("const char*",a) + (a and #a or 0)
	return ffi.new(ctype,a,b)
end
function ImStrv.__tostring(is)
	return is.Begin~=nil and ffi.string(is.Begin,is.End~=nil and is.End-is.Begin or nil) or nil
end
ImStrv.__index = ImStrv
ImStrv = ffi.metatype("ImStrv",ImStrv)

end
-----------ImVec2 definition
---@class ImVec2 : ffi.ctype*
local ImVec2
ImVec2 = {
    __add = function(a,b) return ImVec2(a.x + b.x, a.y + b.y) end,
    __sub = function(a,b) return ImVec2(a.x - b.x, a.y - b.y) end,
    __unm = function(a) return ImVec2(-a.x,-a.y) end,
    __mul = function(a, b) --scalar mult
        if not ffi.istype(ImVec2, b) then
        return ImVec2(a.x * b, a.y * b) end
        return ImVec2(a * b.x, a * b.y)
    end,
	__len = function(a) return math.sqrt(a.x*a.x+a.y*a.y) end,
	norm = function(a)
		return math.sqrt(a.x*a.x+a.y*a.y)
	end,
    __tostring = function(v) return 'ImVec2<'..v.x..','..v.y..'>' end
}
ImVec2.__index = ImVec2
ImVec2 = ffi.metatype("ImVec2",ImVec2) --[[@as ImVec2]]
local ImVec4= {}
ImVec4.__index = ImVec4
ImVec4 = ffi.metatype("ImVec4",ImVec4)
--the module
local M = {ImVec2 = ImVec2, ImVec4 = ImVec4 , ImStrv = ImStrv, lib = lib}

if jit.os == "Windows" then
    function M.ToUTF(unc_str)
        local buf_len = lib.igImTextCountUtf8BytesFromStr(unc_str, nil) + 1;
        local buf_local = ffi.new("char[?]",buf_len)
        lib.igImTextStrToUtf8(buf_local, buf_len, unc_str, nil);
        return buf_local
    end
    
    function M.FromUTF(utf_str)
        local wbuf_length = lib.igImTextCountCharsFromUtf8(utf_str, nil) + 1;
        local buf_local = ffi.new("ImWchar[?]",wbuf_length)
        lib.igImTextStrFromUtf8(buf_local, wbuf_length, utf_str, nil,nil);
        return buf_local
    end
end

M.FLT_MAX = lib.igGET_FLT_MAX()
M.FLT_MIN = lib.igGET_FLT_MIN()----------BEGIN_AUTOGENERATED_LUA---------------------------
--------------------------ActivateFlags----------------------------
---@enum ActivateFlags
M.ActivateFlags= {
    None = 0,
    PreferTweak = 2,
    PreferInput = 1,
    TryToPreserveState = 4,
}
--------------------------Axis----------------------------
---@enum Axis
M.Axis= {
    None = -1,
    X = 0,
    Y = 1,
}
--------------------------BackendFlags----------------------------
---@enum BackendFlags
M.BackendFlags= {
    None = 0,
    HasGamepad = 1,
    HasMouseCursors = 2,
    RendererHasVtxOffset = 8,
    HasSetMousePos = 4,
}
--------------------------ButtonFlags----------------------------
---@enum ButtonFlags
M.ButtonFlags= {
    None = 0,
    DontClosePopups = 8192,
    Repeat = 1024,
    PressedOnClick = 16,
    PressedOnClickReleaseAnywhere = 64,
    PressedOnDragDropHold = 512,
    NoHoveredOnFocus = 524288,
    PressedOnDefault_ = 32,
    PressedOnClickRelease = 32,
    NoTestKeyOwner = 2097152,
    PressedOnDoubleClick = 256,
    MouseButtonRight = 2,
    AlignTextBaseLine = 32768,
    PressedOnMask_ = 1008,
    MouseButtonMiddle = 4,
    PressedOnRelease = 128,
    NoHoldingActiveId = 131072,
    NoSetKeyOwner = 1048576,
    AllowItemOverlap = 4096,
    NoKeyModifiers = 65536,
    MouseButtonLeft = 1,
    FlattenChildren = 2048,
    MouseButtonMask_ = 7,
    MouseButtonDefault_ = 1,
    NoNavFocus = 262144,
}
--------------------------Col----------------------------
---@enum Col
M.Col= {
    ScrollbarGrab = 15,
    TabActive = 35,
    TabHovered = 34,
    FrameBgActive = 9,
    ButtonHovered = 22,
    ChildBg = 3,
    PlotHistogram = 40,
    SliderGrabActive = 20,
    ResizeGripActive = 32,
    ModalWindowDimBg = 52,
    FrameBg = 7,
    TextDisabled = 1,
    ResizeGripHovered = 31,
    PlotHistogramHovered = 41,
    PlotLines = 38,
    SliderGrab = 19,
    TextSelectedBg = 47,
    TabUnfocused = 36,
    TableRowBg = 45,
    TitleBgCollapsed = 12,
    TitleBg = 10,
    HeaderHovered = 25,
    NavHighlight = 49,
    SeparatorHovered = 28,
    ButtonActive = 23,
    NavWindowingHighlight = 50,
    ResizeGrip = 30,
    DragDropTarget = 48,
    SeparatorActive = 29,
    TableRowBgAlt = 46,
    Border = 5,
    TableBorderLight = 44,
    TableBorderStrong = 43,
    Separator = 27,
    FrameBgHovered = 8,
    TableHeaderBg = 42,
    PlotLinesHovered = 39,
    TabUnfocusedActive = 37,
    Tab = 33,
    CheckMark = 18,
    ScrollbarGrabHovered = 16,
    COUNT = 53,
    HeaderActive = 26,
    Button = 21,
    ScrollbarGrabActive = 17,
    NavWindowingDimBg = 51,
    PopupBg = 4,
    WindowBg = 2,
    MenuBarBg = 13,
    TitleBgActive = 11,
    Header = 24,
    BorderShadow = 6,
    ScrollbarBg = 14,
    Text = 0,
}
--------------------------ColorEditFlags----------------------------
---@enum ColorEditFlags
M.ColorEditFlags= {
    None = 0,
    NoTooltip = 64,
    NoDragDrop = 512,
    InputMask_ = 402653184,
    PickerMask_ = 100663296,
    DataTypeMask_ = 25165824,
    NoLabel = 128,
    DisplayMask_ = 7340032,
    DefaultOptions_ = 177209344,
    AlphaPreviewHalf = 262144,
    NoOptions = 8,
    NoAlpha = 2,
    NoPicker = 4,
    DisplayHSV = 2097152,
    HDR = 524288,
    Float = 16777216,
    NoSidePreview = 256,
    AlphaPreview = 131072,
    PickerHueWheel = 67108864,
    AlphaBar = 65536,
    NoInputs = 32,
    Uint8 = 8388608,
    InputHSV = 268435456,
    NoSmallPreview = 16,
    PickerHueBar = 33554432,
    NoBorder = 1024,
    DisplayHex = 4194304,
    DisplayRGB = 1048576,
    InputRGB = 134217728,
}
--------------------------ComboFlags----------------------------
---@enum ComboFlags
M.ComboFlags= {
    None = 0,
    HeightRegular = 4,
    HeightSmall = 2,
    NoArrowButton = 32,
    CustomPreview = 1048576,
    HeightMask_ = 30,
    HeightLargest = 16,
    NoPreview = 64,
    HeightLarge = 8,
    PopupAlignLeft = 1,
}
--------------------------Cond----------------------------
---@enum Cond
M.Cond= {
    None = 0,
    Once = 2,
    Always = 1,
    Appearing = 8,
    FirstUseEver = 4,
}
--------------------------ConfigFlags----------------------------
---@enum ConfigFlags
M.ConfigFlags= {
    None = 0,
    NavNoCaptureKeyboard = 8,
    NavEnableGamepad = 2,
    IsSRGB = 1048576,
    NavEnableKeyboard = 1,
    IsTouchScreen = 2097152,
    NoMouse = 16,
    NavEnableSetMousePos = 4,
    NoMouseCursorChange = 32,
}
--------------------------ContextHookType----------------------------
---@enum ContextHookType
M.ContextHookType= {
    NewFramePost = 1,
    NewFramePre = 0,
    EndFramePre = 2,
    EndFramePost = 3,
    PendingRemoval_ = 7,
    RenderPost = 5,
    RenderPre = 4,
    Shutdown = 6,
}
--------------------------DataType----------------------------
---@enum DataType
M.DataType= {
    U8 = 1,
    U32 = 5,
    COUNT = 10,
    Double = 9,
    S8 = 0,
    ID = 13,
    U64 = 7,
    Pointer = 12,
    S64 = 6,
    String = 11,
    S32 = 4,
    Float = 8,
    S16 = 2,
    U16 = 3,
}
--------------------------DebugLogFlags----------------------------
---@enum DebugLogFlags
M.DebugLogFlags= {
    None = 0,
    OutputToTTY = 1024,
    EventActiveId = 1,
    EventNav = 8,
    EventFocus = 2,
    EventPopup = 4,
    EventMask_ = 63,
    EventIO = 32,
    EventClipper = 16,
}
--------------------------Dir----------------------------
---@enum Dir
M.Dir= {
    None = -1,
    Left = 0,
    COUNT = 4,
    Right = 1,
    Up = 2,
    Down = 3,
}
--------------------------DragDropFlags----------------------------
---@enum DragDropFlags
M.DragDropFlags= {
    None = 0,
    SourceExtern = 16,
    SourceAutoExpirePayload = 32,
    AcceptPeekOnly = 3072,
    SourceAllowNullID = 8,
    SourceNoDisableHover = 2,
    SourceNoHoldToOpenOthers = 4,
    AcceptBeforeDelivery = 1024,
    AcceptNoDrawDefaultRect = 2048,
    SourceNoPreviewTooltip = 1,
    AcceptNoPreviewTooltip = 4096,
}
--------------------------FocusedFlags----------------------------
---@enum FocusedFlags
M.FocusedFlags= {
    None = 0,
    RootWindow = 2,
    AnyWindow = 4,
    NoPopupHierarchy = 8,
    ChildWindows = 1,
    RootAndChildWindows = 3,
}
--------------------------HoveredFlags----------------------------
---@enum HoveredFlags
M.HoveredFlags= {
    None = 0,
    NoNavOverride = 1024,
    NoPopupHierarchy = 8,
    NoSharedDelay = 8192,
    DelayShort = 4096,
    AllowWhenDisabled = 512,
    RootAndChildWindows = 3,
    DelayNormal = 2048,
    RootWindow = 2,
    AnyWindow = 4,
    RectOnly = 416,
    AllowWhenBlockedByPopup = 32,
    ChildWindows = 1,
    AllowWhenOverlapped = 256,
    AllowWhenBlockedByActiveItem = 128,
}
--------------------------ImDrawFlags----------------------------
---@enum ImDrawFlags
M.ImDrawFlags= {
    None = 0,
    RoundCornersBottomLeft = 64,
    RoundCornersDefault_ = 240,
    RoundCornersTop = 48,
    RoundCornersAll = 240,
    RoundCornersNone = 256,
    RoundCornersRight = 160,
    Closed = 1,
    RoundCornersTopLeft = 16,
    RoundCornersTopRight = 32,
    RoundCornersLeft = 80,
    RoundCornersBottom = 192,
    RoundCornersBottomRight = 128,
    RoundCornersMask_ = 496,
}
--------------------------ImDrawListFlags----------------------------
---@enum ImDrawListFlags
M.ImDrawListFlags= {
    None = 0,
    AntiAliasedFill = 4,
    AntiAliasedLinesUseTex = 2,
    AllowVtxOffset = 8,
    AntiAliasedLines = 1,
}
--------------------------ImFontAtlasFlags----------------------------
---@enum ImFontAtlasFlags
M.ImFontAtlasFlags= {
    None = 0,
    NoBakedLines = 4,
    NoPowerOfTwoHeight = 1,
    NoMouseCursors = 2,
}
--------------------------InputEventType----------------------------
---@enum InputEventType
M.InputEventType= {
    None = 0,
    Focus = 6,
    MouseWheel = 2,
    COUNT = 7,
    MouseButton = 3,
    Key = 4,
    MousePos = 1,
    Text = 5,
}
--------------------------InputFlags----------------------------
---@enum InputFlags
M.InputFlags= {
    None = 0,
    CondHovered = 16,
    RepeatRateNavTweak = 8,
    Repeat = 1,
    SupportedByShortcut = 16143,
    RouteAlways = 4096,
    RouteGlobalHigh = 2048,
    RouteMask_ = 3840,
    RepeatRateNavMove = 4,
    RouteExtraMask_ = 12288,
    RepeatRateDefault = 2,
    SupportedBySetItemKeyOwner = 240,
    CondActive = 32,
    SupportedByIsKeyPressed = 15,
    LockUntilRelease = 128,
    SupportedBySetKeyOwner = 192,
    RouteUnlessBgFocused = 8192,
    CondDefault_ = 48,
    RouteGlobalLow = 512,
    CondMask_ = 48,
    RepeatRateMask_ = 14,
    LockThisFrame = 64,
    RouteGlobal = 1024,
    RouteFocused = 256,
}
--------------------------InputSource----------------------------
---@enum InputSource
M.InputSource= {
    None = 0,
    COUNT = 6,
    Clipboard = 4,
    Nav = 5,
    Keyboard = 2,
    Mouse = 1,
    Gamepad = 3,
}
--------------------------InputTextFlags----------------------------
---@enum InputTextFlags
M.InputTextFlags= {
    None = 0,
    AllowTabInput = 1024,
    NoHorizontalScroll = 4096,
    NoMarkEdited = 134217728,
    CallbackHistory = 128,
    CallbackAlways = 256,
    ReadOnly = 16384,
    Multiline = 67108864,
    CallbackCompletion = 64,
    AutoSelectAll = 16,
    CallbackCharFilter = 512,
    Password = 32768,
    CharsUppercase = 4,
    CharsHexadecimal = 2,
    CharsScientific = 131072,
    CallbackResize = 262144,
    CallbackEdit = 524288,
    CharsDecimal = 1,
    EscapeClearsAll = 1048576,
    CharsNoBlank = 8,
    AlwaysOverwrite = 8192,
    CtrlEnterForNewLine = 2048,
    MergedItem = 268435456,
    NoUndoRedo = 65536,
    EnterReturnsTrue = 32,
}
--------------------------ItemFlags----------------------------
---@enum ItemFlags
M.ItemFlags= {
    None = 0,
    NoNavDefaultFocus = 16,
    Disabled = 4,
    SelectableDontClosePopup = 32,
    Inputable = 1024,
    NoWindowHoverableCheck = 256,
    ButtonRepeat = 2,
    MixedValue = 64,
    ReadOnly = 128,
    NoTabStop = 1,
    NoNav = 8,
}
--------------------------ItemStatusFlags----------------------------
---@enum ItemStatusFlags
M.ItemStatusFlags= {
    None = 0,
    Deactivated = 64,
    HasDisplayRect = 2,
    Visible = 512,
    HasDeactivated = 32,
    Edited = 4,
    ToggledOpen = 16,
    HoveredRect = 1,
    ToggledSelection = 8,
    FocusedByTabbing = 256,
    HoveredWindow = 128,
}
--------------------------Key----------------------------
---@enum Key
M.Key= {
    _4 = 540,
    S = 564,
    Period = 587,
    F5 = 576,
    F11 = 582,
    MouseWheelY = 647,
    GamepadLStickRight = 634,
    F7 = 578,
    U = 566,
    _8 = 544,
    W = 568,
    _6 = 542,
    KeypadEqual = 616,
    GamepadDpadRight = 624,
    KeysData_OFFSET = 0,
    Y = 570,
    KeysData_SIZE = 652,
    MouseWheelX = 646,
    F9 = 580,
    Comma = 585,
    ReservedForModAlt = 650,
    GamepadBack = 618,
    RightSuper = 534,
    NamedKey_COUNT = 140,
    MouseRight = 642,
    Keypad6 = 606,
    KeypadDivide = 611,
    B = 547,
    Space = 524,
    ReservedForModCtrl = 648,
    GamepadL1 = 627,
    Home = 519,
    GamepadFaceLeft = 619,
    GamepadL3 = 631,
    Slash = 588,
    GamepadRStickLeft = 637,
    F = 551,
    NumLock = 597,
    RightCtrl = 531,
    GamepadFaceUp = 621,
    GamepadRStickDown = 640,
    L = 557,
    LeftArrow = 513,
    RightBracket = 593,
    _1 = 537,
    Keypad3 = 603,
    Backslash = 592,
    PrintScreen = 598,
    P = 561,
    F2 = 573,
    Keypad1 = 601,
    Menu = 535,
    _5 = 541,
    R = 563,
    PageUp = 517,
    F6 = 577,
    T = 565,
    GamepadL2 = 629,
    _7 = 543,
    RightArrow = 514,
    Apostrophe = 584,
    DownArrow = 516,
    ReservedForModSuper = 651,
    _9 = 545,
    Minus = 586,
    X = 569,
    KeypadEnter = 615,
    V = 567,
    End = 520,
    LeftCtrl = 527,
    GamepadDpadUp = 625,
    MouseLeft = 641,
    LeftAlt = 529,
    Z = 571,
    MouseX1 = 644,
    KeypadMultiply = 612,
    GamepadLStickUp = 635,
    NamedKey_END = 652,
    GamepadStart = 617,
    GamepadLStickLeft = 633,
    A = 546,
    GraveAccent = 594,
    C = 548,
    GamepadDpadDown = 626,
    NamedKey_BEGIN = 512,
    Keypad4 = 604,
    KeypadDecimal = 610,
    H = 553,
    ReservedForModShift = 649,
    MouseX2 = 645,
    E = 550,
    MouseMiddle = 643,
    GamepadRStickUp = 639,
    KeypadAdd = 614,
    Keypad8 = 608,
    GamepadFaceRight = 620,
    Equal = 590,
    Keypad2 = 602,
    G = 552,
    GamepadDpadLeft = 623,
    RightShift = 532,
    Backspace = 523,
    N = 559,
    F8 = 579,
    F1 = 572,
    UpArrow = 515,
    F12 = 583,
    I = 554,
    D = 549,
    GamepadRStickRight = 638,
    Delete = 522,
    Keypad7 = 607,
    LeftBracket = 591,
    _0 = 536,
    PageDown = 518,
    K = 556,
    F4 = 575,
    None = 0,
    GamepadR2 = 630,
    LeftShift = 528,
    _3 = 539,
    M = 558,
    Enter = 525,
    Keypad5 = 605,
    GamepadR1 = 628,
    Q = 562,
    J = 555,
    Tab = 512,
    GamepadR3 = 632,
    RightAlt = 533,
    Insert = 521,
    Semicolon = 589,
    O = 560,
    Keypad0 = 600,
    COUNT = 652,
    Escape = 526,
    CapsLock = 595,
    ScrollLock = 596,
    F10 = 581,
    Pause = 599,
    Keypad9 = 609,
    GamepadFaceDown = 622,
    KeypadSubtract = 613,
    _2 = 538,
    F3 = 574,
    LeftSuper = 530,
    GamepadLStickDown = 636,
}
--------------------------LayoutType----------------------------
---@enum LayoutType
M.LayoutType= {
    Horizontal = 0,
    Vertical = 1,
}
--------------------------LocKey----------------------------
---@enum LocKey
M.LocKey= {
    TableResetOrder = 3,
    COUNT = 7,
    WindowingMainMenuBar = 4,
    TableSizeOne = 0,
    WindowingUntitled = 6,
    WindowingPopup = 5,
    TableSizeAllFit = 1,
    TableSizeAllDefault = 2,
}
--------------------------LogType----------------------------
---@enum LogType
M.LogType= {
    None = 0,
    Buffer = 3,
    File = 2,
    Clipboard = 4,
    TTY = 1,
}
--------------------------Mod----------------------------
---@enum Mod
M.Mod= {
    None = 0,
    Shortcut = 2048,
    Shift = 8192,
    Mask_ = 63488,
    Super = 32768,
    Ctrl = 4096,
    Alt = 16384,
}
--------------------------MouseButton----------------------------
---@enum MouseButton
M.MouseButton= {
    Left = 0,
    Right = 1,
    Middle = 2,
    COUNT = 5,
}
--------------------------MouseCursor----------------------------
---@enum MouseCursor
M.MouseCursor= {
    None = -1,
    ResizeEW = 4,
    COUNT = 9,
    ResizeNESW = 5,
    ResizeNWSE = 6,
    TextInput = 1,
    ResizeAll = 2,
    ResizeNS = 3,
    NotAllowed = 8,
    Hand = 7,
    Arrow = 0,
}
--------------------------NavHighlightFlags----------------------------
---@enum NavHighlightFlags
M.NavHighlightFlags= {
    None = 0,
    TypeDefault = 1,
    TypeThin = 2,
    NoRounding = 8,
    AlwaysDraw = 4,
}
--------------------------NavInput----------------------------
---@enum NavInput
M.NavInput= {
    Menu = 3,
    TweakSlow = 14,
    DpadRight = 5,
    LStickDown = 11,
    TweakFast = 15,
    Cancel = 1,
    DpadDown = 7,
    FocusPrev = 12,
    DpadUp = 6,
    LStickUp = 10,
    COUNT = 16,
    DpadLeft = 4,
    Activate = 0,
    LStickRight = 9,
    FocusNext = 13,
    Input = 2,
    LStickLeft = 8,
}
--------------------------NavLayer----------------------------
---@enum NavLayer
M.NavLayer= {
    Main = 0,
    Menu = 1,
    COUNT = 2,
}
--------------------------NavMoveFlags----------------------------
---@enum NavMoveFlags
M.NavMoveFlags= {
    None = 0,
    LoopY = 2,
    AlsoScoreVisibleSet = 32,
    WrapX = 4,
    FocusApi = 512,
    LoopX = 1,
    Activate = 2048,
    DebugNoResult = 256,
    ScrollToEdgeY = 64,
    Tabbing = 1024,
    DontSetNavHighlight = 4096,
    AllowCurrentNavId = 16,
    Forwarded = 128,
    WrapY = 8,
}
--------------------------NextItemDataFlags----------------------------
---@enum NextItemDataFlags
M.NextItemDataFlags= {
    None = 0,
    HasOpen = 2,
    HasWidth = 1,
}
--------------------------NextWindowDataFlags----------------------------
---@enum NextWindowDataFlags
M.NextWindowDataFlags= {
    None = 0,
    HasSizeConstraint = 16,
    HasPos = 1,
    HasBgAlpha = 64,
    HasCollapsed = 8,
    HasContentSize = 4,
    HasScroll = 128,
    HasSize = 2,
    HasFocus = 32,
}
--------------------------OldColumnFlags----------------------------
---@enum OldColumnFlags
M.OldColumnFlags= {
    None = 0,
    NoPreserveWidths = 4,
    NoBorder = 1,
    NoResize = 2,
    NoForceWithinWindow = 8,
    GrowParentContentsSize = 16,
}
--------------------------PlotType----------------------------
---@enum PlotType
M.PlotType= {
    Lines = 0,
    Histogram = 1,
}
--------------------------PopupFlags----------------------------
---@enum PopupFlags
M.PopupFlags= {
    None = 0,
    MouseButtonRight = 1,
    NoOpenOverItems = 64,
    AnyPopupId = 128,
    MouseButtonDefault_ = 1,
    MouseButtonMiddle = 2,
    MouseButtonLeft = 0,
    NoOpenOverExistingPopup = 32,
    MouseButtonMask_ = 31,
    AnyPopup = 384,
    AnyPopupLevel = 256,
}
--------------------------PopupPositionPolicy----------------------------
---@enum PopupPositionPolicy
M.PopupPositionPolicy= {
    Tooltip = 2,
    ComboBox = 1,
    Default = 0,
}
--------------------------ScrollFlags----------------------------
---@enum ScrollFlags
M.ScrollFlags= {
    None = 0,
    KeepVisibleEdgeX = 1,
    MaskX_ = 21,
    MaskY_ = 42,
    KeepVisibleCenterX = 4,
    NoScrollParent = 64,
    AlwaysCenterY = 32,
    KeepVisibleCenterY = 8,
    AlwaysCenterX = 16,
    KeepVisibleEdgeY = 2,
}
--------------------------SelectableFlags----------------------------
---@enum SelectableFlags
M.SelectableFlags= {
    None = 0,
    DontClosePopups = 1,
    Disabled = 8,
    SetNavIdOnHover = 33554432,
    NoPadWithHalfSpacing = 67108864,
    SelectOnClick = 4194304,
    NoSetKeyOwner = 134217728,
    AllowItemOverlap = 16,
    SpanAvailWidth = 16777216,
    SpanAllColumns = 2,
    AllowDoubleClick = 4,
    SelectOnRelease = 8388608,
    NoHoldingActiveID = 1048576,
    SelectOnNav = 2097152,
}
--------------------------SeparatorFlags----------------------------
---@enum SeparatorFlags
M.SeparatorFlags= {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    SpanAllColumns = 4,
}
--------------------------SliderFlags----------------------------
---@enum SliderFlags
M.SliderFlags= {
    None = 0,
    InvalidMask_ = 1879048207,
    NoInput = 128,
    NoRoundToFormat = 64,
    ReadOnly = 2097152,
    Logarithmic = 32,
    Vertical = 1048576,
    AlwaysClamp = 16,
}
--------------------------SortDirection----------------------------
---@enum SortDirection
M.SortDirection= {
    None = 0,
    Descending = 2,
    Ascending = 1,
}
--------------------------StyleVar----------------------------
---@enum StyleVar
M.StyleVar= {
    SeparatorTextBorderSize = 25,
    WindowRounding = 3,
    FrameRounding = 12,
    ItemSpacing = 14,
    DisabledAlpha = 1,
    Alpha = 0,
    IndentSpacing = 16,
    COUNT = 28,
    SeparatorTextPadding = 27,
    SeparatorTextAlign = 26,
    PopupBorderSize = 10,
    SelectableTextAlign = 24,
    WindowTitleAlign = 6,
    ButtonTextAlign = 23,
    ChildRounding = 7,
    GrabRounding = 21,
    WindowBorderSize = 4,
    WindowMinSize = 5,
    ScrollbarSize = 18,
    TabRounding = 22,
    GrabMinSize = 20,
    PopupRounding = 9,
    WindowPadding = 2,
    ItemInnerSpacing = 15,
    ScrollbarRounding = 19,
    CellPadding = 17,
    ChildBorderSize = 8,
    FrameBorderSize = 13,
    FramePadding = 11,
}
--------------------------TabBarFlags----------------------------
---@enum TabBarFlags
M.TabBarFlags= {
    None = 0,
    NoTooltip = 32,
    TabListPopupButton = 4,
    FittingPolicyResizeDown = 64,
    NoTabListScrollingButtons = 16,
    DockNode = 1048576,
    IsFocused = 2097152,
    SaveSettings = 4194304,
    Reorderable = 1,
    FittingPolicyMask_ = 192,
    AutoSelectNewTabs = 2,
    FittingPolicyDefault_ = 64,
    NoCloseWithMiddleMouseButton = 8,
    FittingPolicyScroll = 128,
}
--------------------------TabItemFlags----------------------------
---@enum TabItemFlags
M.TabItemFlags= {
    None = 0,
    NoTooltip = 16,
    NoPushId = 8,
    NoCloseButton = 1048576,
    Trailing = 128,
    Leading = 64,
    NoReorder = 32,
    Button = 2097152,
    SetSelected = 2,
    SectionMask_ = 192,
    NoCloseWithMiddleMouseButton = 4,
    UnsavedDocument = 1,
}
--------------------------TableBgTarget----------------------------
---@enum TableBgTarget
M.TableBgTarget= {
    None = 0,
    CellBg = 3,
    RowBg1 = 2,
    RowBg0 = 1,
}
--------------------------TableColumnFlags----------------------------
---@enum TableColumnFlags
M.TableColumnFlags= {
    None = 0,
    NoSort = 512,
    Disabled = 1,
    PreferSortAscending = 16384,
    IndentEnable = 65536,
    NoSortDescending = 2048,
    IndentDisable = 131072,
    PreferSortDescending = 32768,
    WidthMask_ = 24,
    NoHide = 128,
    NoDirectResize_ = 1073741824,
    StatusMask_ = 251658240,
    IndentMask_ = 196608,
    IsHovered = 134217728,
    DefaultSort = 4,
    NoHeaderLabel = 4096,
    NoSortAscending = 1024,
    IsVisible = 33554432,
    NoReorder = 64,
    NoHeaderWidth = 8192,
    IsEnabled = 16777216,
    DefaultHide = 2,
    WidthFixed = 16,
    WidthStretch = 8,
    NoClip = 256,
    IsSorted = 67108864,
    NoResize = 32,
}
--------------------------TableFlags----------------------------
---@enum TableFlags
M.TableFlags= {
    NoClip = 1048576,
    SizingFixedSame = 16384,
    BordersOuterV = 1024,
    Borders = 1920,
    BordersInnerV = 512,
    SizingStretchProp = 24576,
    SortMulti = 67108864,
    NoPadInnerX = 8388608,
    ScrollY = 33554432,
    BordersInnerH = 128,
    NoPadOuterX = 4194304,
    BordersH = 384,
    NoHostExtendX = 65536,
    NoBordersInBodyUntilResize = 4096,
    SortTristate = 134217728,
    PreciseWidths = 524288,
    None = 0,
    NoBordersInBody = 2048,
    ContextMenuInBody = 32,
    Sortable = 8,
    BordersInner = 640,
    SizingMask_ = 57344,
    NoSavedSettings = 16,
    Resizable = 1,
    BordersOuter = 1280,
    SizingStretchSame = 32768,
    NoHostExtendY = 131072,
    BordersV = 1536,
    Reorderable = 2,
    SizingFixedFit = 8192,
    BordersOuterH = 256,
    NoKeepColumnsVisible = 262144,
    ScrollX = 16777216,
    RowBg = 64,
    Hideable = 4,
    PadOuterX = 2097152,
}
--------------------------TableRowFlags----------------------------
---@enum TableRowFlags
M.TableRowFlags= {
    None = 0,
    Headers = 1,
}
--------------------------TextFlags----------------------------
---@enum TextFlags
M.TextFlags= {
    None = 0,
    NoWidthForLargeClippedText = 1,
}
--------------------------TooltipFlags----------------------------
---@enum TooltipFlags
M.TooltipFlags= {
    None = 0,
    OverridePreviousTooltip = 1,
}
--------------------------TreeNodeFlags----------------------------
---@enum TreeNodeFlags
M.TreeNodeFlags= {
    None = 0,
    ClipLabelForTrailingButton = 1048576,
    DefaultOpen = 32,
    OpenOnArrow = 128,
    Leaf = 256,
    SpanFullWidth = 4096,
    NavLeftJumpsBackHere = 8192,
    NoAutoOpenOnLog = 16,
    NoTreePushOnOpen = 8,
    OpenOnDoubleClick = 64,
    AllowItemOverlap = 4,
    Framed = 2,
    CollapsingHeader = 26,
    Selected = 1,
    Bullet = 512,
    FramePadding = 1024,
    SpanAvailWidth = 2048,
}
--------------------------ViewportFlags----------------------------
---@enum ViewportFlags
M.ViewportFlags= {
    None = 0,
    IsPlatformWindow = 1,
    IsPlatformMonitor = 2,
    OwnedByApp = 4,
}
--------------------------WindowFlags----------------------------
---@enum WindowFlags
M.WindowFlags= {
    None = 0,
    NavFlattened = 8388608,
    ChildMenu = 268435456,
    NoResize = 2,
    AlwaysVerticalScrollbar = 16384,
    MenuBar = 1024,
    Modal = 134217728,
    HorizontalScrollbar = 2048,
    Popup = 67108864,
    NoNavFocus = 524288,
    NoTitleBar = 1,
    ChildWindow = 16777216,
    NoCollapse = 32,
    NoBackground = 128,
    NoInputs = 786944,
    AlwaysAutoResize = 64,
    AlwaysHorizontalScrollbar = 32768,
    NoDecoration = 43,
    NoMove = 4,
    NoBringToFrontOnFocus = 8192,
    UnsavedDocument = 1048576,
    AlwaysUseWindowPadding = 65536,
    Tooltip = 33554432,
    NoSavedSettings = 256,
    NoNavInputs = 262144,
    NoScrollWithMouse = 16,
    NoNav = 786432,
    NoFocusOnAppearing = 4096,
    NoScrollbar = 8,
    NoMouseInputs = 512,
}
--------------------------ImBitVector----------------------------
---@class ImBitVector
local ImBitVector= {}
ImBitVector.__index = ImBitVector
---@param self ffi.ct* ImBitVector*
---@return nil
function ImBitVector:Clear()
    return lib.ImBitVector_Clear(self)
end
---@param self ffi.ct* ImBitVector*
---@param n number
---@return nil
function ImBitVector:ClearBit(n)
    return lib.ImBitVector_ClearBit(self,n)
end
---@param self ffi.ct* ImBitVector*
---@param sz number
---@return nil
function ImBitVector:Create(sz)
    return lib.ImBitVector_Create(self,sz)
end
---@param self ffi.ct* ImBitVector*
---@param n number
---@return nil
function ImBitVector:SetBit(n)
    return lib.ImBitVector_SetBit(self,n)
end
---@param self ffi.ct* ImBitVector*
---@param n number
---@return boolean
function ImBitVector:TestBit(n)
    return lib.ImBitVector_TestBit(self,n)
end
M.ImBitVector = ffi.metatype("ImBitVector",ImBitVector)
--------------------------ImColor----------------------------
---@class ImColor
local ImColor= {}
ImColor.__index = ImColor
---@param h number
---@param s number
---@param v number
---@param a number?
---@return nil
function M.ImColor_HSV(h,s,v,a)
    a = a or 1.0
    local nonUDT_out = ffi.new("ImColor")
    lib.ImColor_HSV(nonUDT_out,h,s,v,a)
    return nonUDT_out
end
function ImColor.ImColor_Nil()
    local ptr = lib.ImColor_ImColor_Nil()
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Float(r,g,b,a)
    if a == nil then a = 1.0 end
    local ptr = lib.ImColor_ImColor_Float(r,g,b,a)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Vec4(col)
    local ptr = lib.ImColor_ImColor_Vec4(col)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Int(r,g,b,a)
    if a == nil then a = 255 end
    local ptr = lib.ImColor_ImColor_Int(r,g,b,a)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_U32(rgba)
    local ptr = lib.ImColor_ImColor_U32(rgba)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.__new(ctype,a1,a2,a3,a4) -- generic version
    if a1==nil then return ImColor.ImColor_Nil() end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImColor.ImColor_Float(a1,a2,a3,a4) end
    if ffi.istype('const ImVec4',a1) then return ImColor.ImColor_Vec4(a1) end
    if (ffi.istype('int',a1) or type(a1)=='number') then return ImColor.ImColor_Int(a1,a2,a3,a4) end
    if (ffi.istype('ImU32',a1) or type(a1)=='number') then return ImColor.ImColor_U32(a1) end
    print(ctype,a1,a2,a3,a4)
    error'ImColor.__new could not find overloaded'
end
---@param self ffi.ct* ImColor*
---@param h number
---@param s number
---@param v number
---@param a number?
---@return nil
function ImColor:SetHSV(h,s,v,a)
    a = a or 1.0
    return lib.ImColor_SetHSV(self,h,s,v,a)
end
M.ImColor = ffi.metatype("ImColor",ImColor)
--------------------------ImDrawCmd----------------------------
---@class ImDrawCmd
local ImDrawCmd= {}
ImDrawCmd.__index = ImDrawCmd
---@param self ffi.ct* ImDrawCmd*
---@return ffi.ct* ImTextureID
function ImDrawCmd:GetTexID()
    return lib.ImDrawCmd_GetTexID(self)
end
function ImDrawCmd.__new(ctype)
    local ptr = lib.ImDrawCmd_ImDrawCmd()
    return ffi.gc(ptr,lib.ImDrawCmd_destroy)
end
M.ImDrawCmd = ffi.metatype("ImDrawCmd",ImDrawCmd)
--------------------------ImDrawData----------------------------
---@class ImDrawData
local ImDrawData= {}
ImDrawData.__index = ImDrawData
---@param self ffi.ct* ImDrawData*
---@return nil
function ImDrawData:Clear()
    return lib.ImDrawData_Clear(self)
end
---@param self ffi.ct* ImDrawData*
---@return nil
function ImDrawData:DeIndexAllBuffers()
    return lib.ImDrawData_DeIndexAllBuffers(self)
end
function ImDrawData.__new(ctype)
    local ptr = lib.ImDrawData_ImDrawData()
    return ffi.gc(ptr,lib.ImDrawData_destroy)
end
---@param self ffi.ct* ImDrawData*
---@param fb_scale ImVec2
---@return nil
function ImDrawData:ScaleClipRects(fb_scale)
    return lib.ImDrawData_ScaleClipRects(self,fb_scale)
end
M.ImDrawData = ffi.metatype("ImDrawData",ImDrawData)
--------------------------ImDrawDataBuilder----------------------------
---@class ImDrawDataBuilder
local ImDrawDataBuilder= {}
ImDrawDataBuilder.__index = ImDrawDataBuilder
---@param self ffi.ct* ImDrawDataBuilder*
---@return nil
function ImDrawDataBuilder:Clear()
    return lib.ImDrawDataBuilder_Clear(self)
end
---@param self ffi.ct* ImDrawDataBuilder*
---@return nil
function ImDrawDataBuilder:ClearFreeMemory()
    return lib.ImDrawDataBuilder_ClearFreeMemory(self)
end
---@param self ffi.ct* ImDrawDataBuilder*
---@return nil
function ImDrawDataBuilder:FlattenIntoSingleLayer()
    return lib.ImDrawDataBuilder_FlattenIntoSingleLayer(self)
end
---@param self ffi.ct* ImDrawDataBuilder*
---@return number
function ImDrawDataBuilder:GetDrawListCount()
    return lib.ImDrawDataBuilder_GetDrawListCount(self)
end
M.ImDrawDataBuilder = ffi.metatype("ImDrawDataBuilder",ImDrawDataBuilder)
--------------------------ImDrawList----------------------------
---@class ImDrawList
local ImDrawList= {}
ImDrawList.__index = ImDrawList
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number
---@param thickness number
---@param num_segments number?
---@return nil
function ImDrawList:AddBezierCubic(p1,p2,p3,p4,col,thickness,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddBezierCubic(self,p1,p2,p3,p4,col,thickness,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number
---@param thickness number
---@param num_segments number?
---@return nil
function ImDrawList:AddBezierQuadratic(p1,p2,p3,col,thickness,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddBezierQuadratic(self,p1,p2,p3,col,thickness,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param callback ffi.ct* ImDrawCallback
---@param callback_data ffi.ct* void*
---@return nil
function ImDrawList:AddCallback(callback,callback_data)
    return lib.ImDrawList_AddCallback(self,callback,callback_data)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param col number
---@param num_segments number?
---@param thickness number?
---@return nil
function ImDrawList:AddCircle(center,radius,col,num_segments,thickness)
    num_segments = num_segments or 0
    thickness = thickness or 1.0
    return lib.ImDrawList_AddCircle(self,center,radius,col,num_segments,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param col number
---@param num_segments number?
---@return nil
function ImDrawList:AddCircleFilled(center,radius,col,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddCircleFilled(self,center,radius,col,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param points ffi.ct* const ImVec2*
---@param num_points number
---@param col number
---@return nil
function ImDrawList:AddConvexPolyFilled(points,num_points,col)
    return lib.ImDrawList_AddConvexPolyFilled(self,points,num_points,col)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:AddDrawCmd()
    return lib.ImDrawList_AddDrawCmd(self)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id ffi.ct* ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2?
---@param uv_max ImVec2?
---@param col number?
---@return nil
function ImDrawList:AddImage(user_texture_id,p_min,p_max,uv_min,uv_max,col)
    col = col or 4294967295
    uv_max = uv_max or ImVec2(1,1)
    uv_min = uv_min or ImVec2(0,0)
    return lib.ImDrawList_AddImage(self,user_texture_id,p_min,p_max,uv_min,uv_max,col)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id ffi.ct* ImTextureID
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param uv1 ImVec2?
---@param uv2 ImVec2?
---@param uv3 ImVec2?
---@param uv4 ImVec2?
---@param col number?
---@return nil
function ImDrawList:AddImageQuad(user_texture_id,p1,p2,p3,p4,uv1,uv2,uv3,uv4,col)
    col = col or 4294967295
    uv1 = uv1 or ImVec2(0,0)
    uv2 = uv2 or ImVec2(1,0)
    uv3 = uv3 or ImVec2(1,1)
    uv4 = uv4 or ImVec2(0,1)
    return lib.ImDrawList_AddImageQuad(self,user_texture_id,p1,p2,p3,p4,uv1,uv2,uv3,uv4,col)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id ffi.ct* ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2
---@param uv_max ImVec2
---@param col number
---@param rounding number
---@param flags number?
---@return nil
function ImDrawList:AddImageRounded(user_texture_id,p_min,p_max,uv_min,uv_max,col,rounding,flags)
    flags = flags or 0
    return lib.ImDrawList_AddImageRounded(self,user_texture_id,p_min,p_max,uv_min,uv_max,col,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param col number
---@param thickness number?
---@return nil
function ImDrawList:AddLine(p1,p2,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddLine(self,p1,p2,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param col number
---@param num_segments number
---@param thickness number?
---@return nil
function ImDrawList:AddNgon(center,radius,col,num_segments,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddNgon(self,center,radius,col,num_segments,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param col number
---@param num_segments number
---@return nil
function ImDrawList:AddNgonFilled(center,radius,col,num_segments)
    return lib.ImDrawList_AddNgonFilled(self,center,radius,col,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param points ffi.ct* const ImVec2*
---@param num_points number
---@param col number
---@param flags number
---@param thickness number
---@return nil
function ImDrawList:AddPolyline(points,num_points,col,flags,thickness)
    return lib.ImDrawList_AddPolyline(self,points,num_points,col,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number
---@param thickness number?
---@return nil
function ImDrawList:AddQuad(p1,p2,p3,p4,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddQuad(self,p1,p2,p3,p4,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number
---@return nil
function ImDrawList:AddQuadFilled(p1,p2,p3,p4,col)
    return lib.ImDrawList_AddQuadFilled(self,p1,p2,p3,p4,col)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col number
---@param rounding number?
---@param flags number?
---@param thickness number?
---@return nil
function ImDrawList:AddRect(p_min,p_max,col,rounding,flags,thickness)
    flags = flags or 0
    rounding = rounding or 0.0
    thickness = thickness or 1.0
    return lib.ImDrawList_AddRect(self,p_min,p_max,col,rounding,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col number
---@param rounding number?
---@param flags number?
---@return nil
function ImDrawList:AddRectFilled(p_min,p_max,col,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.ImDrawList_AddRectFilled(self,p_min,p_max,col,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col_upr_left number
---@param col_upr_right number
---@param col_bot_right number
---@param col_bot_left number
---@return nil
function ImDrawList:AddRectFilledMultiColor(p_min,p_max,col_upr_left,col_upr_right,col_bot_right,col_bot_left)
    return lib.ImDrawList_AddRectFilledMultiColor(self,p_min,p_max,col_upr_left,col_upr_right,col_bot_right,col_bot_left)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number
---@param text_begin string
---@param text_end string?
---@return nil
function ImDrawList:AddText_Vec2(pos,col,text_begin,text_end)
    text_end = text_end or nil
    return lib.ImDrawList_AddText_Vec2(self,pos,col,text_begin,text_end)
end
---@param self ffi.ct* ImDrawList*
---@param font ffi.ct* const ImFont*
---@param font_size number
---@param pos ImVec2
---@param col number
---@param text_begin string
---@param text_end string?
---@param wrap_width number?
---@param cpu_fine_clip_rect ffi.ct*? const ImVec4*
---@return nil
function ImDrawList:AddText_FontPtr(font,font_size,pos,col,text_begin,text_end,wrap_width,cpu_fine_clip_rect)
    cpu_fine_clip_rect = cpu_fine_clip_rect or nil
    text_end = text_end or nil
    wrap_width = wrap_width or 0.0
    return lib.ImDrawList_AddText_FontPtr(self,font,font_size,pos,col,text_begin,text_end,wrap_width,cpu_fine_clip_rect)
end
function ImDrawList:AddText(a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:AddText_Vec2(a2,a3,a4,a5) end
    if (ffi.istype('const ImFont*',a2) or ffi.istype('const ImFont',a2) or ffi.istype('const ImFont[]',a2)) then return self:AddText_FontPtr(a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a2,a3,a4,a5,a6,a7,a8,a9)
    error'ImDrawList:AddText could not find overloaded'
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number
---@param thickness number?
---@return nil
function ImDrawList:AddTriangle(p1,p2,p3,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddTriangle(self,p1,p2,p3,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number
---@return nil
function ImDrawList:AddTriangleFilled(p1,p2,p3,col)
    return lib.ImDrawList_AddTriangleFilled(self,p1,p2,p3,col)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:ChannelsMerge()
    return lib.ImDrawList_ChannelsMerge(self)
end
---@param self ffi.ct* ImDrawList*
---@param n number
---@return nil
function ImDrawList:ChannelsSetCurrent(n)
    return lib.ImDrawList_ChannelsSetCurrent(self,n)
end
---@param self ffi.ct* ImDrawList*
---@param count number
---@return nil
function ImDrawList:ChannelsSplit(count)
    return lib.ImDrawList_ChannelsSplit(self,count)
end
---@param self ffi.ct* ImDrawList*
---@return ffi.ct* ImDrawList*
function ImDrawList:CloneOutput()
    return lib.ImDrawList_CloneOutput(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:GetClipRectMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImDrawList_GetClipRectMax(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:GetClipRectMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImDrawList_GetClipRectMin(nonUDT_out,self)
    return nonUDT_out
end
function ImDrawList.__new(ctype,shared_data)
    local ptr = lib.ImDrawList_ImDrawList(shared_data)
    return ffi.gc(ptr,lib.ImDrawList_destroy)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param a_min number
---@param a_max number
---@param num_segments number?
---@return nil
function ImDrawList:PathArcTo(center,radius,a_min,a_max,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathArcTo(self,center,radius,a_min,a_max,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param a_min_of_12 number
---@param a_max_of_12 number
---@return nil
function ImDrawList:PathArcToFast(center,radius,a_min_of_12,a_max_of_12)
    return lib.ImDrawList_PathArcToFast(self,center,radius,a_min_of_12,a_max_of_12)
end
---@param self ffi.ct* ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param num_segments number?
---@return nil
function ImDrawList:PathBezierCubicCurveTo(p2,p3,p4,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathBezierCubicCurveTo(self,p2,p3,p4,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param num_segments number?
---@return nil
function ImDrawList:PathBezierQuadraticCurveTo(p2,p3,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathBezierQuadraticCurveTo(self,p2,p3,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PathClear()
    return lib.ImDrawList_PathClear(self)
end
---@param self ffi.ct* ImDrawList*
---@param col number
---@return nil
function ImDrawList:PathFillConvex(col)
    return lib.ImDrawList_PathFillConvex(self,col)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@return nil
function ImDrawList:PathLineTo(pos)
    return lib.ImDrawList_PathLineTo(self,pos)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@return nil
function ImDrawList:PathLineToMergeDuplicate(pos)
    return lib.ImDrawList_PathLineToMergeDuplicate(self,pos)
end
---@param self ffi.ct* ImDrawList*
---@param rect_min ImVec2
---@param rect_max ImVec2
---@param rounding number?
---@param flags number?
---@return nil
function ImDrawList:PathRect(rect_min,rect_max,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.ImDrawList_PathRect(self,rect_min,rect_max,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param col number
---@param flags number?
---@param thickness number?
---@return nil
function ImDrawList:PathStroke(col,flags,thickness)
    flags = flags or 0
    thickness = thickness or 1.0
    return lib.ImDrawList_PathStroke(self,col,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PopClipRect()
    return lib.ImDrawList_PopClipRect(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PopTextureID()
    return lib.ImDrawList_PopTextureID(self)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param d ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param uv_c ImVec2
---@param uv_d ImVec2
---@param col number
---@return nil
function ImDrawList:PrimQuadUV(a,b,c,d,uv_a,uv_b,uv_c,uv_d,col)
    return lib.ImDrawList_PrimQuadUV(self,a,b,c,d,uv_a,uv_b,uv_c,uv_d,col)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param col number
---@return nil
function ImDrawList:PrimRect(a,b,col)
    return lib.ImDrawList_PrimRect(self,a,b,col)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param col number
---@return nil
function ImDrawList:PrimRectUV(a,b,uv_a,uv_b,col)
    return lib.ImDrawList_PrimRectUV(self,a,b,uv_a,uv_b,col)
end
---@param self ffi.ct* ImDrawList*
---@param idx_count number
---@param vtx_count number
---@return nil
function ImDrawList:PrimReserve(idx_count,vtx_count)
    return lib.ImDrawList_PrimReserve(self,idx_count,vtx_count)
end
---@param self ffi.ct* ImDrawList*
---@param idx_count number
---@param vtx_count number
---@return nil
function ImDrawList:PrimUnreserve(idx_count,vtx_count)
    return lib.ImDrawList_PrimUnreserve(self,idx_count,vtx_count)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col number
---@return nil
function ImDrawList:PrimVtx(pos,uv,col)
    return lib.ImDrawList_PrimVtx(self,pos,uv,col)
end
---@param self ffi.ct* ImDrawList*
---@param idx ffi.ct* ImDrawIdx
---@return nil
function ImDrawList:PrimWriteIdx(idx)
    return lib.ImDrawList_PrimWriteIdx(self,idx)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col number
---@return nil
function ImDrawList:PrimWriteVtx(pos,uv,col)
    return lib.ImDrawList_PrimWriteVtx(self,pos,uv,col)
end
---@param self ffi.ct* ImDrawList*
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect boolean?
---@return nil
function ImDrawList:PushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
    intersect_with_current_clip_rect = intersect_with_current_clip_rect or false
    return lib.ImDrawList_PushClipRect(self,clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PushClipRectFullScreen()
    return lib.ImDrawList_PushClipRectFullScreen(self)
end
---@param self ffi.ct* ImDrawList*
---@param texture_id ffi.ct* ImTextureID
---@return nil
function ImDrawList:PushTextureID(texture_id)
    return lib.ImDrawList_PushTextureID(self,texture_id)
end
---@param self ffi.ct* ImDrawList*
---@param radius number
---@return number
function ImDrawList:_CalcCircleAutoSegmentCount(radius)
    return lib.ImDrawList__CalcCircleAutoSegmentCount(self,radius)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_ClearFreeMemory()
    return lib.ImDrawList__ClearFreeMemory(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedClipRect()
    return lib.ImDrawList__OnChangedClipRect(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedTextureID()
    return lib.ImDrawList__OnChangedTextureID(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedVtxOffset()
    return lib.ImDrawList__OnChangedVtxOffset(self)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param a_min_sample number
---@param a_max_sample number
---@param a_step number
---@return nil
function ImDrawList:_PathArcToFastEx(center,radius,a_min_sample,a_max_sample,a_step)
    return lib.ImDrawList__PathArcToFastEx(self,center,radius,a_min_sample,a_max_sample,a_step)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number
---@param a_min number
---@param a_max number
---@param num_segments number
---@return nil
function ImDrawList:_PathArcToN(center,radius,a_min,a_max,num_segments)
    return lib.ImDrawList__PathArcToN(self,center,radius,a_min,a_max,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_PopUnusedDrawCmd()
    return lib.ImDrawList__PopUnusedDrawCmd(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_ResetForNewFrame()
    return lib.ImDrawList__ResetForNewFrame(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_TryMergeDrawCmds()
    return lib.ImDrawList__TryMergeDrawCmds(self)
end
M.ImDrawList = ffi.metatype("ImDrawList",ImDrawList)
--------------------------ImDrawListSharedData----------------------------
---@class ImDrawListSharedData
local ImDrawListSharedData= {}
ImDrawListSharedData.__index = ImDrawListSharedData
function ImDrawListSharedData.__new(ctype)
    local ptr = lib.ImDrawListSharedData_ImDrawListSharedData()
    return ffi.gc(ptr,lib.ImDrawListSharedData_destroy)
end
---@param self ffi.ct* ImDrawListSharedData*
---@param max_error number
---@return nil
function ImDrawListSharedData:SetCircleTessellationMaxError(max_error)
    return lib.ImDrawListSharedData_SetCircleTessellationMaxError(self,max_error)
end
M.ImDrawListSharedData = ffi.metatype("ImDrawListSharedData",ImDrawListSharedData)
--------------------------ImDrawListSplitter----------------------------
---@class ImDrawListSplitter
local ImDrawListSplitter= {}
ImDrawListSplitter.__index = ImDrawListSplitter
---@param self ffi.ct* ImDrawListSplitter*
---@return nil
function ImDrawListSplitter:Clear()
    return lib.ImDrawListSplitter_Clear(self)
end
---@param self ffi.ct* ImDrawListSplitter*
---@return nil
function ImDrawListSplitter:ClearFreeMemory()
    return lib.ImDrawListSplitter_ClearFreeMemory(self)
end
function ImDrawListSplitter.__new(ctype)
    local ptr = lib.ImDrawListSplitter_ImDrawListSplitter()
    return ffi.gc(ptr,lib.ImDrawListSplitter_destroy)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function ImDrawListSplitter:Merge(draw_list)
    return lib.ImDrawListSplitter_Merge(self,draw_list)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@param channel_idx number
---@return nil
function ImDrawListSplitter:SetCurrentChannel(draw_list,channel_idx)
    return lib.ImDrawListSplitter_SetCurrentChannel(self,draw_list,channel_idx)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@param count number
---@return nil
function ImDrawListSplitter:Split(draw_list,count)
    return lib.ImDrawListSplitter_Split(self,draw_list,count)
end
M.ImDrawListSplitter = ffi.metatype("ImDrawListSplitter",ImDrawListSplitter)
--------------------------ImFont----------------------------
---@class ImFont
local ImFont= {}
ImFont.__index = ImFont
---@param self ffi.ct* ImFont*
---@param src_cfg ffi.ct* const ImFontConfig*
---@param c ffi.ct* ImWchar
---@param x0 number
---@param y0 number
---@param x1 number
---@param y1 number
---@param u0 number
---@param v0 number
---@param u1 number
---@param v1 number
---@param advance_x number
---@return nil
function ImFont:AddGlyph(src_cfg,c,x0,y0,x1,y1,u0,v0,u1,v1,advance_x)
    return lib.ImFont_AddGlyph(self,src_cfg,c,x0,y0,x1,y1,u0,v0,u1,v1,advance_x)
end
---@param self ffi.ct* ImFont*
---@param dst ffi.ct* ImWchar
---@param src ffi.ct* ImWchar
---@param overwrite_dst boolean?
---@return nil
function ImFont:AddRemapChar(dst,src,overwrite_dst)
    if overwrite_dst == nil then overwrite_dst = true end
    return lib.ImFont_AddRemapChar(self,dst,src,overwrite_dst)
end
---@param self ffi.ct* ImFont*
---@return nil
function ImFont:BuildLookupTable()
    return lib.ImFont_BuildLookupTable(self)
end
---@param self ffi.ct* ImFont*
---@param size number
---@param max_width number
---@param wrap_width number
---@param text_begin string
---@param text_end string?
---@param remaining ffi.ct*? const char**
---@return nil
function ImFont:CalcTextSizeA(size,max_width,wrap_width,text_begin,text_end,remaining)
    remaining = remaining or nil
    text_end = text_end or nil
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImFont_CalcTextSizeA(nonUDT_out,self,size,max_width,wrap_width,text_begin,text_end,remaining)
    return nonUDT_out
end
---@param self ffi.ct* ImFont*
---@param scale number
---@param text string
---@param text_end string
---@param wrap_width number
---@return string
function ImFont:CalcWordWrapPositionA(scale,text,text_end,wrap_width)
    return ffi.string(lib.ImFont_CalcWordWrapPositionA(self,scale,text,text_end,wrap_width))
end
---@param self ffi.ct* ImFont*
---@return nil
function ImFont:ClearOutputData()
    return lib.ImFont_ClearOutputData(self)
end
---@param self ffi.ct* ImFont*
---@param c ffi.ct* ImWchar
---@return ffi.ct* const ImFontGlyph*
function ImFont:FindGlyph(c)
    return lib.ImFont_FindGlyph(self,c)
end
---@param self ffi.ct* ImFont*
---@param c ffi.ct* ImWchar
---@return ffi.ct* const ImFontGlyph*
function ImFont:FindGlyphNoFallback(c)
    return lib.ImFont_FindGlyphNoFallback(self,c)
end
---@param self ffi.ct* ImFont*
---@param c ffi.ct* ImWchar
---@return number
function ImFont:GetCharAdvance(c)
    return lib.ImFont_GetCharAdvance(self,c)
end
---@param self ffi.ct* ImFont*
---@return string
function ImFont:GetDebugName()
    return ffi.string(lib.ImFont_GetDebugName(self))
end
---@param self ffi.ct* ImFont*
---@param new_size number
---@return nil
function ImFont:GrowIndex(new_size)
    return lib.ImFont_GrowIndex(self,new_size)
end
function ImFont.__new(ctype)
    local ptr = lib.ImFont_ImFont()
    return ffi.gc(ptr,lib.ImFont_destroy)
end
---@param self ffi.ct* ImFont*
---@param c_begin number
---@param c_last number
---@return boolean
function ImFont:IsGlyphRangeUnused(c_begin,c_last)
    return lib.ImFont_IsGlyphRangeUnused(self,c_begin,c_last)
end
---@param self ffi.ct* ImFont*
---@return boolean
function ImFont:IsLoaded()
    return lib.ImFont_IsLoaded(self)
end
---@param self ffi.ct* ImFont*
---@param draw_list ffi.ct* ImDrawList*
---@param size number
---@param pos ImVec2
---@param col number
---@param c ffi.ct* ImWchar
---@return nil
function ImFont:RenderChar(draw_list,size,pos,col,c)
    return lib.ImFont_RenderChar(self,draw_list,size,pos,col,c)
end
---@param self ffi.ct* ImFont*
---@param draw_list ffi.ct* ImDrawList*
---@param size number
---@param pos ImVec2
---@param col number
---@param clip_rect ffi.ct* const ImVec4
---@param text_begin string
---@param text_end string
---@param wrap_width number?
---@param cpu_fine_clip boolean?
---@return nil
function ImFont:RenderText(draw_list,size,pos,col,clip_rect,text_begin,text_end,wrap_width,cpu_fine_clip)
    cpu_fine_clip = cpu_fine_clip or false
    wrap_width = wrap_width or 0.0
    return lib.ImFont_RenderText(self,draw_list,size,pos,col,clip_rect,text_begin,text_end,wrap_width,cpu_fine_clip)
end
---@param self ffi.ct* ImFont*
---@param c ffi.ct* ImWchar
---@param visible boolean
---@return nil
function ImFont:SetGlyphVisible(c,visible)
    return lib.ImFont_SetGlyphVisible(self,c,visible)
end
M.ImFont = ffi.metatype("ImFont",ImFont)
--------------------------ImFontAtlas----------------------------
---@class ImFontAtlas
local ImFontAtlas= {}
ImFontAtlas.__index = ImFontAtlas
---@param self ffi.ct* ImFontAtlas*
---@param font ffi.ct* ImFont*
---@param id ffi.ct* ImWchar
---@param width number
---@param height number
---@param advance_x number
---@param offset ImVec2?
---@return number
function ImFontAtlas:AddCustomRectFontGlyph(font,id,width,height,advance_x,offset)
    offset = offset or ImVec2(0,0)
    return lib.ImFontAtlas_AddCustomRectFontGlyph(self,font,id,width,height,advance_x,offset)
end
---@param self ffi.ct* ImFontAtlas*
---@param width number
---@param height number
---@return number
function ImFontAtlas:AddCustomRectRegular(width,height)
    return lib.ImFontAtlas_AddCustomRectRegular(self,width,height)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_cfg ffi.ct* const ImFontConfig*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFont(font_cfg)
    return lib.ImFontAtlas_AddFont(self,font_cfg)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_cfg ffi.ct*? const ImFontConfig*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontDefault(font_cfg)
    font_cfg = font_cfg or nil
    return lib.ImFontAtlas_AddFontDefault(self,font_cfg)
end
---@param self ffi.ct* ImFontAtlas*
---@param filename string
---@param size_pixels number
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromFileTTF(filename,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromFileTTF(self,filename,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param compressed_font_data_base85 string
---@param size_pixels number
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryCompressedBase85TTF(compressed_font_data_base85,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self,compressed_font_data_base85,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param compressed_font_data ffi.ct* const void*
---@param compressed_font_size number
---@param size_pixels number
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryCompressedTTF(compressed_font_data,compressed_font_size,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryCompressedTTF(self,compressed_font_data,compressed_font_size,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_data ffi.ct* void*
---@param font_size number
---@param size_pixels number
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryTTF(font_data,font_size,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryTTF(self,font_data,font_size,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@return boolean
function ImFontAtlas:Build()
    return lib.ImFontAtlas_Build(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param rect ffi.ct* const ImFontAtlasCustomRect*
---@param out_uv_min ffi.ct* ImVec2*
---@param out_uv_max ffi.ct* ImVec2*
---@return nil
function ImFontAtlas:CalcCustomRectUV(rect,out_uv_min,out_uv_max)
    return lib.ImFontAtlas_CalcCustomRectUV(self,rect,out_uv_min,out_uv_max)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:Clear()
    return lib.ImFontAtlas_Clear(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearFonts()
    return lib.ImFontAtlas_ClearFonts(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearInputData()
    return lib.ImFontAtlas_ClearInputData(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearTexData()
    return lib.ImFontAtlas_ClearTexData(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param index number
---@return ffi.ct* ImFontAtlasCustomRect*
function ImFontAtlas:GetCustomRectByIndex(index)
    return lib.ImFontAtlas_GetCustomRectByIndex(self,index)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesChineseFull()
    return lib.ImFontAtlas_GetGlyphRangesChineseFull(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesChineseSimplifiedCommon()
    return lib.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesCyrillic()
    return lib.ImFontAtlas_GetGlyphRangesCyrillic(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesDefault()
    return lib.ImFontAtlas_GetGlyphRangesDefault(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesGreek()
    return lib.ImFontAtlas_GetGlyphRangesGreek(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesJapanese()
    return lib.ImFontAtlas_GetGlyphRangesJapanese(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesKorean()
    return lib.ImFontAtlas_GetGlyphRangesKorean(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesThai()
    return lib.ImFontAtlas_GetGlyphRangesThai(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesVietnamese()
    return lib.ImFontAtlas_GetGlyphRangesVietnamese(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param cursor number
---@param out_offset ffi.ct* ImVec2*
---@param out_size ffi.ct* ImVec2*
---@param out_uv_border ffi.ct* ImVec2[2]
---@param out_uv_fill ffi.ct* ImVec2[2]
---@return boolean
function ImFontAtlas:GetMouseCursorTexData(cursor,out_offset,out_size,out_uv_border,out_uv_fill)
    return lib.ImFontAtlas_GetMouseCursorTexData(self,cursor,out_offset,out_size,out_uv_border,out_uv_fill)
end
---@param self ffi.ct* ImFontAtlas*
---@param out_pixels ffi.ct* unsigned char**
---@param out_width ffi.ct* int*
---@param out_height ffi.ct* int*
---@param out_bytes_per_pixel ffi.ct*? int*
---@return nil
function ImFontAtlas:GetTexDataAsAlpha8(out_pixels,out_width,out_height,out_bytes_per_pixel)
    out_bytes_per_pixel = out_bytes_per_pixel or nil
    return lib.ImFontAtlas_GetTexDataAsAlpha8(self,out_pixels,out_width,out_height,out_bytes_per_pixel)
end
---@param self ffi.ct* ImFontAtlas*
---@param out_pixels ffi.ct* unsigned char**
---@param out_width ffi.ct* int*
---@param out_height ffi.ct* int*
---@param out_bytes_per_pixel ffi.ct*? int*
---@return nil
function ImFontAtlas:GetTexDataAsRGBA32(out_pixels,out_width,out_height,out_bytes_per_pixel)
    out_bytes_per_pixel = out_bytes_per_pixel or nil
    return lib.ImFontAtlas_GetTexDataAsRGBA32(self,out_pixels,out_width,out_height,out_bytes_per_pixel)
end
function ImFontAtlas.__new(ctype)
    local ptr = lib.ImFontAtlas_ImFontAtlas()
    return ffi.gc(ptr,lib.ImFontAtlas_destroy)
end
---@param self ffi.ct* ImFontAtlas*
---@return boolean
function ImFontAtlas:IsBuilt()
    return lib.ImFontAtlas_IsBuilt(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param id ffi.ct* ImTextureID
---@return nil
function ImFontAtlas:SetTexID(id)
    return lib.ImFontAtlas_SetTexID(self,id)
end
M.ImFontAtlas = ffi.metatype("ImFontAtlas",ImFontAtlas)
--------------------------ImFontAtlasCustomRect----------------------------
---@class ImFontAtlasCustomRect
local ImFontAtlasCustomRect= {}
ImFontAtlasCustomRect.__index = ImFontAtlasCustomRect
function ImFontAtlasCustomRect.__new(ctype)
    local ptr = lib.ImFontAtlasCustomRect_ImFontAtlasCustomRect()
    return ffi.gc(ptr,lib.ImFontAtlasCustomRect_destroy)
end
---@param self ffi.ct* ImFontAtlasCustomRect*
---@return boolean
function ImFontAtlasCustomRect:IsPacked()
    return lib.ImFontAtlasCustomRect_IsPacked(self)
end
M.ImFontAtlasCustomRect = ffi.metatype("ImFontAtlasCustomRect",ImFontAtlasCustomRect)
--------------------------ImFontConfig----------------------------
---@class ImFontConfig
local ImFontConfig= {}
ImFontConfig.__index = ImFontConfig
function ImFontConfig.__new(ctype)
    local ptr = lib.ImFontConfig_ImFontConfig()
    return ffi.gc(ptr,lib.ImFontConfig_destroy)
end
M.ImFontConfig = ffi.metatype("ImFontConfig",ImFontConfig)
--------------------------ImFontGlyphRangesBuilder----------------------------
---@class ImFontGlyphRangesBuilder
local ImFontGlyphRangesBuilder= {}
ImFontGlyphRangesBuilder.__index = ImFontGlyphRangesBuilder
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param c ffi.ct* ImWchar
---@return nil
function ImFontGlyphRangesBuilder:AddChar(c)
    return lib.ImFontGlyphRangesBuilder_AddChar(self,c)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param ranges ffi.ct* const ImWchar*
---@return nil
function ImFontGlyphRangesBuilder:AddRanges(ranges)
    return lib.ImFontGlyphRangesBuilder_AddRanges(self,ranges)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param text string
---@param text_end string?
---@return nil
function ImFontGlyphRangesBuilder:AddText(text,text_end)
    text_end = text_end or nil
    return lib.ImFontGlyphRangesBuilder_AddText(self,text,text_end)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param out_ranges ffi.ct* ImVector_ImWchar*
---@return nil
function ImFontGlyphRangesBuilder:BuildRanges(out_ranges)
    return lib.ImFontGlyphRangesBuilder_BuildRanges(self,out_ranges)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@return nil
function ImFontGlyphRangesBuilder:Clear()
    return lib.ImFontGlyphRangesBuilder_Clear(self)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param n number
---@return boolean
function ImFontGlyphRangesBuilder:GetBit(n)
    return lib.ImFontGlyphRangesBuilder_GetBit(self,n)
end
function ImFontGlyphRangesBuilder.__new(ctype)
    local ptr = lib.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder()
    return ffi.gc(ptr,lib.ImFontGlyphRangesBuilder_destroy)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param n number
---@return nil
function ImFontGlyphRangesBuilder:SetBit(n)
    return lib.ImFontGlyphRangesBuilder_SetBit(self,n)
end
M.ImFontGlyphRangesBuilder = ffi.metatype("ImFontGlyphRangesBuilder",ImFontGlyphRangesBuilder)
--------------------------ImGuiComboPreviewData----------------------------
---@class ImGuiComboPreviewData
local ImGuiComboPreviewData= {}
ImGuiComboPreviewData.__index = ImGuiComboPreviewData
function ImGuiComboPreviewData.__new(ctype)
    local ptr = lib.ImGuiComboPreviewData_ImGuiComboPreviewData()
    return ffi.gc(ptr,lib.ImGuiComboPreviewData_destroy)
end
M.ImGuiComboPreviewData = ffi.metatype("ImGuiComboPreviewData",ImGuiComboPreviewData)
--------------------------ImGuiContext----------------------------
---@class ImGuiContext
local ImGuiContext= {}
ImGuiContext.__index = ImGuiContext
function ImGuiContext.__new(ctype,shared_font_atlas)
    local ptr = lib.ImGuiContext_ImGuiContext(shared_font_atlas)
    return ffi.gc(ptr,lib.ImGuiContext_destroy)
end
M.ImGuiContext = ffi.metatype("ImGuiContext",ImGuiContext)
--------------------------ImGuiContextHook----------------------------
---@class ImGuiContextHook
local ImGuiContextHook= {}
ImGuiContextHook.__index = ImGuiContextHook
function ImGuiContextHook.__new(ctype)
    local ptr = lib.ImGuiContextHook_ImGuiContextHook()
    return ffi.gc(ptr,lib.ImGuiContextHook_destroy)
end
M.ImGuiContextHook = ffi.metatype("ImGuiContextHook",ImGuiContextHook)
--------------------------ImGuiIO----------------------------
---@class ImGuiIO
local ImGuiIO= {}
ImGuiIO.__index = ImGuiIO
---@param self ffi.ct* ImGuiIO*
---@param focused boolean
---@return nil
function ImGuiIO:AddFocusEvent(focused)
    return lib.ImGuiIO_AddFocusEvent(self,focused)
end
---@param self ffi.ct* ImGuiIO*
---@param c number
---@return nil
function ImGuiIO:AddInputCharacter(c)
    return lib.ImGuiIO_AddInputCharacter(self,c)
end
---@param self ffi.ct* ImGuiIO*
---@param c ffi.ct* ImWchar16
---@return nil
function ImGuiIO:AddInputCharacterUTF16(c)
    return lib.ImGuiIO_AddInputCharacterUTF16(self,c)
end
---@param self ffi.ct* ImGuiIO*
---@param str string
---@return nil
function ImGuiIO:AddInputCharactersUTF8(str)
    return lib.ImGuiIO_AddInputCharactersUTF8(self,str)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param down boolean
---@param v number
---@return nil
function ImGuiIO:AddKeyAnalogEvent(key,down,v)
    return lib.ImGuiIO_AddKeyAnalogEvent(self,key,down,v)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param down boolean
---@return nil
function ImGuiIO:AddKeyEvent(key,down)
    return lib.ImGuiIO_AddKeyEvent(self,key,down)
end
---@param self ffi.ct* ImGuiIO*
---@param button number
---@param down boolean
---@return nil
function ImGuiIO:AddMouseButtonEvent(button,down)
    return lib.ImGuiIO_AddMouseButtonEvent(self,button,down)
end
---@param self ffi.ct* ImGuiIO*
---@param x number
---@param y number
---@return nil
function ImGuiIO:AddMousePosEvent(x,y)
    return lib.ImGuiIO_AddMousePosEvent(self,x,y)
end
---@param self ffi.ct* ImGuiIO*
---@param wheel_x number
---@param wheel_y number
---@return nil
function ImGuiIO:AddMouseWheelEvent(wheel_x,wheel_y)
    return lib.ImGuiIO_AddMouseWheelEvent(self,wheel_x,wheel_y)
end
---@param self ffi.ct* ImGuiIO*
---@return nil
function ImGuiIO:ClearInputCharacters()
    return lib.ImGuiIO_ClearInputCharacters(self)
end
---@param self ffi.ct* ImGuiIO*
---@return nil
function ImGuiIO:ClearInputKeys()
    return lib.ImGuiIO_ClearInputKeys(self)
end
function ImGuiIO.__new(ctype)
    local ptr = lib.ImGuiIO_ImGuiIO()
    return ffi.gc(ptr,lib.ImGuiIO_destroy)
end
---@param self ffi.ct* ImGuiIO*
---@param accepting_events boolean
---@return nil
function ImGuiIO:SetAppAcceptingEvents(accepting_events)
    return lib.ImGuiIO_SetAppAcceptingEvents(self,accepting_events)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param native_keycode number
---@param native_scancode number
---@param native_legacy_index number?
---@return nil
function ImGuiIO:SetKeyEventNativeData(key,native_keycode,native_scancode,native_legacy_index)
    native_legacy_index = native_legacy_index or -1
    return lib.ImGuiIO_SetKeyEventNativeData(self,key,native_keycode,native_scancode,native_legacy_index)
end
M.ImGuiIO = ffi.metatype("ImGuiIO",ImGuiIO)
--------------------------ImGuiInputEvent----------------------------
---@class ImGuiInputEvent
local ImGuiInputEvent= {}
ImGuiInputEvent.__index = ImGuiInputEvent
function ImGuiInputEvent.__new(ctype)
    local ptr = lib.ImGuiInputEvent_ImGuiInputEvent()
    return ffi.gc(ptr,lib.ImGuiInputEvent_destroy)
end
M.ImGuiInputEvent = ffi.metatype("ImGuiInputEvent",ImGuiInputEvent)
--------------------------ImGuiInputTextCallbackData----------------------------
---@class ImGuiInputTextCallbackData
local ImGuiInputTextCallbackData= {}
ImGuiInputTextCallbackData.__index = ImGuiInputTextCallbackData
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return nil
function ImGuiInputTextCallbackData:ClearSelection()
    return lib.ImGuiInputTextCallbackData_ClearSelection(self)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@param pos number
---@param bytes_count number
---@return nil
function ImGuiInputTextCallbackData:DeleteChars(pos,bytes_count)
    return lib.ImGuiInputTextCallbackData_DeleteChars(self,pos,bytes_count)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return boolean
function ImGuiInputTextCallbackData:HasSelection()
    return lib.ImGuiInputTextCallbackData_HasSelection(self)
end
function ImGuiInputTextCallbackData.__new(ctype)
    local ptr = lib.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData()
    return ffi.gc(ptr,lib.ImGuiInputTextCallbackData_destroy)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@param pos number
---@param text string
---@param text_end string?
---@return nil
function ImGuiInputTextCallbackData:InsertChars(pos,text,text_end)
    text_end = text_end or nil
    return lib.ImGuiInputTextCallbackData_InsertChars(self,pos,text,text_end)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return nil
function ImGuiInputTextCallbackData:SelectAll()
    return lib.ImGuiInputTextCallbackData_SelectAll(self)
end
M.ImGuiInputTextCallbackData = ffi.metatype("ImGuiInputTextCallbackData",ImGuiInputTextCallbackData)
--------------------------ImGuiInputTextState----------------------------
---@class ImGuiInputTextState
local ImGuiInputTextState= {}
ImGuiInputTextState.__index = ImGuiInputTextState
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearFreeMemory()
    return lib.ImGuiInputTextState_ClearFreeMemory(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearSelection()
    return lib.ImGuiInputTextState_ClearSelection(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearText()
    return lib.ImGuiInputTextState_ClearText(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:CursorAnimReset()
    return lib.ImGuiInputTextState_CursorAnimReset(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:CursorClamp()
    return lib.ImGuiInputTextState_CursorClamp(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number
function ImGuiInputTextState:GetCursorPos()
    return lib.ImGuiInputTextState_GetCursorPos(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number
function ImGuiInputTextState:GetRedoAvailCount()
    return lib.ImGuiInputTextState_GetRedoAvailCount(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number
function ImGuiInputTextState:GetSelectionEnd()
    return lib.ImGuiInputTextState_GetSelectionEnd(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number
function ImGuiInputTextState:GetSelectionStart()
    return lib.ImGuiInputTextState_GetSelectionStart(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number
function ImGuiInputTextState:GetUndoAvailCount()
    return lib.ImGuiInputTextState_GetUndoAvailCount(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return boolean
function ImGuiInputTextState:HasSelection()
    return lib.ImGuiInputTextState_HasSelection(self)
end
function ImGuiInputTextState.__new(ctype,ctx)
    local ptr = lib.ImGuiInputTextState_ImGuiInputTextState(ctx)
    return ffi.gc(ptr,lib.ImGuiInputTextState_destroy)
end
---@param self ffi.ct* ImGuiInputTextState*
---@param key number
---@return nil
function ImGuiInputTextState:OnKeyPressed(key)
    return lib.ImGuiInputTextState_OnKeyPressed(self,key)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:SelectAll()
    return lib.ImGuiInputTextState_SelectAll(self)
end
M.ImGuiInputTextState = ffi.metatype("ImGuiInputTextState",ImGuiInputTextState)
--------------------------ImGuiKeyOwnerData----------------------------
---@class ImGuiKeyOwnerData
local ImGuiKeyOwnerData= {}
ImGuiKeyOwnerData.__index = ImGuiKeyOwnerData
function ImGuiKeyOwnerData.__new(ctype)
    local ptr = lib.ImGuiKeyOwnerData_ImGuiKeyOwnerData()
    return ffi.gc(ptr,lib.ImGuiKeyOwnerData_destroy)
end
M.ImGuiKeyOwnerData = ffi.metatype("ImGuiKeyOwnerData",ImGuiKeyOwnerData)
--------------------------ImGuiKeyRoutingData----------------------------
---@class ImGuiKeyRoutingData
local ImGuiKeyRoutingData= {}
ImGuiKeyRoutingData.__index = ImGuiKeyRoutingData
function ImGuiKeyRoutingData.__new(ctype)
    local ptr = lib.ImGuiKeyRoutingData_ImGuiKeyRoutingData()
    return ffi.gc(ptr,lib.ImGuiKeyRoutingData_destroy)
end
M.ImGuiKeyRoutingData = ffi.metatype("ImGuiKeyRoutingData",ImGuiKeyRoutingData)
--------------------------ImGuiKeyRoutingTable----------------------------
---@class ImGuiKeyRoutingTable
local ImGuiKeyRoutingTable= {}
ImGuiKeyRoutingTable.__index = ImGuiKeyRoutingTable
---@param self ffi.ct* ImGuiKeyRoutingTable*
---@return nil
function ImGuiKeyRoutingTable:Clear()
    return lib.ImGuiKeyRoutingTable_Clear(self)
end
function ImGuiKeyRoutingTable.__new(ctype)
    local ptr = lib.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable()
    return ffi.gc(ptr,lib.ImGuiKeyRoutingTable_destroy)
end
M.ImGuiKeyRoutingTable = ffi.metatype("ImGuiKeyRoutingTable",ImGuiKeyRoutingTable)
--------------------------ImGuiLastItemData----------------------------
---@class ImGuiLastItemData
local ImGuiLastItemData= {}
ImGuiLastItemData.__index = ImGuiLastItemData
function ImGuiLastItemData.__new(ctype)
    local ptr = lib.ImGuiLastItemData_ImGuiLastItemData()
    return ffi.gc(ptr,lib.ImGuiLastItemData_destroy)
end
M.ImGuiLastItemData = ffi.metatype("ImGuiLastItemData",ImGuiLastItemData)
--------------------------ImGuiListClipper----------------------------
---@class ImGuiListClipper
local ImGuiListClipper= {}
ImGuiListClipper.__index = ImGuiListClipper
---@param self ffi.ct* ImGuiListClipper*
---@param items_count number
---@param items_height number?
---@return nil
function ImGuiListClipper:Begin(items_count,items_height)
    items_height = items_height or -1.0
    return lib.ImGuiListClipper_Begin(self,items_count,items_height)
end
---@param self ffi.ct* ImGuiListClipper*
---@return nil
function ImGuiListClipper:End()
    return lib.ImGuiListClipper_End(self)
end
---@param self ffi.ct* ImGuiListClipper*
---@param item_min number
---@param item_max number
---@return nil
function ImGuiListClipper:ForceDisplayRangeByIndices(item_min,item_max)
    return lib.ImGuiListClipper_ForceDisplayRangeByIndices(self,item_min,item_max)
end
function ImGuiListClipper.__new(ctype)
    local ptr = lib.ImGuiListClipper_ImGuiListClipper()
    return ffi.gc(ptr,lib.ImGuiListClipper_destroy)
end
---@param self ffi.ct* ImGuiListClipper*
---@return boolean
function ImGuiListClipper:Step()
    return lib.ImGuiListClipper_Step(self)
end
M.ImGuiListClipper = ffi.metatype("ImGuiListClipper",ImGuiListClipper)
--------------------------ImGuiListClipperData----------------------------
---@class ImGuiListClipperData
local ImGuiListClipperData= {}
ImGuiListClipperData.__index = ImGuiListClipperData
function ImGuiListClipperData.__new(ctype)
    local ptr = lib.ImGuiListClipperData_ImGuiListClipperData()
    return ffi.gc(ptr,lib.ImGuiListClipperData_destroy)
end
---@param self ffi.ct* ImGuiListClipperData*
---@param clipper ffi.ct* ImGuiListClipper*
---@return nil
function ImGuiListClipperData:Reset(clipper)
    return lib.ImGuiListClipperData_Reset(self,clipper)
end
M.ImGuiListClipperData = ffi.metatype("ImGuiListClipperData",ImGuiListClipperData)
--------------------------ImGuiListClipperRange----------------------------
---@class ImGuiListClipperRange
local ImGuiListClipperRange= {}
ImGuiListClipperRange.__index = ImGuiListClipperRange
---@param min number
---@param max number
---@return ImGuiListClipperRange
function M.ImGuiListClipperRange_FromIndices(min,max)
    return lib.ImGuiListClipperRange_FromIndices(min,max)
end
---@param y1 number
---@param y2 number
---@param off_min number
---@param off_max number
---@return ImGuiListClipperRange
function M.ImGuiListClipperRange_FromPositions(y1,y2,off_min,off_max)
    return lib.ImGuiListClipperRange_FromPositions(y1,y2,off_min,off_max)
end
M.ImGuiListClipperRange = ffi.metatype("ImGuiListClipperRange",ImGuiListClipperRange)
--------------------------ImGuiMenuColumns----------------------------
---@class ImGuiMenuColumns
local ImGuiMenuColumns= {}
ImGuiMenuColumns.__index = ImGuiMenuColumns
---@param self ffi.ct* ImGuiMenuColumns*
---@param update_offsets boolean
---@return nil
function ImGuiMenuColumns:CalcNextTotalWidth(update_offsets)
    return lib.ImGuiMenuColumns_CalcNextTotalWidth(self,update_offsets)
end
---@param self ffi.ct* ImGuiMenuColumns*
---@param w_icon number
---@param w_label number
---@param w_shortcut number
---@param w_mark number
---@return number
function ImGuiMenuColumns:DeclColumns(w_icon,w_label,w_shortcut,w_mark)
    return lib.ImGuiMenuColumns_DeclColumns(self,w_icon,w_label,w_shortcut,w_mark)
end
function ImGuiMenuColumns.__new(ctype)
    local ptr = lib.ImGuiMenuColumns_ImGuiMenuColumns()
    return ffi.gc(ptr,lib.ImGuiMenuColumns_destroy)
end
---@param self ffi.ct* ImGuiMenuColumns*
---@param spacing number
---@param window_reappearing boolean
---@return nil
function ImGuiMenuColumns:Update(spacing,window_reappearing)
    return lib.ImGuiMenuColumns_Update(self,spacing,window_reappearing)
end
M.ImGuiMenuColumns = ffi.metatype("ImGuiMenuColumns",ImGuiMenuColumns)
--------------------------ImGuiNavItemData----------------------------
---@class ImGuiNavItemData
local ImGuiNavItemData= {}
ImGuiNavItemData.__index = ImGuiNavItemData
---@param self ffi.ct* ImGuiNavItemData*
---@return nil
function ImGuiNavItemData:Clear()
    return lib.ImGuiNavItemData_Clear(self)
end
function ImGuiNavItemData.__new(ctype)
    local ptr = lib.ImGuiNavItemData_ImGuiNavItemData()
    return ffi.gc(ptr,lib.ImGuiNavItemData_destroy)
end
M.ImGuiNavItemData = ffi.metatype("ImGuiNavItemData",ImGuiNavItemData)
--------------------------ImGuiNextItemData----------------------------
---@class ImGuiNextItemData
local ImGuiNextItemData= {}
ImGuiNextItemData.__index = ImGuiNextItemData
---@param self ffi.ct* ImGuiNextItemData*
---@return nil
function ImGuiNextItemData:ClearFlags()
    return lib.ImGuiNextItemData_ClearFlags(self)
end
function ImGuiNextItemData.__new(ctype)
    local ptr = lib.ImGuiNextItemData_ImGuiNextItemData()
    return ffi.gc(ptr,lib.ImGuiNextItemData_destroy)
end
M.ImGuiNextItemData = ffi.metatype("ImGuiNextItemData",ImGuiNextItemData)
--------------------------ImGuiNextWindowData----------------------------
---@class ImGuiNextWindowData
local ImGuiNextWindowData= {}
ImGuiNextWindowData.__index = ImGuiNextWindowData
---@param self ffi.ct* ImGuiNextWindowData*
---@return nil
function ImGuiNextWindowData:ClearFlags()
    return lib.ImGuiNextWindowData_ClearFlags(self)
end
function ImGuiNextWindowData.__new(ctype)
    local ptr = lib.ImGuiNextWindowData_ImGuiNextWindowData()
    return ffi.gc(ptr,lib.ImGuiNextWindowData_destroy)
end
M.ImGuiNextWindowData = ffi.metatype("ImGuiNextWindowData",ImGuiNextWindowData)
--------------------------ImGuiOldColumnData----------------------------
---@class ImGuiOldColumnData
local ImGuiOldColumnData= {}
ImGuiOldColumnData.__index = ImGuiOldColumnData
function ImGuiOldColumnData.__new(ctype)
    local ptr = lib.ImGuiOldColumnData_ImGuiOldColumnData()
    return ffi.gc(ptr,lib.ImGuiOldColumnData_destroy)
end
M.ImGuiOldColumnData = ffi.metatype("ImGuiOldColumnData",ImGuiOldColumnData)
--------------------------ImGuiOldColumns----------------------------
---@class ImGuiOldColumns
local ImGuiOldColumns= {}
ImGuiOldColumns.__index = ImGuiOldColumns
function ImGuiOldColumns.__new(ctype)
    local ptr = lib.ImGuiOldColumns_ImGuiOldColumns()
    return ffi.gc(ptr,lib.ImGuiOldColumns_destroy)
end
M.ImGuiOldColumns = ffi.metatype("ImGuiOldColumns",ImGuiOldColumns)
--------------------------ImGuiOnceUponAFrame----------------------------
---@class ImGuiOnceUponAFrame
local ImGuiOnceUponAFrame= {}
ImGuiOnceUponAFrame.__index = ImGuiOnceUponAFrame
function ImGuiOnceUponAFrame.__new(ctype)
    local ptr = lib.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame()
    return ffi.gc(ptr,lib.ImGuiOnceUponAFrame_destroy)
end
M.ImGuiOnceUponAFrame = ffi.metatype("ImGuiOnceUponAFrame",ImGuiOnceUponAFrame)
--------------------------ImGuiPayload----------------------------
---@class ImGuiPayload
local ImGuiPayload= {}
ImGuiPayload.__index = ImGuiPayload
---@param self ffi.ct* ImGuiPayload*
---@return nil
function ImGuiPayload:Clear()
    return lib.ImGuiPayload_Clear(self)
end
function ImGuiPayload.__new(ctype)
    local ptr = lib.ImGuiPayload_ImGuiPayload()
    return ffi.gc(ptr,lib.ImGuiPayload_destroy)
end
---@param self ffi.ct* ImGuiPayload*
---@param type string
---@return boolean
function ImGuiPayload:IsDataType(type)
    return lib.ImGuiPayload_IsDataType(self,type)
end
---@param self ffi.ct* ImGuiPayload*
---@return boolean
function ImGuiPayload:IsDelivery()
    return lib.ImGuiPayload_IsDelivery(self)
end
---@param self ffi.ct* ImGuiPayload*
---@return boolean
function ImGuiPayload:IsPreview()
    return lib.ImGuiPayload_IsPreview(self)
end
M.ImGuiPayload = ffi.metatype("ImGuiPayload",ImGuiPayload)
--------------------------ImGuiPlatformImeData----------------------------
---@class ImGuiPlatformImeData
local ImGuiPlatformImeData= {}
ImGuiPlatformImeData.__index = ImGuiPlatformImeData
function ImGuiPlatformImeData.__new(ctype)
    local ptr = lib.ImGuiPlatformImeData_ImGuiPlatformImeData()
    return ffi.gc(ptr,lib.ImGuiPlatformImeData_destroy)
end
M.ImGuiPlatformImeData = ffi.metatype("ImGuiPlatformImeData",ImGuiPlatformImeData)
--------------------------ImGuiPopupData----------------------------
---@class ImGuiPopupData
local ImGuiPopupData= {}
ImGuiPopupData.__index = ImGuiPopupData
function ImGuiPopupData.__new(ctype)
    local ptr = lib.ImGuiPopupData_ImGuiPopupData()
    return ffi.gc(ptr,lib.ImGuiPopupData_destroy)
end
M.ImGuiPopupData = ffi.metatype("ImGuiPopupData",ImGuiPopupData)
--------------------------ImGuiPtrOrIndex----------------------------
---@class ImGuiPtrOrIndex
local ImGuiPtrOrIndex= {}
ImGuiPtrOrIndex.__index = ImGuiPtrOrIndex
function ImGuiPtrOrIndex.ImGuiPtrOrIndex_Ptr(ptr)
    local ptr = lib.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(ptr)
    return ffi.gc(ptr,lib.ImGuiPtrOrIndex_destroy)
end
function ImGuiPtrOrIndex.ImGuiPtrOrIndex_Int(index)
    local ptr = lib.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(index)
    return ffi.gc(ptr,lib.ImGuiPtrOrIndex_destroy)
end
function ImGuiPtrOrIndex.__new(ctype,a1) -- generic version
    if ffi.istype('void*',a1) then return ImGuiPtrOrIndex.ImGuiPtrOrIndex_Ptr(a1) end
    if (ffi.istype('int',a1) or type(a1)=='number') then return ImGuiPtrOrIndex.ImGuiPtrOrIndex_Int(a1) end
    print(ctype,a1)
    error'ImGuiPtrOrIndex.__new could not find overloaded'
end
M.ImGuiPtrOrIndex = ffi.metatype("ImGuiPtrOrIndex",ImGuiPtrOrIndex)
--------------------------ImGuiSettingsHandler----------------------------
---@class ImGuiSettingsHandler
local ImGuiSettingsHandler= {}
ImGuiSettingsHandler.__index = ImGuiSettingsHandler
function ImGuiSettingsHandler.__new(ctype)
    local ptr = lib.ImGuiSettingsHandler_ImGuiSettingsHandler()
    return ffi.gc(ptr,lib.ImGuiSettingsHandler_destroy)
end
M.ImGuiSettingsHandler = ffi.metatype("ImGuiSettingsHandler",ImGuiSettingsHandler)
--------------------------ImGuiStackLevelInfo----------------------------
---@class ImGuiStackLevelInfo
local ImGuiStackLevelInfo= {}
ImGuiStackLevelInfo.__index = ImGuiStackLevelInfo
function ImGuiStackLevelInfo.__new(ctype)
    local ptr = lib.ImGuiStackLevelInfo_ImGuiStackLevelInfo()
    return ffi.gc(ptr,lib.ImGuiStackLevelInfo_destroy)
end
M.ImGuiStackLevelInfo = ffi.metatype("ImGuiStackLevelInfo",ImGuiStackLevelInfo)
--------------------------ImGuiStackSizes----------------------------
---@class ImGuiStackSizes
local ImGuiStackSizes= {}
ImGuiStackSizes.__index = ImGuiStackSizes
---@param self ffi.ct* ImGuiStackSizes*
---@return nil
function ImGuiStackSizes:CompareWithCurrentState()
    return lib.ImGuiStackSizes_CompareWithCurrentState(self)
end
function ImGuiStackSizes.__new(ctype)
    local ptr = lib.ImGuiStackSizes_ImGuiStackSizes()
    return ffi.gc(ptr,lib.ImGuiStackSizes_destroy)
end
---@param self ffi.ct* ImGuiStackSizes*
---@return nil
function ImGuiStackSizes:SetToCurrentState()
    return lib.ImGuiStackSizes_SetToCurrentState(self)
end
M.ImGuiStackSizes = ffi.metatype("ImGuiStackSizes",ImGuiStackSizes)
--------------------------ImGuiStackTool----------------------------
---@class ImGuiStackTool
local ImGuiStackTool= {}
ImGuiStackTool.__index = ImGuiStackTool
function ImGuiStackTool.__new(ctype)
    local ptr = lib.ImGuiStackTool_ImGuiStackTool()
    return ffi.gc(ptr,lib.ImGuiStackTool_destroy)
end
M.ImGuiStackTool = ffi.metatype("ImGuiStackTool",ImGuiStackTool)
--------------------------ImGuiStorage----------------------------
---@class ImGuiStorage
local ImGuiStorage= {}
ImGuiStorage.__index = ImGuiStorage
---@param self ffi.ct* ImGuiStorage*
---@return nil
function ImGuiStorage:BuildSortByKey()
    return lib.ImGuiStorage_BuildSortByKey(self)
end
---@param self ffi.ct* ImGuiStorage*
---@return nil
function ImGuiStorage:Clear()
    return lib.ImGuiStorage_Clear(self)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val boolean?
---@return boolean
function ImGuiStorage:GetBool(key,default_val)
    default_val = default_val or false
    return lib.ImGuiStorage_GetBool(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val boolean?
---@return ffi.ct* bool*
function ImGuiStorage:GetBoolRef(key,default_val)
    default_val = default_val or false
    return lib.ImGuiStorage_GetBoolRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val number?
---@return number
function ImGuiStorage:GetFloat(key,default_val)
    default_val = default_val or 0.0
    return lib.ImGuiStorage_GetFloat(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val number?
---@return ffi.ct* float*
function ImGuiStorage:GetFloatRef(key,default_val)
    default_val = default_val or 0.0
    return lib.ImGuiStorage_GetFloatRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val number?
---@return number
function ImGuiStorage:GetInt(key,default_val)
    default_val = default_val or 0
    return lib.ImGuiStorage_GetInt(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val number?
---@return ffi.ct* int*
function ImGuiStorage:GetIntRef(key,default_val)
    default_val = default_val or 0
    return lib.ImGuiStorage_GetIntRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@return ffi.ct* void*
function ImGuiStorage:GetVoidPtr(key)
    return lib.ImGuiStorage_GetVoidPtr(self,key)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param default_val ffi.ct*? void*
---@return ffi.ct* void**
function ImGuiStorage:GetVoidPtrRef(key,default_val)
    default_val = default_val or nil
    return lib.ImGuiStorage_GetVoidPtrRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param val number
---@return nil
function ImGuiStorage:SetAllInt(val)
    return lib.ImGuiStorage_SetAllInt(self,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param val boolean
---@return nil
function ImGuiStorage:SetBool(key,val)
    return lib.ImGuiStorage_SetBool(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param val number
---@return nil
function ImGuiStorage:SetFloat(key,val)
    return lib.ImGuiStorage_SetFloat(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param val number
---@return nil
function ImGuiStorage:SetInt(key,val)
    return lib.ImGuiStorage_SetInt(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number
---@param val ffi.ct* void*
---@return nil
function ImGuiStorage:SetVoidPtr(key,val)
    return lib.ImGuiStorage_SetVoidPtr(self,key,val)
end
M.ImGuiStorage = ffi.metatype("ImGuiStorage",ImGuiStorage)
--------------------------ImGuiStoragePair----------------------------
---@class ImGuiStoragePair
local ImGuiStoragePair= {}
ImGuiStoragePair.__index = ImGuiStoragePair
function ImGuiStoragePair.ImGuiStoragePair_Int(_key,_val_i)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Int(_key,_val_i)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.ImGuiStoragePair_Float(_key,_val_f)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Float(_key,_val_f)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.ImGuiStoragePair_Ptr(_key,_val_p)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Ptr(_key,_val_p)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.__new(ctype,a1,a2) -- generic version
    if (ffi.istype('int',a2) or type(a2)=='number') then return ImGuiStoragePair.ImGuiStoragePair_Int(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return ImGuiStoragePair.ImGuiStoragePair_Float(a1,a2) end
    if ffi.istype('void*',a2) then return ImGuiStoragePair.ImGuiStoragePair_Ptr(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiStoragePair.__new could not find overloaded'
end
M.ImGuiStoragePair = ffi.metatype("ImGuiStoragePair",ImGuiStoragePair)
--------------------------ImGuiStyle----------------------------
---@class ImGuiStyle
local ImGuiStyle= {}
ImGuiStyle.__index = ImGuiStyle
function ImGuiStyle.__new(ctype)
    local ptr = lib.ImGuiStyle_ImGuiStyle()
    return ffi.gc(ptr,lib.ImGuiStyle_destroy)
end
---@param self ffi.ct* ImGuiStyle*
---@param scale_factor number
---@return nil
function ImGuiStyle:ScaleAllSizes(scale_factor)
    return lib.ImGuiStyle_ScaleAllSizes(self,scale_factor)
end
M.ImGuiStyle = ffi.metatype("ImGuiStyle",ImGuiStyle)
--------------------------ImGuiStyleMod----------------------------
---@class ImGuiStyleMod
local ImGuiStyleMod= {}
ImGuiStyleMod.__index = ImGuiStyleMod
function ImGuiStyleMod.ImGuiStyleMod_Int(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Int(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.ImGuiStyleMod_Float(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Float(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.ImGuiStyleMod_Vec2(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Vec2(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.__new(ctype,a1,a2) -- generic version
    if (ffi.istype('int',a2) or type(a2)=='number') then return ImGuiStyleMod.ImGuiStyleMod_Int(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return ImGuiStyleMod.ImGuiStyleMod_Float(a1,a2) end
    if ffi.istype('ImVec2',a2) then return ImGuiStyleMod.ImGuiStyleMod_Vec2(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiStyleMod.__new could not find overloaded'
end
M.ImGuiStyleMod = ffi.metatype("ImGuiStyleMod",ImGuiStyleMod)
--------------------------ImGuiTabBar----------------------------
---@class ImGuiTabBar
local ImGuiTabBar= {}
ImGuiTabBar.__index = ImGuiTabBar
function ImGuiTabBar.__new(ctype)
    local ptr = lib.ImGuiTabBar_ImGuiTabBar()
    return ffi.gc(ptr,lib.ImGuiTabBar_destroy)
end
M.ImGuiTabBar = ffi.metatype("ImGuiTabBar",ImGuiTabBar)
--------------------------ImGuiTabItem----------------------------
---@class ImGuiTabItem
local ImGuiTabItem= {}
ImGuiTabItem.__index = ImGuiTabItem
function ImGuiTabItem.__new(ctype)
    local ptr = lib.ImGuiTabItem_ImGuiTabItem()
    return ffi.gc(ptr,lib.ImGuiTabItem_destroy)
end
M.ImGuiTabItem = ffi.metatype("ImGuiTabItem",ImGuiTabItem)
--------------------------ImGuiTable----------------------------
---@class ImGuiTable
local ImGuiTable= {}
ImGuiTable.__index = ImGuiTable
function ImGuiTable.__new(ctype)
    local ptr = lib.ImGuiTable_ImGuiTable()
    return ffi.gc(ptr,lib.ImGuiTable_destroy)
end
M.ImGuiTable = ffi.metatype("ImGuiTable",ImGuiTable)
--------------------------ImGuiTableColumn----------------------------
---@class ImGuiTableColumn
local ImGuiTableColumn= {}
ImGuiTableColumn.__index = ImGuiTableColumn
function ImGuiTableColumn.__new(ctype)
    local ptr = lib.ImGuiTableColumn_ImGuiTableColumn()
    return ffi.gc(ptr,lib.ImGuiTableColumn_destroy)
end
M.ImGuiTableColumn = ffi.metatype("ImGuiTableColumn",ImGuiTableColumn)
--------------------------ImGuiTableColumnSettings----------------------------
---@class ImGuiTableColumnSettings
local ImGuiTableColumnSettings= {}
ImGuiTableColumnSettings.__index = ImGuiTableColumnSettings
function ImGuiTableColumnSettings.__new(ctype)
    local ptr = lib.ImGuiTableColumnSettings_ImGuiTableColumnSettings()
    return ffi.gc(ptr,lib.ImGuiTableColumnSettings_destroy)
end
M.ImGuiTableColumnSettings = ffi.metatype("ImGuiTableColumnSettings",ImGuiTableColumnSettings)
--------------------------ImGuiTableColumnSortSpecs----------------------------
---@class ImGuiTableColumnSortSpecs
local ImGuiTableColumnSortSpecs= {}
ImGuiTableColumnSortSpecs.__index = ImGuiTableColumnSortSpecs
function ImGuiTableColumnSortSpecs.__new(ctype)
    local ptr = lib.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs()
    return ffi.gc(ptr,lib.ImGuiTableColumnSortSpecs_destroy)
end
M.ImGuiTableColumnSortSpecs = ffi.metatype("ImGuiTableColumnSortSpecs",ImGuiTableColumnSortSpecs)
--------------------------ImGuiTableInstanceData----------------------------
---@class ImGuiTableInstanceData
local ImGuiTableInstanceData= {}
ImGuiTableInstanceData.__index = ImGuiTableInstanceData
function ImGuiTableInstanceData.__new(ctype)
    local ptr = lib.ImGuiTableInstanceData_ImGuiTableInstanceData()
    return ffi.gc(ptr,lib.ImGuiTableInstanceData_destroy)
end
M.ImGuiTableInstanceData = ffi.metatype("ImGuiTableInstanceData",ImGuiTableInstanceData)
--------------------------ImGuiTableSettings----------------------------
---@class ImGuiTableSettings
local ImGuiTableSettings= {}
ImGuiTableSettings.__index = ImGuiTableSettings
---@param self ffi.ct* ImGuiTableSettings*
---@return ffi.ct* ImGuiTableColumnSettings*
function ImGuiTableSettings:GetColumnSettings()
    return lib.ImGuiTableSettings_GetColumnSettings(self)
end
function ImGuiTableSettings.__new(ctype)
    local ptr = lib.ImGuiTableSettings_ImGuiTableSettings()
    return ffi.gc(ptr,lib.ImGuiTableSettings_destroy)
end
M.ImGuiTableSettings = ffi.metatype("ImGuiTableSettings",ImGuiTableSettings)
--------------------------ImGuiTableSortSpecs----------------------------
---@class ImGuiTableSortSpecs
local ImGuiTableSortSpecs= {}
ImGuiTableSortSpecs.__index = ImGuiTableSortSpecs
function ImGuiTableSortSpecs.__new(ctype)
    local ptr = lib.ImGuiTableSortSpecs_ImGuiTableSortSpecs()
    return ffi.gc(ptr,lib.ImGuiTableSortSpecs_destroy)
end
M.ImGuiTableSortSpecs = ffi.metatype("ImGuiTableSortSpecs",ImGuiTableSortSpecs)
--------------------------ImGuiTableTempData----------------------------
---@class ImGuiTableTempData
local ImGuiTableTempData= {}
ImGuiTableTempData.__index = ImGuiTableTempData
function ImGuiTableTempData.__new(ctype)
    local ptr = lib.ImGuiTableTempData_ImGuiTableTempData()
    return ffi.gc(ptr,lib.ImGuiTableTempData_destroy)
end
M.ImGuiTableTempData = ffi.metatype("ImGuiTableTempData",ImGuiTableTempData)
--------------------------ImGuiTextBuffer----------------------------
---@class ImGuiTextBuffer
local ImGuiTextBuffer= {}
ImGuiTextBuffer.__index = ImGuiTextBuffer
function ImGuiTextBuffer.__new(ctype)
    local ptr = lib.ImGuiTextBuffer_ImGuiTextBuffer()
    return ffi.gc(ptr,lib.ImGuiTextBuffer_destroy)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param str string
---@param str_end string?
---@return nil
function ImGuiTextBuffer:append(str,str_end)
    str_end = str_end or nil
    return lib.ImGuiTextBuffer_append(self,str,str_end)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param fmt string
---@return nil
function ImGuiTextBuffer:appendf(fmt,...)
    return lib.ImGuiTextBuffer_appendf(self,fmt,...)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function ImGuiTextBuffer:appendfv(fmt,args)
    return lib.ImGuiTextBuffer_appendfv(self,fmt,args)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:begin()
    return ffi.string(lib.ImGuiTextBuffer_begin(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:c_str()
    return ffi.string(lib.ImGuiTextBuffer_c_str(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return nil
function ImGuiTextBuffer:clear()
    return lib.ImGuiTextBuffer_clear(self)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return boolean
function ImGuiTextBuffer:empty()
    return lib.ImGuiTextBuffer_empty(self)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:_end()
    return ffi.string(lib.ImGuiTextBuffer_end(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param capacity number
---@return nil
function ImGuiTextBuffer:reserve(capacity)
    return lib.ImGuiTextBuffer_reserve(self,capacity)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return number
function ImGuiTextBuffer:size()
    return lib.ImGuiTextBuffer_size(self)
end
M.ImGuiTextBuffer = ffi.metatype("ImGuiTextBuffer",ImGuiTextBuffer)
--------------------------ImGuiTextFilter----------------------------
---@class ImGuiTextFilter
local ImGuiTextFilter= {}
ImGuiTextFilter.__index = ImGuiTextFilter
---@param self ffi.ct* ImGuiTextFilter*
---@return nil
function ImGuiTextFilter:Build()
    return lib.ImGuiTextFilter_Build(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@return nil
function ImGuiTextFilter:Clear()
    return lib.ImGuiTextFilter_Clear(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@param label string?
---@param width number?
---@return boolean
function ImGuiTextFilter:Draw(label,width)
    label = label or "Filter(inc,-exc)"
    width = width or 0.0
    return lib.ImGuiTextFilter_Draw(self,label,width)
end
function ImGuiTextFilter.__new(ctype,default_filter)
    if default_filter == nil then default_filter = "" end
    local ptr = lib.ImGuiTextFilter_ImGuiTextFilter(default_filter)
    return ffi.gc(ptr,lib.ImGuiTextFilter_destroy)
end
---@param self ffi.ct* ImGuiTextFilter*
---@return boolean
function ImGuiTextFilter:IsActive()
    return lib.ImGuiTextFilter_IsActive(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@param text string
---@param text_end string?
---@return boolean
function ImGuiTextFilter:PassFilter(text,text_end)
    text_end = text_end or nil
    return lib.ImGuiTextFilter_PassFilter(self,text,text_end)
end
M.ImGuiTextFilter = ffi.metatype("ImGuiTextFilter",ImGuiTextFilter)
--------------------------ImGuiTextIndex----------------------------
---@class ImGuiTextIndex
local ImGuiTextIndex= {}
ImGuiTextIndex.__index = ImGuiTextIndex
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param old_size number
---@param new_size number
---@return nil
function ImGuiTextIndex:append(base,old_size,new_size)
    return lib.ImGuiTextIndex_append(self,base,old_size,new_size)
end
---@param self ffi.ct* ImGuiTextIndex*
---@return nil
function ImGuiTextIndex:clear()
    return lib.ImGuiTextIndex_clear(self)
end
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param n number
---@return string
function ImGuiTextIndex:get_line_begin(base,n)
    return ffi.string(lib.ImGuiTextIndex_get_line_begin(self,base,n))
end
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param n number
---@return string
function ImGuiTextIndex:get_line_end(base,n)
    return ffi.string(lib.ImGuiTextIndex_get_line_end(self,base,n))
end
---@param self ffi.ct* ImGuiTextIndex*
---@return number
function ImGuiTextIndex:size()
    return lib.ImGuiTextIndex_size(self)
end
M.ImGuiTextIndex = ffi.metatype("ImGuiTextIndex",ImGuiTextIndex)
--------------------------ImGuiTextRange----------------------------
---@class ImGuiTextRange
local ImGuiTextRange= {}
ImGuiTextRange.__index = ImGuiTextRange
function ImGuiTextRange.ImGuiTextRange_Nil()
    local ptr = lib.ImGuiTextRange_ImGuiTextRange_Nil()
    return ffi.gc(ptr,lib.ImGuiTextRange_destroy)
end
function ImGuiTextRange.ImGuiTextRange_Str(_b,_e)
    local ptr = lib.ImGuiTextRange_ImGuiTextRange_Str(_b,_e)
    return ffi.gc(ptr,lib.ImGuiTextRange_destroy)
end
function ImGuiTextRange.__new(ctype,a1,a2) -- generic version
    if a1==nil then return ImGuiTextRange.ImGuiTextRange_Nil() end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return ImGuiTextRange.ImGuiTextRange_Str(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiTextRange.__new could not find overloaded'
end
---@param self ffi.ct* ImGuiTextRange*
---@return boolean
function ImGuiTextRange:empty()
    return lib.ImGuiTextRange_empty(self)
end
---@param self ffi.ct* ImGuiTextRange*
---@param separator number
---@param out ffi.ct* ImVector_ImGuiTextRange*
---@return nil
function ImGuiTextRange:split(separator,out)
    return lib.ImGuiTextRange_split(self,separator,out)
end
M.ImGuiTextRange = ffi.metatype("ImGuiTextRange",ImGuiTextRange)
--------------------------ImGuiViewport----------------------------
---@class ImGuiViewport
local ImGuiViewport= {}
ImGuiViewport.__index = ImGuiViewport
---@param self ffi.ct* ImGuiViewport*
---@return nil
function ImGuiViewport:GetCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewport_GetCenter(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewport*
---@return nil
function ImGuiViewport:GetWorkCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewport_GetWorkCenter(nonUDT_out,self)
    return nonUDT_out
end
function ImGuiViewport.__new(ctype)
    local ptr = lib.ImGuiViewport_ImGuiViewport()
    return ffi.gc(ptr,lib.ImGuiViewport_destroy)
end
M.ImGuiViewport = ffi.metatype("ImGuiViewport",ImGuiViewport)
--------------------------ImGuiViewportP----------------------------
---@class ImGuiViewportP
local ImGuiViewportP= {}
ImGuiViewportP.__index = ImGuiViewportP
---@param self ffi.ct* ImGuiViewportP*
---@param off_min ImVec2
---@return nil
function ImGuiViewportP:CalcWorkRectPos(off_min)
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewportP_CalcWorkRectPos(nonUDT_out,self,off_min)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@param off_min ImVec2
---@param off_max ImVec2
---@return nil
function ImGuiViewportP:CalcWorkRectSize(off_min,off_max)
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewportP_CalcWorkRectSize(nonUDT_out,self,off_min,off_max)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetBuildWorkRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetBuildWorkRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetMainRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetMainRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetWorkRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetWorkRect(nonUDT_out,self)
    return nonUDT_out
end
function ImGuiViewportP.__new(ctype)
    local ptr = lib.ImGuiViewportP_ImGuiViewportP()
    return ffi.gc(ptr,lib.ImGuiViewportP_destroy)
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:UpdateWorkRect()
    return lib.ImGuiViewportP_UpdateWorkRect(self)
end
M.ImGuiViewportP = ffi.metatype("ImGuiViewportP",ImGuiViewportP)
--------------------------ImGuiWindow----------------------------
---@class ImGuiWindow
local ImGuiWindow= {}
ImGuiWindow.__index = ImGuiWindow
---@param self ffi.ct* ImGuiWindow*
---@return number
function ImGuiWindow:CalcFontSize()
    return lib.ImGuiWindow_CalcFontSize(self)
end
---@param self ffi.ct* ImGuiWindow*
---@param str string
---@param str_end string?
---@return number
function ImGuiWindow:GetID_Str(str,str_end)
    str_end = str_end or nil
    return lib.ImGuiWindow_GetID_Str(self,str,str_end)
end
---@param self ffi.ct* ImGuiWindow*
---@param ptr ffi.ct* const void*
---@return number
function ImGuiWindow:GetID_Ptr(ptr)
    return lib.ImGuiWindow_GetID_Ptr(self,ptr)
end
---@param self ffi.ct* ImGuiWindow*
---@param n number
---@return number
function ImGuiWindow:GetID_Int(n)
    return lib.ImGuiWindow_GetID_Int(self,n)
end
function ImGuiWindow:GetID(a2,a3) -- generic version
    if (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return self:GetID_Str(a2,a3) end
    if ffi.istype('const void*',a2) then return self:GetID_Ptr(a2) end
    if (ffi.istype('int',a2) or type(a2)=='number') then return self:GetID_Int(a2) end
    print(a2,a3)
    error'ImGuiWindow:GetID could not find overloaded'
end
---@param self ffi.ct* ImGuiWindow*
---@param r_abs ImRect
---@return number
function ImGuiWindow:GetIDFromRectangle(r_abs)
    return lib.ImGuiWindow_GetIDFromRectangle(self,r_abs)
end
function ImGuiWindow.__new(ctype,context,name)
    local ptr = lib.ImGuiWindow_ImGuiWindow(context,name)
    return ffi.gc(ptr,lib.ImGuiWindow_destroy)
end
---@param self ffi.ct* ImGuiWindow*
---@return number
function ImGuiWindow:MenuBarHeight()
    return lib.ImGuiWindow_MenuBarHeight(self)
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:MenuBarRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_MenuBarRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:Rect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_Rect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiWindow*
---@return number
function ImGuiWindow:TitleBarHeight()
    return lib.ImGuiWindow_TitleBarHeight(self)
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:TitleBarRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_TitleBarRect(nonUDT_out,self)
    return nonUDT_out
end
M.ImGuiWindow = ffi.metatype("ImGuiWindow",ImGuiWindow)
--------------------------ImGuiWindowSettings----------------------------
---@class ImGuiWindowSettings
local ImGuiWindowSettings= {}
ImGuiWindowSettings.__index = ImGuiWindowSettings
---@param self ffi.ct* ImGuiWindowSettings*
---@return ffi.ct* char*
function ImGuiWindowSettings:GetName()
    return lib.ImGuiWindowSettings_GetName(self)
end
function ImGuiWindowSettings.__new(ctype)
    local ptr = lib.ImGuiWindowSettings_ImGuiWindowSettings()
    return ffi.gc(ptr,lib.ImGuiWindowSettings_destroy)
end
M.ImGuiWindowSettings = ffi.metatype("ImGuiWindowSettings",ImGuiWindowSettings)
--------------------------ImRect----------------------------
---@class ImRect
local ImRect= {}
ImRect.__index = ImRect
---@param self ffi.ct* ImRect*
---@param p ImVec2
---@return nil
function ImRect:Add_Vec2(p)
    return lib.ImRect_Add_Vec2(self,p)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:Add_Rect(r)
    return lib.ImRect_Add_Rect(self,r)
end
function ImRect:Add(a2) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:Add_Vec2(a2) end
    if ffi.istype('const ImRect',a2) then return self:Add_Rect(a2) end
    print(a2)
    error'ImRect:Add could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:ClipWith(r)
    return lib.ImRect_ClipWith(self,r)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:ClipWithFull(r)
    return lib.ImRect_ClipWithFull(self,r)
end
---@param self ffi.ct* ImRect*
---@param p ImVec2
---@return boolean
function ImRect:Contains_Vec2(p)
    return lib.ImRect_Contains_Vec2(self,p)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return boolean
function ImRect:Contains_Rect(r)
    return lib.ImRect_Contains_Rect(self,r)
end
function ImRect:Contains(a2) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:Contains_Vec2(a2) end
    if ffi.istype('const ImRect',a2) then return self:Contains_Rect(a2) end
    print(a2)
    error'ImRect:Contains could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@param amount number
---@return nil
function ImRect:Expand_Float(amount)
    return lib.ImRect_Expand_Float(self,amount)
end
---@param self ffi.ct* ImRect*
---@param amount ImVec2
---@return nil
function ImRect:Expand_Vec2(amount)
    return lib.ImRect_Expand_Vec2(self,amount)
end
function ImRect:Expand(a2) -- generic version
    if ffi.istype('const float',a2) then return self:Expand_Float(a2) end
    if ffi.istype('const ImVec2',a2) then return self:Expand_Vec2(a2) end
    print(a2)
    error'ImRect:Expand could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:Floor()
    return lib.ImRect_Floor(self)
end
---@param self ffi.ct* ImRect*
---@return number
function ImRect:GetArea()
    return lib.ImRect_GetArea(self)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetBL()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetBL(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetBR()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetBR(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetCenter(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return number
function ImRect:GetHeight()
    return lib.ImRect_GetHeight(self)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetSize(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetTL()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetTL(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetTR()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetTR(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return number
function ImRect:GetWidth()
    return lib.ImRect_GetWidth(self)
end
function ImRect.ImRect_Nil()
    local ptr = lib.ImRect_ImRect_Nil()
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Vec2(min,max)
    local ptr = lib.ImRect_ImRect_Vec2(min,max)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Vec4(v)
    local ptr = lib.ImRect_ImRect_Vec4(v)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Float(x1,y1,x2,y2)
    local ptr = lib.ImRect_ImRect_Float(x1,y1,x2,y2)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.__new(ctype,a1,a2,a3,a4) -- generic version
    if a1==nil then return ImRect.ImRect_Nil() end
    if ffi.istype('const ImVec2',a1) then return ImRect.ImRect_Vec2(a1,a2) end
    if ffi.istype('const ImVec4',a1) then return ImRect.ImRect_Vec4(a1) end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImRect.ImRect_Float(a1,a2,a3,a4) end
    print(ctype,a1,a2,a3,a4)
    error'ImRect.__new could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@return boolean
function ImRect:IsInverted()
    return lib.ImRect_IsInverted(self)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return boolean
function ImRect:Overlaps(r)
    return lib.ImRect_Overlaps(self,r)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:ToVec4()
    local nonUDT_out = ffi.new("ImVec4")
    lib.ImRect_ToVec4(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@param d ImVec2
---@return nil
function ImRect:Translate(d)
    return lib.ImRect_Translate(self,d)
end
---@param self ffi.ct* ImRect*
---@param dx number
---@return nil
function ImRect:TranslateX(dx)
    return lib.ImRect_TranslateX(self,dx)
end
---@param self ffi.ct* ImRect*
---@param dy number
---@return nil
function ImRect:TranslateY(dy)
    return lib.ImRect_TranslateY(self,dy)
end
M.ImRect = ffi.metatype("ImRect",ImRect)
--------------------------ImVec1----------------------------
---@class ImVec1
local ImVec1= {}
ImVec1.__index = ImVec1
function ImVec1.ImVec1_Nil()
    local ptr = lib.ImVec1_ImVec1_Nil()
    return ffi.gc(ptr,lib.ImVec1_destroy)
end
function ImVec1.ImVec1_Float(_x)
    local ptr = lib.ImVec1_ImVec1_Float(_x)
    return ffi.gc(ptr,lib.ImVec1_destroy)
end
function ImVec1.__new(ctype,a1) -- generic version
    if a1==nil then return ImVec1.ImVec1_Nil() end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImVec1.ImVec1_Float(a1) end
    print(ctype,a1)
    error'ImVec1.__new could not find overloaded'
end
M.ImVec1 = ffi.metatype("ImVec1",ImVec1)
--------------------------ImVec2ih----------------------------
---@class ImVec2ih
local ImVec2ih= {}
ImVec2ih.__index = ImVec2ih
function ImVec2ih.ImVec2ih_Nil()
    local ptr = lib.ImVec2ih_ImVec2ih_Nil()
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.ImVec2ih_short(_x,_y)
    local ptr = lib.ImVec2ih_ImVec2ih_short(_x,_y)
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.ImVec2ih_Vec2(rhs)
    local ptr = lib.ImVec2ih_ImVec2ih_Vec2(rhs)
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.__new(ctype,a1,a2) -- generic version
    if a1==nil then return ImVec2ih.ImVec2ih_Nil() end
    if ffi.istype('short',a1) then return ImVec2ih.ImVec2ih_short(a1,a2) end
    if ffi.istype('const ImVec2',a1) then return ImVec2ih.ImVec2ih_Vec2(a1) end
    print(ctype,a1,a2)
    error'ImVec2ih.__new could not find overloaded'
end
M.ImVec2ih = ffi.metatype("ImVec2ih",ImVec2ih)
------------------------------------------------------
---@param type string
---@param flags number?
---@return ffi.ct* const ImGuiPayload*
function M.AcceptDragDropPayload(type,flags)
    flags = flags or 0
    return lib.igAcceptDragDropPayload(type,flags)
end
---@param id number
---@return nil
function M.ActivateItem(id)
    return lib.igActivateItem(id)
end
---@param context ffi.ct* ImGuiContext*
---@param hook ffi.ct* const ImGuiContextHook*
---@return number
function M.AddContextHook(context,hook)
    return lib.igAddContextHook(context,hook)
end
---@param handler ffi.ct* const ImGuiSettingsHandler*
---@return nil
function M.AddSettingsHandler(handler)
    return lib.igAddSettingsHandler(handler)
end
---@return nil
function M.AlignTextToFramePadding()
    return lib.igAlignTextToFramePadding()
end
---@param str_id string
---@param dir number
---@return boolean
function M.ArrowButton(str_id,dir)
    return lib.igArrowButton(str_id,dir)
end
---@param str_id string
---@param dir number
---@param size_arg ImVec2
---@param flags number?
---@return boolean
function M.ArrowButtonEx(str_id,dir,size_arg,flags)
    flags = flags or 0
    return lib.igArrowButtonEx(str_id,dir,size_arg,flags)
end
---@param name string
---@param p_open ffi.ct*? bool*
---@param flags number?
---@return boolean
function M.Begin(name,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBegin(name,p_open,flags)
end
---@param str_id string
---@param size ImVec2?
---@param border boolean?
---@param flags number?
---@return boolean
function M.BeginChild_Str(str_id,size,border,flags)
    border = border or false
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igBeginChild_Str(str_id,size,border,flags)
end
---@param id number
---@param size ImVec2?
---@param border boolean?
---@param flags number?
---@return boolean
function M.BeginChild_ID(id,size,border,flags)
    border = border or false
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igBeginChild_ID(id,size,border,flags)
end
function M.BeginChild(a1,a2,a3,a4) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.BeginChild_Str(a1,a2,a3,a4) end
    if ffi.istype('ImGuiID',a1) then return M.BeginChild_ID(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.BeginChild could not find overloaded'
end
---@param name string
---@param id number
---@param size_arg ImVec2
---@param border boolean
---@param flags number
---@return boolean
function M.BeginChildEx(name,id,size_arg,border,flags)
    return lib.igBeginChildEx(name,id,size_arg,border,flags)
end
---@param id number
---@param size ImVec2
---@param flags number?
---@return boolean
function M.BeginChildFrame(id,size,flags)
    flags = flags or 0
    return lib.igBeginChildFrame(id,size,flags)
end
---@param str_id string
---@param count number
---@param flags number?
---@return nil
function M.BeginColumns(str_id,count,flags)
    flags = flags or 0
    return lib.igBeginColumns(str_id,count,flags)
end
---@param label string
---@param preview_value string
---@param flags number?
---@return boolean
function M.BeginCombo(label,preview_value,flags)
    flags = flags or 0
    return lib.igBeginCombo(label,preview_value,flags)
end
---@param popup_id number
---@param bb ImRect
---@param flags number
---@return boolean
function M.BeginComboPopup(popup_id,bb,flags)
    return lib.igBeginComboPopup(popup_id,bb,flags)
end
---@return boolean
function M.BeginComboPreview()
    return lib.igBeginComboPreview()
end
---@param disabled boolean?
---@return nil
function M.BeginDisabled(disabled)
    if disabled == nil then disabled = true end
    return lib.igBeginDisabled(disabled)
end
---@param flags number?
---@return boolean
function M.BeginDragDropSource(flags)
    flags = flags or 0
    return lib.igBeginDragDropSource(flags)
end
---@return boolean
function M.BeginDragDropTarget()
    return lib.igBeginDragDropTarget()
end
---@param bb ImRect
---@param id number
---@return boolean
function M.BeginDragDropTargetCustom(bb,id)
    return lib.igBeginDragDropTargetCustom(bb,id)
end
---@return nil
function M.BeginGroup()
    return lib.igBeginGroup()
end
---@param label string
---@param size ImVec2?
---@return boolean
function M.BeginListBox(label,size)
    size = size or ImVec2(0,0)
    return lib.igBeginListBox(label,size)
end
---@return boolean
function M.BeginMainMenuBar()
    return lib.igBeginMainMenuBar()
end
---@param label string
---@param enabled boolean?
---@return boolean
function M.BeginMenu(label,enabled)
    if enabled == nil then enabled = true end
    return lib.igBeginMenu(label,enabled)
end
---@return boolean
function M.BeginMenuBar()
    return lib.igBeginMenuBar()
end
---@param label string
---@param icon string
---@param enabled boolean?
---@return boolean
function M.BeginMenuEx(label,icon,enabled)
    if enabled == nil then enabled = true end
    return lib.igBeginMenuEx(label,icon,enabled)
end
---@param str_id string
---@param flags number?
---@return boolean
function M.BeginPopup(str_id,flags)
    flags = flags or 0
    return lib.igBeginPopup(str_id,flags)
end
---@param str_id string?
---@param popup_flags number?
---@return boolean
function M.BeginPopupContextItem(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextItem(str_id,popup_flags)
end
---@param str_id string?
---@param popup_flags number?
---@return boolean
function M.BeginPopupContextVoid(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextVoid(str_id,popup_flags)
end
---@param str_id string?
---@param popup_flags number?
---@return boolean
function M.BeginPopupContextWindow(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextWindow(str_id,popup_flags)
end
---@param id number
---@param extra_flags number
---@return boolean
function M.BeginPopupEx(id,extra_flags)
    return lib.igBeginPopupEx(id,extra_flags)
end
---@param name string
---@param p_open ffi.ct*? bool*
---@param flags number?
---@return boolean
function M.BeginPopupModal(name,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBeginPopupModal(name,p_open,flags)
end
---@param str_id string
---@param flags number?
---@return boolean
function M.BeginTabBar(str_id,flags)
    flags = flags or 0
    return lib.igBeginTabBar(str_id,flags)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param bb ImRect
---@param flags number
---@return boolean
function M.BeginTabBarEx(tab_bar,bb,flags)
    return lib.igBeginTabBarEx(tab_bar,bb,flags)
end
---@param label string
---@param p_open ffi.ct*? bool*
---@param flags number?
---@return boolean
function M.BeginTabItem(label,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBeginTabItem(label,p_open,flags)
end
---@param str_id string
---@param column number
---@param flags number?
---@param outer_size ImVec2?
---@param inner_width number?
---@return boolean
function M.BeginTable(str_id,column,flags,outer_size,inner_width)
    flags = flags or 0
    inner_width = inner_width or 0.0
    outer_size = outer_size or ImVec2(0.0,0.0)
    return lib.igBeginTable(str_id,column,flags,outer_size,inner_width)
end
---@param name string
---@param id number
---@param columns_count number
---@param flags number?
---@param outer_size ImVec2?
---@param inner_width number?
---@return boolean
function M.BeginTableEx(name,id,columns_count,flags,outer_size,inner_width)
    flags = flags or 0
    inner_width = inner_width or 0.0
    outer_size = outer_size or ImVec2(0,0)
    return lib.igBeginTableEx(name,id,columns_count,flags,outer_size,inner_width)
end
---@return nil
function M.BeginTooltip()
    return lib.igBeginTooltip()
end
---@param tooltip_flags number
---@param extra_window_flags number
---@return nil
function M.BeginTooltipEx(tooltip_flags,extra_window_flags)
    return lib.igBeginTooltipEx(tooltip_flags,extra_window_flags)
end
---@param name string
---@param viewport ffi.ct* ImGuiViewport*
---@param dir number
---@param size number
---@param window_flags number
---@return boolean
function M.BeginViewportSideBar(name,viewport,dir,size,window_flags)
    return lib.igBeginViewportSideBar(name,viewport,dir,size,window_flags)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayBack(window)
    return lib.igBringWindowToDisplayBack(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param above_window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayBehind(window,above_window)
    return lib.igBringWindowToDisplayBehind(window,above_window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayFront(window)
    return lib.igBringWindowToDisplayFront(window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToFocusFront(window)
    return lib.igBringWindowToFocusFront(window)
end
---@return nil
function M.Bullet()
    return lib.igBullet()
end
---@param fmt string
---@return nil
function M.BulletText(fmt,...)
    return lib.igBulletText(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.BulletTextV(fmt,args)
    return lib.igBulletTextV(fmt,args)
end
---@param label string
---@param size ImVec2?
---@return boolean
function M.Button(label,size)
    size = size or ImVec2(0,0)
    return lib.igButton(label,size)
end
---@param bb ImRect
---@param id number
---@param out_hovered ffi.ct* bool*
---@param out_held ffi.ct* bool*
---@param flags number?
---@return boolean
function M.ButtonBehavior(bb,id,out_hovered,out_held,flags)
    flags = flags or 0
    return lib.igButtonBehavior(bb,id,out_hovered,out_held,flags)
end
---@param label string
---@param size_arg ImVec2?
---@param flags number?
---@return boolean
function M.ButtonEx(label,size_arg,flags)
    flags = flags or 0
    size_arg = size_arg or ImVec2(0,0)
    return lib.igButtonEx(label,size_arg,flags)
end
---@param size ImVec2
---@param default_w number
---@param default_h number
---@return nil
function M.CalcItemSize(size,default_w,default_h)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcItemSize(nonUDT_out,size,default_w,default_h)
    return nonUDT_out
end
---@return number
function M.CalcItemWidth()
    return lib.igCalcItemWidth()
end
---@param text string
---@param text_end string?
---@param hide_text_after_double_hash boolean?
---@param wrap_width number?
---@return nil
function M.CalcTextSize(text,text_end,hide_text_after_double_hash,wrap_width)
    hide_text_after_double_hash = hide_text_after_double_hash or false
    text_end = text_end or nil
    wrap_width = wrap_width or -1.0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcTextSize(nonUDT_out,text,text_end,hide_text_after_double_hash,wrap_width)
    return nonUDT_out
end
---@param t0 number
---@param t1 number
---@param repeat_delay number
---@param repeat_rate number
---@return number
function M.CalcTypematicRepeatAmount(t0,t1,repeat_delay,repeat_rate)
    return lib.igCalcTypematicRepeatAmount(t0,t1,repeat_delay,repeat_rate)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.CalcWindowNextAutoFitSize(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcWindowNextAutoFitSize(nonUDT_out,window)
    return nonUDT_out
end
---@param pos ImVec2
---@param wrap_pos_x number
---@return number
function M.CalcWrapWidthForPos(pos,wrap_pos_x)
    return lib.igCalcWrapWidthForPos(pos,wrap_pos_x)
end
---@param context ffi.ct* ImGuiContext*
---@param type ContextHookType
---@return nil
function M.CallContextHooks(context,type)
    return lib.igCallContextHooks(context,type)
end
---@param label string
---@param v ffi.ct* bool*
---@return boolean
function M.Checkbox(label,v)
    return lib.igCheckbox(label,v)
end
---@param label string
---@param flags ffi.ct* int*
---@param flags_value number
---@return boolean
function M.CheckboxFlags_IntPtr(label,flags,flags_value)
    return lib.igCheckboxFlags_IntPtr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* unsigned int*
---@param flags_value number
---@return boolean
function M.CheckboxFlags_UintPtr(label,flags,flags_value)
    return lib.igCheckboxFlags_UintPtr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* ImS64*
---@param flags_value number
---@return boolean
function M.CheckboxFlags_S64Ptr(label,flags,flags_value)
    return lib.igCheckboxFlags_S64Ptr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* ImU64*
---@param flags_value number
---@return boolean
function M.CheckboxFlags_U64Ptr(label,flags,flags_value)
    return lib.igCheckboxFlags_U64Ptr(label,flags,flags_value)
end
function M.CheckboxFlags(a1,a2,a3) -- generic version
    if (ffi.istype('int*',a2) or ffi.istype('int[]',a2)) then return M.CheckboxFlags_IntPtr(a1,a2,a3) end
    if (ffi.istype('unsigned int*',a2) or ffi.istype('unsigned int',a2) or ffi.istype('unsigned int[]',a2)) then return M.CheckboxFlags_UintPtr(a1,a2,a3) end
    if (ffi.istype('ImS64*',a2) or ffi.istype('ImS64',a2) or ffi.istype('ImS64[]',a2)) then return M.CheckboxFlags_S64Ptr(a1,a2,a3) end
    if (ffi.istype('ImU64*',a2) or ffi.istype('ImU64',a2) or ffi.istype('ImU64[]',a2)) then return M.CheckboxFlags_U64Ptr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.CheckboxFlags could not find overloaded'
end
---@return nil
function M.ClearActiveID()
    return lib.igClearActiveID()
end
---@return nil
function M.ClearDragDrop()
    return lib.igClearDragDrop()
end
---@return nil
function M.ClearIniSettings()
    return lib.igClearIniSettings()
end
---@param name string
---@return nil
function M.ClearWindowSettings(name)
    return lib.igClearWindowSettings(name)
end
---@param id number
---@param pos ImVec2
---@return boolean
function M.CloseButton(id,pos)
    return lib.igCloseButton(id,pos)
end
---@return nil
function M.CloseCurrentPopup()
    return lib.igCloseCurrentPopup()
end
---@param remaining number
---@param restore_focus_to_window_under_popup boolean
---@return nil
function M.ClosePopupToLevel(remaining,restore_focus_to_window_under_popup)
    return lib.igClosePopupToLevel(remaining,restore_focus_to_window_under_popup)
end
---@return nil
function M.ClosePopupsExceptModals()
    return lib.igClosePopupsExceptModals()
end
---@param ref_window ffi.ct* ImGuiWindow*
---@param restore_focus_to_window_under_popup boolean
---@return nil
function M.ClosePopupsOverWindow(ref_window,restore_focus_to_window_under_popup)
    return lib.igClosePopupsOverWindow(ref_window,restore_focus_to_window_under_popup)
end
---@param id number
---@param pos ImVec2
---@return boolean
function M.CollapseButton(id,pos)
    return lib.igCollapseButton(id,pos)
end
---@param label string
---@param flags number?
---@return boolean
function M.CollapsingHeader_TreeNodeFlags(label,flags)
    flags = flags or 0
    return lib.igCollapsingHeader_TreeNodeFlags(label,flags)
end
---@param label string
---@param p_visible ffi.ct* bool*
---@param flags number?
---@return boolean
function M.CollapsingHeader_BoolPtr(label,p_visible,flags)
    flags = flags or 0
    return lib.igCollapsingHeader_BoolPtr(label,p_visible,flags)
end
function M.CollapsingHeader(a1,a2,a3) -- generic version
    if ((ffi.istype('ImGuiTreeNodeFlags',a2) or type(a2)=='number') or type(a2)=='nil') then return M.CollapsingHeader_TreeNodeFlags(a1,a2) end
    if (ffi.istype('bool*',a2) or ffi.istype('bool',a2) or ffi.istype('bool[]',a2)) then return M.CollapsingHeader_BoolPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.CollapsingHeader could not find overloaded'
end
---@param desc_id string
---@param col ffi.ct* const ImVec4
---@param flags number?
---@param size ImVec2?
---@return boolean
function M.ColorButton(desc_id,col,flags,size)
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igColorButton(desc_id,col,flags,size)
end
---@param _in ffi.ct* const ImVec4
---@return number
function M.ColorConvertFloat4ToU32(_in)
    return lib.igColorConvertFloat4ToU32(_in)
end
---@param h number
---@param s number
---@param v number
---@param out_r ffi.ct* float*
---@param out_g ffi.ct* float*
---@param out_b ffi.ct* float*
---@return nil
function M.ColorConvertHSVtoRGB(h,s,v,out_r,out_g,out_b)
    return lib.igColorConvertHSVtoRGB(h,s,v,out_r,out_g,out_b)
end
---@param r number
---@param g number
---@param b number
---@param out_h ffi.ct* float*
---@param out_s ffi.ct* float*
---@param out_v ffi.ct* float*
---@return nil
function M.ColorConvertRGBtoHSV(r,g,b,out_h,out_s,out_v)
    return lib.igColorConvertRGBtoHSV(r,g,b,out_h,out_s,out_v)
end
---@param _in number
---@return nil
function M.ColorConvertU32ToFloat4(_in)
    local nonUDT_out = ffi.new("ImVec4")
    lib.igColorConvertU32ToFloat4(nonUDT_out,_in)
    return nonUDT_out
end
---@param label string
---@param col ffi.ct* float[3]
---@param flags number?
---@return boolean
function M.ColorEdit3(label,col,flags)
    flags = flags or 0
    return lib.igColorEdit3(label,col,flags)
end
---@param label string
---@param col ffi.ct* float[4]
---@param flags number?
---@return boolean
function M.ColorEdit4(label,col,flags)
    flags = flags or 0
    return lib.igColorEdit4(label,col,flags)
end
---@param col ffi.ct* const float*
---@param flags number
---@return nil
function M.ColorEditOptionsPopup(col,flags)
    return lib.igColorEditOptionsPopup(col,flags)
end
---@param label string
---@param col ffi.ct* float[3]
---@param flags number?
---@return boolean
function M.ColorPicker3(label,col,flags)
    flags = flags or 0
    return lib.igColorPicker3(label,col,flags)
end
---@param label string
---@param col ffi.ct* float[4]
---@param flags number?
---@param ref_col ffi.ct*? const float*
---@return boolean
function M.ColorPicker4(label,col,flags,ref_col)
    flags = flags or 0
    ref_col = ref_col or nil
    return lib.igColorPicker4(label,col,flags,ref_col)
end
---@param ref_col ffi.ct* const float*
---@param flags number
---@return nil
function M.ColorPickerOptionsPopup(ref_col,flags)
    return lib.igColorPickerOptionsPopup(ref_col,flags)
end
---@param text string
---@param col ffi.ct* const float*
---@param flags number
---@return nil
function M.ColorTooltip(text,col,flags)
    return lib.igColorTooltip(text,col,flags)
end
---@param count number?
---@param id string?
---@param border boolean?
---@return nil
function M.Columns(count,id,border)
    if border == nil then border = true end
    count = count or 1
    id = id or nil
    return lib.igColumns(count,id,border)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items ffi.ct* const char* const[]
---@param items_count number
---@param popup_max_height_in_items number?
---@return boolean
function M.Combo_Str_arr(label,current_item,items,items_count,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_Str_arr(label,current_item,items,items_count,popup_max_height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items_separated_by_zeros string
---@param popup_max_height_in_items number?
---@return boolean
function M.Combo_Str(label,current_item,items_separated_by_zeros,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_Str(label,current_item,items_separated_by_zeros,popup_max_height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items_getter ffi.ct* bool(*)(void* data,int idx,const char** out_text)
---@param data ffi.ct* void*
---@param items_count number
---@param popup_max_height_in_items number?
---@return boolean
function M.Combo_FnBoolPtr(label,current_item,items_getter,data,items_count,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_FnBoolPtr(label,current_item,items_getter,data,items_count,popup_max_height_in_items)
end
function M.Combo(a1,a2,a3,a4,a5,a6) -- generic version
    if (ffi.istype('const char* const[]',a3) or ffi.istype('const char const[]',a3) or ffi.istype('const char const[][]',a3)) then return M.Combo_Str_arr(a1,a2,a3,a4,a5) end
    if (ffi.istype('const char*',a3) or ffi.istype('char[]',a3) or type(a3)=='string') then return M.Combo_Str(a1,a2,a3,a4) end
    if ffi.istype('bool(*)(void* data,int idx,const char** out_text)',a3) then return M.Combo_FnBoolPtr(a1,a2,a3,a4,a5,a6) end
    print(a1,a2,a3,a4,a5,a6)
    error'M.Combo could not find overloaded'
end
---@param key_chord number
---@return number
function M.ConvertShortcutMod(key_chord)
    return lib.igConvertShortcutMod(key_chord)
end
---@param key Key
---@return Key
function M.ConvertSingleModFlagToKey(key)
    return lib.igConvertSingleModFlagToKey(key)
end
---@param shared_font_atlas ffi.ct*? ImFontAtlas*
---@return ffi.ct* ImGuiContext*
function M.CreateContext(shared_font_atlas)
    shared_font_atlas = shared_font_atlas or nil
    return lib.igCreateContext(shared_font_atlas)
end
---@param name string
---@return ffi.ct* ImGuiWindowSettings*
function M.CreateNewWindowSettings(name)
    return lib.igCreateNewWindowSettings(name)
end
---@param buf string
---@param data_type number
---@param p_data ffi.ct* void*
---@param format string
---@return boolean
function M.DataTypeApplyFromText(buf,data_type,p_data,format)
    return lib.igDataTypeApplyFromText(buf,data_type,p_data,format)
end
---@param data_type number
---@param op number
---@param output ffi.ct* void*
---@param arg_1 ffi.ct* const void*
---@param arg_2 ffi.ct* const void*
---@return nil
function M.DataTypeApplyOp(data_type,op,output,arg_1,arg_2)
    return lib.igDataTypeApplyOp(data_type,op,output,arg_1,arg_2)
end
---@param data_type number
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@return boolean
function M.DataTypeClamp(data_type,p_data,p_min,p_max)
    return lib.igDataTypeClamp(data_type,p_data,p_min,p_max)
end
---@param data_type number
---@param arg_1 ffi.ct* const void*
---@param arg_2 ffi.ct* const void*
---@return number
function M.DataTypeCompare(data_type,arg_1,arg_2)
    return lib.igDataTypeCompare(data_type,arg_1,arg_2)
end
---@param buf ffi.ct* char*
---@param buf_size number
---@param data_type number
---@param p_data ffi.ct* const void*
---@param format string
---@return number
function M.DataTypeFormatString(buf,buf_size,data_type,p_data,format)
    return lib.igDataTypeFormatString(buf,buf_size,data_type,p_data,format)
end
---@param data_type number
---@return ffi.ct* const ImGuiDataTypeInfo*
function M.DataTypeGetInfo(data_type)
    return lib.igDataTypeGetInfo(data_type)
end
---@param version_str string
---@param sz_io number
---@param sz_style number
---@param sz_vec2 number
---@param sz_vec4 number
---@param sz_drawvert number
---@param sz_drawidx number
---@return boolean
function M.DebugCheckVersionAndDataLayout(version_str,sz_io,sz_style,sz_vec2,sz_vec4,sz_drawvert,sz_drawidx)
    return lib.igDebugCheckVersionAndDataLayout(version_str,sz_io,sz_style,sz_vec2,sz_vec4,sz_drawvert,sz_drawidx)
end
---@param col number?
---@return nil
function M.DebugDrawItemRect(col)
    col = col or 4278190335
    return lib.igDebugDrawItemRect(col)
end
---@param id number
---@param data_type number
---@param data_id ffi.ct* const void*
---@param data_id_end ffi.ct* const void*
---@return nil
function M.DebugHookIdInfo(id,data_type,data_id,data_id_end)
    return lib.igDebugHookIdInfo(id,data_type,data_id,data_id_end)
end
---@param target_id number
---@return nil
function M.DebugLocateItem(target_id)
    return lib.igDebugLocateItem(target_id)
end
---@param target_id number
---@return nil
function M.DebugLocateItemOnHover(target_id)
    return lib.igDebugLocateItemOnHover(target_id)
end
---@return nil
function M.DebugLocateItemResolveWithLastItem()
    return lib.igDebugLocateItemResolveWithLastItem()
end
---@param fmt string
---@return nil
function M.DebugLog(fmt,...)
    return lib.igDebugLog(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.DebugLogV(fmt,args)
    return lib.igDebugLogV(fmt,args)
end
---@param columns ffi.ct* ImGuiOldColumns*
---@return nil
function M.DebugNodeColumns(columns)
    return lib.igDebugNodeColumns(columns)
end
---@param out_draw_list ffi.ct* ImDrawList*
---@param draw_list ffi.ct* const ImDrawList*
---@param draw_cmd ffi.ct* const ImDrawCmd*
---@param show_mesh boolean
---@param show_aabb boolean
---@return nil
function M.DebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list,draw_list,draw_cmd,show_mesh,show_aabb)
    return lib.igDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list,draw_list,draw_cmd,show_mesh,show_aabb)
end
---@param window ffi.ct* ImGuiWindow*
---@param draw_list ffi.ct* const ImDrawList*
---@param label string
---@return nil
function M.DebugNodeDrawList(window,draw_list,label)
    return lib.igDebugNodeDrawList(window,draw_list,label)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.DebugNodeFont(font)
    return lib.igDebugNodeFont(font)
end
---@param font ffi.ct* ImFont*
---@param glyph ffi.ct* const ImFontGlyph*
---@return nil
function M.DebugNodeFontGlyph(font,glyph)
    return lib.igDebugNodeFontGlyph(font,glyph)
end
---@param state ffi.ct* ImGuiInputTextState*
---@return nil
function M.DebugNodeInputTextState(state)
    return lib.igDebugNodeInputTextState(state)
end
---@param storage ffi.ct* ImGuiStorage*
---@param label string
---@return nil
function M.DebugNodeStorage(storage,label)
    return lib.igDebugNodeStorage(storage,label)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param label string
---@return nil
function M.DebugNodeTabBar(tab_bar,label)
    return lib.igDebugNodeTabBar(tab_bar,label)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.DebugNodeTable(table)
    return lib.igDebugNodeTable(table)
end
---@param settings ffi.ct* ImGuiTableSettings*
---@return nil
function M.DebugNodeTableSettings(settings)
    return lib.igDebugNodeTableSettings(settings)
end
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.DebugNodeViewport(viewport)
    return lib.igDebugNodeViewport(viewport)
end
---@param window ffi.ct* ImGuiWindow*
---@param label string
---@return nil
function M.DebugNodeWindow(window,label)
    return lib.igDebugNodeWindow(window,label)
end
---@param settings ffi.ct* ImGuiWindowSettings*
---@return nil
function M.DebugNodeWindowSettings(settings)
    return lib.igDebugNodeWindowSettings(settings)
end
---@param windows ffi.ct* ImVector_ImGuiWindowPtr*
---@param label string
---@return nil
function M.DebugNodeWindowsList(windows,label)
    return lib.igDebugNodeWindowsList(windows,label)
end
---@param windows ffi.ct* ImGuiWindow**
---@param windows_size number
---@param parent_in_begin_stack ffi.ct* ImGuiWindow*
---@return nil
function M.DebugNodeWindowsListByBeginStackParent(windows,windows_size,parent_in_begin_stack)
    return lib.igDebugNodeWindowsListByBeginStackParent(windows,windows_size,parent_in_begin_stack)
end
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function M.DebugRenderKeyboardPreview(draw_list)
    return lib.igDebugRenderKeyboardPreview(draw_list)
end
---@param draw_list ffi.ct* ImDrawList*
---@param viewport ffi.ct* ImGuiViewportP*
---@param bb ImRect
---@return nil
function M.DebugRenderViewportThumbnail(draw_list,viewport,bb)
    return lib.igDebugRenderViewportThumbnail(draw_list,viewport,bb)
end
---@return nil
function M.DebugStartItemPicker()
    return lib.igDebugStartItemPicker()
end
---@param text string
---@return nil
function M.DebugTextEncoding(text)
    return lib.igDebugTextEncoding(text)
end
---@param ctx ffi.ct*? ImGuiContext*
---@return nil
function M.DestroyContext(ctx)
    ctx = ctx or nil
    return lib.igDestroyContext(ctx)
end
---@param id number
---@param data_type number
---@param p_v ffi.ct* void*
---@param v_speed number
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string
---@param flags number
---@return boolean
function M.DragBehavior(id,data_type,p_v,v_speed,p_min,p_max,format,flags)
    return lib.igDragBehavior(id,data_type,p_v,v_speed,p_min,p_max,format,flags)
end
---@param label string
---@param v ffi.ct* float*
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragFloat(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragFloat2(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat2(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragFloat3(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat3(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragFloat4(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat4(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v_current_min ffi.ct* float*
---@param v_current_max ffi.ct* float*
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param format_max string?
---@param flags number?
---@return boolean
function M.DragFloatRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
    flags = flags or 0
    format = format or "%.3f"
    format_max = format_max or nil
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloatRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragInt(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragInt2(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt2(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragInt3(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt3(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.DragInt4(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt4(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v_current_min ffi.ct* int*
---@param v_current_max ffi.ct* int*
---@param v_speed number?
---@param v_min number?
---@param v_max number?
---@param format string?
---@param format_max string?
---@param flags number?
---@return boolean
function M.DragIntRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
    flags = flags or 0
    format = format or "%d"
    format_max = format_max or nil
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragIntRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param v_speed number?
---@param p_min ffi.ct*? const void*
---@param p_max ffi.ct*? const void*
---@param format string?
---@param flags number?
---@return boolean
function M.DragScalar(label,data_type,p_data,v_speed,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    p_max = p_max or nil
    p_min = p_min or nil
    v_speed = v_speed or 1.0
    return lib.igDragScalar(label,data_type,p_data,v_speed,p_min,p_max,format,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param components number
---@param v_speed number?
---@param p_min ffi.ct*? const void*
---@param p_max ffi.ct*? const void*
---@param format string?
---@param flags number?
---@return boolean
function M.DragScalarN(label,data_type,p_data,components,v_speed,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    p_max = p_max or nil
    p_min = p_min or nil
    v_speed = v_speed or 1.0
    return lib.igDragScalarN(label,data_type,p_data,components,v_speed,p_min,p_max,format,flags)
end
---@param size ImVec2
---@return nil
function M.Dummy(size)
    return lib.igDummy(size)
end
---@return nil
function M.End()
    return lib.igEnd()
end
---@return nil
function M.EndChild()
    return lib.igEndChild()
end
---@return nil
function M.EndChildFrame()
    return lib.igEndChildFrame()
end
---@return nil
function M.EndColumns()
    return lib.igEndColumns()
end
---@return nil
function M.EndCombo()
    return lib.igEndCombo()
end
---@return nil
function M.EndComboPreview()
    return lib.igEndComboPreview()
end
---@return nil
function M.EndDisabled()
    return lib.igEndDisabled()
end
---@return nil
function M.EndDragDropSource()
    return lib.igEndDragDropSource()
end
---@return nil
function M.EndDragDropTarget()
    return lib.igEndDragDropTarget()
end
---@return nil
function M.EndFrame()
    return lib.igEndFrame()
end
---@return nil
function M.EndGroup()
    return lib.igEndGroup()
end
---@return nil
function M.EndListBox()
    return lib.igEndListBox()
end
---@return nil
function M.EndMainMenuBar()
    return lib.igEndMainMenuBar()
end
---@return nil
function M.EndMenu()
    return lib.igEndMenu()
end
---@return nil
function M.EndMenuBar()
    return lib.igEndMenuBar()
end
---@return nil
function M.EndPopup()
    return lib.igEndPopup()
end
---@return nil
function M.EndTabBar()
    return lib.igEndTabBar()
end
---@return nil
function M.EndTabItem()
    return lib.igEndTabItem()
end
---@return nil
function M.EndTable()
    return lib.igEndTable()
end
---@return nil
function M.EndTooltip()
    return lib.igEndTooltip()
end
---@param log_callback ffi.ct* ImGuiErrorLogCallback
---@param user_data ffi.ct*? void*
---@return nil
function M.ErrorCheckEndFrameRecover(log_callback,user_data)
    user_data = user_data or nil
    return lib.igErrorCheckEndFrameRecover(log_callback,user_data)
end
---@param log_callback ffi.ct* ImGuiErrorLogCallback
---@param user_data ffi.ct*? void*
---@return nil
function M.ErrorCheckEndWindowRecover(log_callback,user_data)
    user_data = user_data or nil
    return lib.igErrorCheckEndWindowRecover(log_callback,user_data)
end
---@return nil
function M.ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
    return lib.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.FindBestWindowPosForPopup(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igFindBestWindowPosForPopup(nonUDT_out,window)
    return nonUDT_out
end
---@param ref_pos ImVec2
---@param size ImVec2
---@param last_dir ffi.ct* ImGuiDir*
---@param r_outer ImRect
---@param r_avoid ImRect
---@param policy PopupPositionPolicy
---@return nil
function M.FindBestWindowPosForPopupEx(ref_pos,size,last_dir,r_outer,r_avoid,policy)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igFindBestWindowPosForPopupEx(nonUDT_out,ref_pos,size,last_dir,r_outer,r_avoid,policy)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImGuiWindow*
function M.FindBottomMostVisibleWindowWithinBeginStack(window)
    return lib.igFindBottomMostVisibleWindowWithinBeginStack(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param id number
---@return ffi.ct* ImGuiOldColumns*
function M.FindOrCreateColumns(window,id)
    return lib.igFindOrCreateColumns(window,id)
end
---@param text string
---@param text_end string?
---@return string
function M.FindRenderedTextEnd(text,text_end)
    text_end = text_end or nil
    return ffi.string(lib.igFindRenderedTextEnd(text,text_end))
end
---@param type_name string
---@return ffi.ct* ImGuiSettingsHandler*
function M.FindSettingsHandler(type_name)
    return lib.igFindSettingsHandler(type_name)
end
---@param id number
---@return ffi.ct* ImGuiWindow*
function M.FindWindowByID(id)
    return lib.igFindWindowByID(id)
end
---@param name string
---@return ffi.ct* ImGuiWindow*
function M.FindWindowByName(name)
    return lib.igFindWindowByName(name)
end
---@param window ffi.ct* ImGuiWindow*
---@return number
function M.FindWindowDisplayIndex(window)
    return lib.igFindWindowDisplayIndex(window)
end
---@param id number
---@return ffi.ct* ImGuiWindowSettings*
function M.FindWindowSettingsByID(id)
    return lib.igFindWindowSettingsByID(id)
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImGuiWindowSettings*
function M.FindWindowSettingsByWindow(window)
    return lib.igFindWindowSettingsByWindow(window)
end
---@param under_this_window ffi.ct* ImGuiWindow*
---@param ignore_window ffi.ct* ImGuiWindow*
---@return nil
function M.FocusTopMostWindowUnderOne(under_this_window,ignore_window)
    return lib.igFocusTopMostWindowUnderOne(under_this_window,ignore_window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.FocusWindow(window)
    return lib.igFocusWindow(window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GcAwakeTransientWindowBuffers(window)
    return lib.igGcAwakeTransientWindowBuffers(window)
end
---@return nil
function M.GcCompactTransientMiscBuffers()
    return lib.igGcCompactTransientMiscBuffers()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GcCompactTransientWindowBuffers(window)
    return lib.igGcCompactTransientWindowBuffers(window)
end
---@return number
function M.GetActiveID()
    return lib.igGetActiveID()
end
---@param p_alloc_func ffi.ct* ImGuiMemAllocFunc*
---@param p_free_func ffi.ct* ImGuiMemFreeFunc*
---@param p_user_data ffi.ct* void**
---@return nil
function M.GetAllocatorFunctions(p_alloc_func,p_free_func,p_user_data)
    return lib.igGetAllocatorFunctions(p_alloc_func,p_free_func,p_user_data)
end
---@return ffi.ct* ImDrawList*
function M.GetBackgroundDrawList_Nil()
    return lib.igGetBackgroundDrawList_Nil()
end
---@param viewport ffi.ct* ImGuiViewport*
---@return ffi.ct* ImDrawList*
function M.GetBackgroundDrawList_ViewportPtr(viewport)
    return lib.igGetBackgroundDrawList_ViewportPtr(viewport)
end
function M.GetBackgroundDrawList(a1) -- generic version
    if a1==nil then return M.GetBackgroundDrawList_Nil() end
    if (ffi.istype('ImGuiViewport*',a1) or ffi.istype('ImGuiViewport',a1) or ffi.istype('ImGuiViewport[]',a1)) then return M.GetBackgroundDrawList_ViewportPtr(a1) end
    print(a1)
    error'M.GetBackgroundDrawList could not find overloaded'
end
---@return string
function M.GetClipboardText()
    return ffi.string(lib.igGetClipboardText())
end
---@param idx number
---@param alpha_mul number?
---@return number
function M.GetColorU32_Col(idx,alpha_mul)
    alpha_mul = alpha_mul or 1.0
    return lib.igGetColorU32_Col(idx,alpha_mul)
end
---@param col ffi.ct* const ImVec4
---@return number
function M.GetColorU32_Vec4(col)
    return lib.igGetColorU32_Vec4(col)
end
---@param col number
---@return number
function M.GetColorU32_U32(col)
    return lib.igGetColorU32_U32(col)
end
function M.GetColorU32(a1,a2) -- generic version
    if (ffi.istype('ImGuiCol',a1) or type(a1)=='number') then return M.GetColorU32_Col(a1,a2) end
    if ffi.istype('const ImVec4',a1) then return M.GetColorU32_Vec4(a1) end
    if (ffi.istype('ImU32',a1) or type(a1)=='number') then return M.GetColorU32_U32(a1) end
    print(a1,a2)
    error'M.GetColorU32 could not find overloaded'
end
---@return number
function M.GetColumnIndex()
    return lib.igGetColumnIndex()
end
---@param columns ffi.ct* const ImGuiOldColumns*
---@param offset number
---@return number
function M.GetColumnNormFromOffset(columns,offset)
    return lib.igGetColumnNormFromOffset(columns,offset)
end
---@param column_index number?
---@return number
function M.GetColumnOffset(column_index)
    column_index = column_index or -1
    return lib.igGetColumnOffset(column_index)
end
---@param columns ffi.ct* const ImGuiOldColumns*
---@param offset_norm number
---@return number
function M.GetColumnOffsetFromNorm(columns,offset_norm)
    return lib.igGetColumnOffsetFromNorm(columns,offset_norm)
end
---@param column_index number?
---@return number
function M.GetColumnWidth(column_index)
    column_index = column_index or -1
    return lib.igGetColumnWidth(column_index)
end
---@return number
function M.GetColumnsCount()
    return lib.igGetColumnsCount()
end
---@param str_id string
---@param count number
---@return number
function M.GetColumnsID(str_id,count)
    return lib.igGetColumnsID(str_id,count)
end
---@return nil
function M.GetContentRegionAvail()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionAvail(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetContentRegionMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetContentRegionMaxAbs()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionMaxAbs(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImGuiContext*
function M.GetCurrentContext()
    return lib.igGetCurrentContext()
end
---@return number
function M.GetCurrentFocusScope()
    return lib.igGetCurrentFocusScope()
end
---@return ffi.ct* ImGuiTabBar*
function M.GetCurrentTabBar()
    return lib.igGetCurrentTabBar()
end
---@return ffi.ct* ImGuiTable*
function M.GetCurrentTable()
    return lib.igGetCurrentTable()
end
---@return ffi.ct* ImGuiWindow*
function M.GetCurrentWindow()
    return lib.igGetCurrentWindow()
end
---@return ffi.ct* ImGuiWindow*
function M.GetCurrentWindowRead()
    return lib.igGetCurrentWindowRead()
end
---@return nil
function M.GetCursorPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorPos(nonUDT_out)
    return nonUDT_out
end
---@return number
function M.GetCursorPosX()
    return lib.igGetCursorPosX()
end
---@return number
function M.GetCursorPosY()
    return lib.igGetCursorPosY()
end
---@return nil
function M.GetCursorScreenPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorScreenPos(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetCursorStartPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorStartPos(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImFont*
function M.GetDefaultFont()
    return lib.igGetDefaultFont()
end
---@return ffi.ct* const ImGuiPayload*
function M.GetDragDropPayload()
    return lib.igGetDragDropPayload()
end
---@return ffi.ct* ImDrawData*
function M.GetDrawData()
    return lib.igGetDrawData()
end
---@return ffi.ct* ImDrawListSharedData*
function M.GetDrawListSharedData()
    return lib.igGetDrawListSharedData()
end
---@return number
function M.GetFocusID()
    return lib.igGetFocusID()
end
---@return ffi.ct* ImFont*
function M.GetFont()
    return lib.igGetFont()
end
---@return number
function M.GetFontSize()
    return lib.igGetFontSize()
end
---@return nil
function M.GetFontTexUvWhitePixel()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetFontTexUvWhitePixel(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_Nil()
    return lib.igGetForegroundDrawList_Nil()
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_WindowPtr(window)
    return lib.igGetForegroundDrawList_WindowPtr(window)
end
---@param viewport ffi.ct* ImGuiViewport*
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_ViewportPtr(viewport)
    return lib.igGetForegroundDrawList_ViewportPtr(viewport)
end
function M.GetForegroundDrawList(a1) -- generic version
    if a1==nil then return M.GetForegroundDrawList_Nil() end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.GetForegroundDrawList_WindowPtr(a1) end
    if (ffi.istype('ImGuiViewport*',a1) or ffi.istype('ImGuiViewport',a1) or ffi.istype('ImGuiViewport[]',a1)) then return M.GetForegroundDrawList_ViewportPtr(a1) end
    print(a1)
    error'M.GetForegroundDrawList could not find overloaded'
end
---@return number
function M.GetFrameCount()
    return lib.igGetFrameCount()
end
---@return number
function M.GetFrameHeight()
    return lib.igGetFrameHeight()
end
---@return number
function M.GetFrameHeightWithSpacing()
    return lib.igGetFrameHeightWithSpacing()
end
---@return number
function M.GetHoveredID()
    return lib.igGetHoveredID()
end
---@param str_id string
---@return number
function M.GetID_Str(str_id)
    return lib.igGetID_Str(str_id)
end
---@param str_id_begin string
---@param str_id_end string
---@return number
function M.GetID_StrStr(str_id_begin,str_id_end)
    return lib.igGetID_StrStr(str_id_begin,str_id_end)
end
---@param ptr_id ffi.ct* const void*
---@return number
function M.GetID_Ptr(ptr_id)
    return lib.igGetID_Ptr(ptr_id)
end
function M.GetID(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.GetID_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.GetID_StrStr(a1,a2) end
    if ffi.istype('const void*',a1) then return M.GetID_Ptr(a1) end
    print(a1,a2)
    error'M.GetID could not find overloaded'
end
---@param str_id_begin string
---@param str_id_end string
---@param seed number
---@return number
function M.GetIDWithSeed_Str(str_id_begin,str_id_end,seed)
    return lib.igGetIDWithSeed_Str(str_id_begin,str_id_end,seed)
end
---@param n number
---@param seed number
---@return number
function M.GetIDWithSeed_Int(n,seed)
    return lib.igGetIDWithSeed_Int(n,seed)
end
function M.GetIDWithSeed(a1,a2,a3) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.GetIDWithSeed_Str(a1,a2,a3) end
    if (ffi.istype('int',a1) or type(a1)=='number') then return M.GetIDWithSeed_Int(a1,a2) end
    print(a1,a2,a3)
    error'M.GetIDWithSeed could not find overloaded'
end
---@return ffi.ct* ImGuiIO*
function M.GetIO()
    return lib.igGetIO()
end
---@param id number
---@return ffi.ct* ImGuiInputTextState*
function M.GetInputTextState(id)
    return lib.igGetInputTextState(id)
end
---@return number
function M.GetItemFlags()
    return lib.igGetItemFlags()
end
---@return number
function M.GetItemID()
    return lib.igGetItemID()
end
---@return nil
function M.GetItemRectMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetItemRectMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectMin(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetItemRectSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectSize(nonUDT_out)
    return nonUDT_out
end
---@return number
function M.GetItemStatusFlags()
    return lib.igGetItemStatusFlags()
end
---@param key_chord number
---@param out_buf ffi.ct* char*
---@param out_buf_size number
---@return nil
function M.GetKeyChordName(key_chord,out_buf,out_buf_size)
    return lib.igGetKeyChordName(key_chord,out_buf,out_buf_size)
end
---@param key Key
---@return ffi.ct* ImGuiKeyData*
function M.GetKeyData(key)
    return lib.igGetKeyData(key)
end
---@param key Key
---@return Key
function M.GetKeyIndex(key)
    return lib.igGetKeyIndex(key)
end
---@param key_left Key
---@param key_right Key
---@param key_up Key
---@param key_down Key
---@return nil
function M.GetKeyMagnitude2d(key_left,key_right,key_up,key_down)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetKeyMagnitude2d(nonUDT_out,key_left,key_right,key_up,key_down)
    return nonUDT_out
end
---@param key Key
---@return string
function M.GetKeyName(key)
    return ffi.string(lib.igGetKeyName(key))
end
---@param key Key
---@return number
function M.GetKeyOwner(key)
    return lib.igGetKeyOwner(key)
end
---@param key Key
---@return ffi.ct* ImGuiKeyOwnerData*
function M.GetKeyOwnerData(key)
    return lib.igGetKeyOwnerData(key)
end
---@param key Key
---@param repeat_delay number
---@param rate number
---@return number
function M.GetKeyPressedAmount(key,repeat_delay,rate)
    return lib.igGetKeyPressedAmount(key,repeat_delay,rate)
end
---@return ffi.ct* ImGuiViewport*
function M.GetMainViewport()
    return lib.igGetMainViewport()
end
---@param button number
---@return number
function M.GetMouseClickedCount(button)
    return lib.igGetMouseClickedCount(button)
end
---@return number
function M.GetMouseCursor()
    return lib.igGetMouseCursor()
end
---@param button number?
---@param lock_threshold number?
---@return nil
function M.GetMouseDragDelta(button,lock_threshold)
    button = button or 0
    lock_threshold = lock_threshold or -1.0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMouseDragDelta(nonUDT_out,button,lock_threshold)
    return nonUDT_out
end
---@return nil
function M.GetMousePos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMousePos(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetMousePosOnOpeningCurrentPopup()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMousePosOnOpeningCurrentPopup(nonUDT_out)
    return nonUDT_out
end
---@param axis Axis
---@return number
function M.GetNavTweakPressedAmount(axis)
    return lib.igGetNavTweakPressedAmount(axis)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GetPopupAllowedExtentRect(window)
    local nonUDT_out = ffi.new("ImRect")
    lib.igGetPopupAllowedExtentRect(nonUDT_out,window)
    return nonUDT_out
end
---@return number
function M.GetScrollMaxX()
    return lib.igGetScrollMaxX()
end
---@return number
function M.GetScrollMaxY()
    return lib.igGetScrollMaxY()
end
---@return number
function M.GetScrollX()
    return lib.igGetScrollX()
end
---@return number
function M.GetScrollY()
    return lib.igGetScrollY()
end
---@param key_chord number
---@return ffi.ct* ImGuiKeyRoutingData*
function M.GetShortcutRoutingData(key_chord)
    return lib.igGetShortcutRoutingData(key_chord)
end
---@return ffi.ct* ImGuiStorage*
function M.GetStateStorage()
    return lib.igGetStateStorage()
end
---@return ffi.ct* ImGuiStyle*
function M.GetStyle()
    return lib.igGetStyle()
end
---@param idx number
---@return string
function M.GetStyleColorName(idx)
    return ffi.string(lib.igGetStyleColorName(idx))
end
---@param idx number
---@return ffi.ct* const ImVec4*
function M.GetStyleColorVec4(idx)
    return lib.igGetStyleColorVec4(idx)
end
---@return number
function M.GetTextLineHeight()
    return lib.igGetTextLineHeight()
end
---@return number
function M.GetTextLineHeightWithSpacing()
    return lib.igGetTextLineHeightWithSpacing()
end
---@return number
function M.GetTime()
    return lib.igGetTime()
end
---@return ffi.ct* ImGuiWindow*
function M.GetTopMostAndVisiblePopupModal()
    return lib.igGetTopMostAndVisiblePopupModal()
end
---@return ffi.ct* ImGuiWindow*
function M.GetTopMostPopupModal()
    return lib.igGetTopMostPopupModal()
end
---@return number
function M.GetTreeNodeToLabelSpacing()
    return lib.igGetTreeNodeToLabelSpacing()
end
---@param flags number
---@param repeat_delay ffi.ct* float*
---@param repeat_rate ffi.ct* float*
---@return nil
function M.GetTypematicRepeatRate(flags,repeat_delay,repeat_rate)
    return lib.igGetTypematicRepeatRate(flags,repeat_delay,repeat_rate)
end
---@return string
function M.GetVersion()
    return ffi.string(lib.igGetVersion())
end
---@return nil
function M.GetWindowContentRegionMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowContentRegionMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetWindowContentRegionMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowContentRegionMin(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImDrawList*
function M.GetWindowDrawList()
    return lib.igGetWindowDrawList()
end
---@return number
function M.GetWindowHeight()
    return lib.igGetWindowHeight()
end
---@return nil
function M.GetWindowPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowPos(nonUDT_out)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@param dir number
---@return number
function M.GetWindowResizeBorderID(window,dir)
    return lib.igGetWindowResizeBorderID(window,dir)
end
---@param window ffi.ct* ImGuiWindow*
---@param n number
---@return number
function M.GetWindowResizeCornerID(window,n)
    return lib.igGetWindowResizeCornerID(window,n)
end
---@param window ffi.ct* ImGuiWindow*
---@param axis Axis
---@return number
function M.GetWindowScrollbarID(window,axis)
    return lib.igGetWindowScrollbarID(window,axis)
end
---@param window ffi.ct* ImGuiWindow*
---@param axis Axis
---@return nil
function M.GetWindowScrollbarRect(window,axis)
    local nonUDT_out = ffi.new("ImRect")
    lib.igGetWindowScrollbarRect(nonUDT_out,window,axis)
    return nonUDT_out
end
---@return nil
function M.GetWindowSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowSize(nonUDT_out)
    return nonUDT_out
end
---@return number
function M.GetWindowWidth()
    return lib.igGetWindowWidth()
end
---@param x number
---@return number
function M.ImAbs_Int(x)
    return lib.igImAbs_Int(x)
end
---@param x number
---@return number
function M.ImAbs_Float(x)
    return lib.igImAbs_Float(x)
end
---@param x number
---@return number
function M.ImAbs_double(x)
    return lib.igImAbs_double(x)
end
function M.ImAbs(a1) -- generic version
    if (ffi.istype('int',a1) or type(a1)=='number') then return M.ImAbs_Int(a1) end
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImAbs_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImAbs_double(a1) end
    print(a1)
    error'M.ImAbs could not find overloaded'
end
---@param col_a number
---@param col_b number
---@return number
function M.ImAlphaBlendColors(col_a,col_b)
    return lib.igImAlphaBlendColors(col_a,col_b)
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param t number
---@return nil
function M.ImBezierCubicCalc(p1,p2,p3,p4,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicCalc(nonUDT_out,p1,p2,p3,p4,t)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param p ImVec2
---@param num_segments number
---@return nil
function M.ImBezierCubicClosestPoint(p1,p2,p3,p4,p,num_segments)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicClosestPoint(nonUDT_out,p1,p2,p3,p4,p,num_segments)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param p ImVec2
---@param tess_tol number
---@return nil
function M.ImBezierCubicClosestPointCasteljau(p1,p2,p3,p4,p,tess_tol)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicClosestPointCasteljau(nonUDT_out,p1,p2,p3,p4,p,tess_tol)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param t number
---@return nil
function M.ImBezierQuadraticCalc(p1,p2,p3,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierQuadraticCalc(nonUDT_out,p1,p2,p3,t)
    return nonUDT_out
end
---@param arr ffi.ct* ImU32*
---@param bitcount number
---@return nil
function M.ImBitArrayClearAllBits(arr,bitcount)
    return lib.igImBitArrayClearAllBits(arr,bitcount)
end
---@param arr ffi.ct* ImU32*
---@param n number
---@return nil
function M.ImBitArrayClearBit(arr,n)
    return lib.igImBitArrayClearBit(arr,n)
end
---@param bitcount number
---@return number
function M.ImBitArrayGetStorageSizeInBytes(bitcount)
    return lib.igImBitArrayGetStorageSizeInBytes(bitcount)
end
---@param arr ffi.ct* ImU32*
---@param n number
---@return nil
function M.ImBitArraySetBit(arr,n)
    return lib.igImBitArraySetBit(arr,n)
end
---@param arr ffi.ct* ImU32*
---@param n number
---@param n2 number
---@return nil
function M.ImBitArraySetBitRange(arr,n,n2)
    return lib.igImBitArraySetBitRange(arr,n,n2)
end
---@param arr ffi.ct* const ImU32*
---@param n number
---@return boolean
function M.ImBitArrayTestBit(arr,n)
    return lib.igImBitArrayTestBit(arr,n)
end
---@param c number
---@return boolean
function M.ImCharIsBlankA(c)
    return lib.igImCharIsBlankA(c)
end
---@param c number
---@return boolean
function M.ImCharIsBlankW(c)
    return lib.igImCharIsBlankW(c)
end
---@param v ImVec2
---@param mn ImVec2
---@param mx ImVec2
---@return nil
function M.ImClamp(v,mn,mx)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImClamp(nonUDT_out,v,mn,mx)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@return number
function M.ImDot(a,b)
    return lib.igImDot(a,b)
end
---@param avg number
---@param sample number
---@param n number
---@return number
function M.ImExponentialMovingAverage(avg,sample,n)
    return lib.igImExponentialMovingAverage(avg,sample,n)
end
---@param file ffi.ct* ImFileHandle
---@return boolean
function M.ImFileClose(file)
    return lib.igImFileClose(file)
end
---@param file ffi.ct* ImFileHandle
---@return number
function M.ImFileGetSize(file)
    return lib.igImFileGetSize(file)
end
---@param filename string
---@param mode string
---@param out_file_size ffi.ct*? size_t*
---@param padding_bytes number?
---@return ffi.ct* void*
function M.ImFileLoadToMemory(filename,mode,out_file_size,padding_bytes)
    out_file_size = out_file_size or nil
    padding_bytes = padding_bytes or 0
    return lib.igImFileLoadToMemory(filename,mode,out_file_size,padding_bytes)
end
---@param filename string
---@param mode string
---@return ffi.ct* ImFileHandle
function M.ImFileOpen(filename,mode)
    return lib.igImFileOpen(filename,mode)
end
---@param data ffi.ct* void*
---@param size number
---@param count number
---@param file ffi.ct* ImFileHandle
---@return number
function M.ImFileRead(data,size,count,file)
    return lib.igImFileRead(data,size,count,file)
end
---@param data ffi.ct* const void*
---@param size number
---@param count number
---@param file ffi.ct* ImFileHandle
---@return number
function M.ImFileWrite(data,size,count,file)
    return lib.igImFileWrite(data,size,count,file)
end
---@param f number
---@return number
function M.ImFloor_Float(f)
    return lib.igImFloor_Float(f)
end
---@param v ImVec2
---@return nil
function M.ImFloor_Vec2(v)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImFloor_Vec2(nonUDT_out,v)
    return nonUDT_out
end
function M.ImFloor(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImFloor_Float(a1) end
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) then return M.ImFloor_Vec2(a2) end
    print(a1,a2)
    error'M.ImFloor could not find overloaded'
end
---@param f number
---@return number
function M.ImFloorSigned_Float(f)
    return lib.igImFloorSigned_Float(f)
end
---@param v ImVec2
---@return nil
function M.ImFloorSigned_Vec2(v)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImFloorSigned_Vec2(nonUDT_out,v)
    return nonUDT_out
end
function M.ImFloorSigned(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImFloorSigned_Float(a1) end
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) then return M.ImFloorSigned_Vec2(a2) end
    print(a1,a2)
    error'M.ImFloorSigned could not find overloaded'
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ImFontAtlasBuildFinish(atlas)
    return lib.igImFontAtlasBuildFinish(atlas)
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ImFontAtlasBuildInit(atlas)
    return lib.igImFontAtlasBuildInit(atlas)
end
---@param out_table ffi.ct* unsigned char[256]
---@param in_multiply_factor number
---@return nil
function M.ImFontAtlasBuildMultiplyCalcLookupTable(out_table,in_multiply_factor)
    return lib.igImFontAtlasBuildMultiplyCalcLookupTable(out_table,in_multiply_factor)
end
---@param table ffi.ct* const unsigned char[256]
---@param pixels ffi.ct* unsigned char*
---@param x number
---@param y number
---@param w number
---@param h number
---@param stride number
---@return nil
function M.ImFontAtlasBuildMultiplyRectAlpha8(table,pixels,x,y,w,h,stride)
    return lib.igImFontAtlasBuildMultiplyRectAlpha8(table,pixels,x,y,w,h,stride)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param stbrp_context_opaque ffi.ct* void*
---@return nil
function M.ImFontAtlasBuildPackCustomRects(atlas,stbrp_context_opaque)
    return lib.igImFontAtlasBuildPackCustomRects(atlas,stbrp_context_opaque)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param x number
---@param y number
---@param w number
---@param h number
---@param in_str string
---@param in_marker_char number
---@param in_marker_pixel_value number
---@return nil
function M.ImFontAtlasBuildRender32bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
    return lib.igImFontAtlasBuildRender32bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param x number
---@param y number
---@param w number
---@param h number
---@param in_str string
---@param in_marker_char number
---@param in_marker_pixel_value ffi.ct* unsigned char
---@return nil
function M.ImFontAtlasBuildRender8bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
    return lib.igImFontAtlasBuildRender8bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param font ffi.ct* ImFont*
---@param font_config ffi.ct* ImFontConfig*
---@param ascent number
---@param descent number
---@return nil
function M.ImFontAtlasBuildSetupFont(atlas,font,font_config,ascent,descent)
    return lib.igImFontAtlasBuildSetupFont(atlas,font,font_config,ascent,descent)
end
---@return ffi.ct* const ImFontBuilderIO*
function M.ImFontAtlasGetBuilderForStbTruetype()
    return lib.igImFontAtlasGetBuilderForStbTruetype()
end
---@param buf ffi.ct* char*
---@param buf_size number
---@param fmt string
---@return number
function M.ImFormatString(buf,buf_size,fmt,...)
    return lib.igImFormatString(buf,buf_size,fmt,...)
end
---@param out_buf ffi.ct* const char**
---@param out_buf_end ffi.ct* const char**
---@param fmt string
---@return nil
function M.ImFormatStringToTempBuffer(out_buf,out_buf_end,fmt,...)
    return lib.igImFormatStringToTempBuffer(out_buf,out_buf_end,fmt,...)
end
---@param out_buf ffi.ct* const char**
---@param out_buf_end ffi.ct* const char**
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.ImFormatStringToTempBufferV(out_buf,out_buf_end,fmt,args)
    return lib.igImFormatStringToTempBufferV(out_buf,out_buf_end,fmt,args)
end
---@param buf ffi.ct* char*
---@param buf_size number
---@param fmt string
---@param args ffi.ct* va_list
---@return number
function M.ImFormatStringV(buf,buf_size,fmt,args)
    return lib.igImFormatStringV(buf,buf_size,fmt,args)
end
---@param dx number
---@param dy number
---@return number
function M.ImGetDirQuadrantFromDelta(dx,dy)
    return lib.igImGetDirQuadrantFromDelta(dx,dy)
end
---@param data ffi.ct* const void*
---@param data_size number
---@param seed number?
---@return number
function M.ImHashData(data,data_size,seed)
    seed = seed or 0
    return lib.igImHashData(data,data_size,seed)
end
---@param data string
---@param data_size number?
---@param seed number?
---@return number
function M.ImHashStr(data,data_size,seed)
    data_size = data_size or 0
    seed = seed or 0
    return lib.igImHashStr(data,data_size,seed)
end
---@param lhs ImVec2
---@param fail_value number
---@return number
function M.ImInvLength(lhs,fail_value)
    return lib.igImInvLength(lhs,fail_value)
end
---@param f number
---@return boolean
function M.ImIsFloatAboveGuaranteedIntegerPrecision(f)
    return lib.igImIsFloatAboveGuaranteedIntegerPrecision(f)
end
---@param v number
---@return boolean
function M.ImIsPowerOfTwo_Int(v)
    return lib.igImIsPowerOfTwo_Int(v)
end
---@param v number
---@return boolean
function M.ImIsPowerOfTwo_U64(v)
    return lib.igImIsPowerOfTwo_U64(v)
end
function M.ImIsPowerOfTwo(a1) -- generic version
    if (ffi.istype('int',a1) or type(a1)=='number') then return M.ImIsPowerOfTwo_Int(a1) end
    if ffi.istype('ImU64',a1) then return M.ImIsPowerOfTwo_U64(a1) end
    print(a1)
    error'M.ImIsPowerOfTwo could not find overloaded'
end
---@param lhs ImVec2
---@return number
function M.ImLengthSqr_Vec2(lhs)
    return lib.igImLengthSqr_Vec2(lhs)
end
---@param lhs ffi.ct* const ImVec4
---@return number
function M.ImLengthSqr_Vec4(lhs)
    return lib.igImLengthSqr_Vec4(lhs)
end
function M.ImLengthSqr(a1) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.ImLengthSqr_Vec2(a1) end
    if ffi.istype('const ImVec4',a1) then return M.ImLengthSqr_Vec4(a1) end
    print(a1)
    error'M.ImLengthSqr could not find overloaded'
end
---@param a ImVec2
---@param b ImVec2
---@param t number
---@return nil
function M.ImLerp_Vec2Float(a,b,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLerp_Vec2Float(nonUDT_out,a,b,t)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@param t ImVec2
---@return nil
function M.ImLerp_Vec2Vec2(a,b,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLerp_Vec2Vec2(nonUDT_out,a,b,t)
    return nonUDT_out
end
---@param a ffi.ct* const ImVec4
---@param b ffi.ct* const ImVec4
---@param t number
---@return nil
function M.ImLerp_Vec4(a,b,t)
    local nonUDT_out = ffi.new("ImVec4")
    lib.igImLerp_Vec4(nonUDT_out,a,b,t)
    return nonUDT_out
end
function M.ImLerp(a2,a3,a4) -- generic version
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) and (ffi.istype('float',a4) or type(a4)=='number') then return M.ImLerp_Vec2Float(a2,a3,a4) end
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) and ffi.istype('const ImVec2',a4) then return M.ImLerp_Vec2Vec2(a2,a3,a4) end
    if (ffi.istype('ImVec4*',a1) or ffi.istype('ImVec4',a1) or ffi.istype('ImVec4[]',a1)) then return M.ImLerp_Vec4(a2,a3,a4) end
    print(a2,a3,a4)
    error'M.ImLerp could not find overloaded'
end
---@param a ImVec2
---@param b ImVec2
---@param p ImVec2
---@return nil
function M.ImLineClosestPoint(a,b,p)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLineClosestPoint(nonUDT_out,a,b,p)
    return nonUDT_out
end
---@param current number
---@param target number
---@param speed number
---@return number
function M.ImLinearSweep(current,target,speed)
    return lib.igImLinearSweep(current,target,speed)
end
---@param x number
---@return number
function M.ImLog_Float(x)
    return lib.igImLog_Float(x)
end
---@param x number
---@return number
function M.ImLog_double(x)
    return lib.igImLog_double(x)
end
function M.ImLog(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImLog_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImLog_double(a1) end
    print(a1)
    error'M.ImLog could not find overloaded'
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMax(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMax(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMin(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMin(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param a number
---@param b number
---@return number
function M.ImModPositive(a,b)
    return lib.igImModPositive(a,b)
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMul(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMul(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param format string
---@return string
function M.ImParseFormatFindEnd(format)
    return ffi.string(lib.igImParseFormatFindEnd(format))
end
---@param format string
---@return string
function M.ImParseFormatFindStart(format)
    return ffi.string(lib.igImParseFormatFindStart(format))
end
---@param format string
---@param default_value number
---@return number
function M.ImParseFormatPrecision(format,default_value)
    return lib.igImParseFormatPrecision(format,default_value)
end
---@param fmt_in string
---@param fmt_out ffi.ct* char*
---@param fmt_out_size number
---@return nil
function M.ImParseFormatSanitizeForPrinting(fmt_in,fmt_out,fmt_out_size)
    return lib.igImParseFormatSanitizeForPrinting(fmt_in,fmt_out,fmt_out_size)
end
---@param fmt_in string
---@param fmt_out ffi.ct* char*
---@param fmt_out_size number
---@return string
function M.ImParseFormatSanitizeForScanning(fmt_in,fmt_out,fmt_out_size)
    return ffi.string(lib.igImParseFormatSanitizeForScanning(fmt_in,fmt_out,fmt_out_size))
end
---@param format string
---@param buf ffi.ct* char*
---@param buf_size number
---@return string
function M.ImParseFormatTrimDecorations(format,buf,buf_size)
    return ffi.string(lib.igImParseFormatTrimDecorations(format,buf,buf_size))
end
---@param x number
---@param y number
---@return number
function M.ImPow_Float(x,y)
    return lib.igImPow_Float(x,y)
end
---@param x number
---@param y number
---@return number
function M.ImPow_double(x,y)
    return lib.igImPow_double(x,y)
end
function M.ImPow(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImPow_Float(a1,a2) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImPow_double(a1,a2) end
    print(a1,a2)
    error'M.ImPow could not find overloaded'
end
---@param base ffi.ct* void*
---@param count number
---@param size_of_element number
---@param compare_func ffi.ct* int(*)(void const*,void const*)
---@return nil
function M.ImQsort(base,count,size_of_element,compare_func)
    return lib.igImQsort(base,count,size_of_element,compare_func)
end
---@param v ImVec2
---@param cos_a number
---@param sin_a number
---@return nil
function M.ImRotate(v,cos_a,sin_a)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImRotate(nonUDT_out,v,cos_a,sin_a)
    return nonUDT_out
end
---@param x number
---@return number
function M.ImRsqrt_Float(x)
    return lib.igImRsqrt_Float(x)
end
---@param x number
---@return number
function M.ImRsqrt_double(x)
    return lib.igImRsqrt_double(x)
end
function M.ImRsqrt(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImRsqrt_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImRsqrt_double(a1) end
    print(a1)
    error'M.ImRsqrt could not find overloaded'
end
---@param f number
---@return number
function M.ImSaturate(f)
    return lib.igImSaturate(f)
end
---@param x number
---@return number
function M.ImSign_Float(x)
    return lib.igImSign_Float(x)
end
---@param x number
---@return number
function M.ImSign_double(x)
    return lib.igImSign_double(x)
end
function M.ImSign(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImSign_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImSign_double(a1) end
    print(a1)
    error'M.ImSign could not find overloaded'
end
---@param str string
---@return string
function M.ImStrSkipBlank(str)
    return ffi.string(lib.igImStrSkipBlank(str))
end
---@param str ffi.ct* char*
---@return nil
function M.ImStrTrimBlanks(str)
    return lib.igImStrTrimBlanks(str)
end
---@param buf_mid_line ffi.ct* const ImWchar*
---@param buf_begin ffi.ct* const ImWchar*
---@return ffi.ct* const ImWchar*
function M.ImStrbolW(buf_mid_line,buf_begin)
    return lib.igImStrbolW(buf_mid_line,buf_begin)
end
---@param str_begin string
---@param str_end string
---@param c number
---@return string
function M.ImStrchrRange(str_begin,str_end,c)
    return ffi.string(lib.igImStrchrRange(str_begin,str_end,c))
end
---@param str string
---@return ffi.ct* char*
function M.ImStrdup(str)
    return lib.igImStrdup(str)
end
---@param dst ffi.ct* char*
---@param p_dst_size ffi.ct* size_t*
---@param str string
---@return ffi.ct* char*
function M.ImStrdupcpy(dst,p_dst_size,str)
    return lib.igImStrdupcpy(dst,p_dst_size,str)
end
---@param str string
---@param str_end string
---@return string
function M.ImStreolRange(str,str_end)
    return ffi.string(lib.igImStreolRange(str,str_end))
end
---@param str1 string
---@param str2 string
---@return number
function M.ImStricmp(str1,str2)
    return lib.igImStricmp(str1,str2)
end
---@param haystack string
---@param haystack_end string
---@param needle string
---@param needle_end string
---@return string
function M.ImStristr(haystack,haystack_end,needle,needle_end)
    return ffi.string(lib.igImStristr(haystack,haystack_end,needle,needle_end))
end
---@param str ffi.ct* const ImWchar*
---@return number
function M.ImStrlenW(str)
    return lib.igImStrlenW(str)
end
---@param dst ffi.ct* char*
---@param src string
---@param count number
---@return nil
function M.ImStrncpy(dst,src,count)
    return lib.igImStrncpy(dst,src,count)
end
---@param str1 string
---@param str2 string
---@param count number
---@return number
function M.ImStrnicmp(str1,str2,count)
    return lib.igImStrnicmp(str1,str2,count)
end
---@param out_char ffi.ct* unsigned int*
---@param in_text string
---@param in_text_end string
---@return number
function M.ImTextCharFromUtf8(out_char,in_text,in_text_end)
    return lib.igImTextCharFromUtf8(out_char,in_text,in_text_end)
end
---@param out_buf ffi.ct* char[5]
---@param c number
---@return string
function M.ImTextCharToUtf8(out_buf,c)
    return ffi.string(lib.igImTextCharToUtf8(out_buf,c))
end
---@param in_text string
---@param in_text_end string
---@return number
function M.ImTextCountCharsFromUtf8(in_text,in_text_end)
    return lib.igImTextCountCharsFromUtf8(in_text,in_text_end)
end
---@param in_text string
---@param in_text_end string
---@return number
function M.ImTextCountUtf8BytesFromChar(in_text,in_text_end)
    return lib.igImTextCountUtf8BytesFromChar(in_text,in_text_end)
end
---@param in_text ffi.ct* const ImWchar*
---@param in_text_end ffi.ct* const ImWchar*
---@return number
function M.ImTextCountUtf8BytesFromStr(in_text,in_text_end)
    return lib.igImTextCountUtf8BytesFromStr(in_text,in_text_end)
end
---@param out_buf ffi.ct* ImWchar*
---@param out_buf_size number
---@param in_text string
---@param in_text_end string
---@param in_remaining ffi.ct*? const char**
---@return number
function M.ImTextStrFromUtf8(out_buf,out_buf_size,in_text,in_text_end,in_remaining)
    in_remaining = in_remaining or nil
    return lib.igImTextStrFromUtf8(out_buf,out_buf_size,in_text,in_text_end,in_remaining)
end
---@param out_buf ffi.ct* char*
---@param out_buf_size number
---@param in_text ffi.ct* const ImWchar*
---@param in_text_end ffi.ct* const ImWchar*
---@return number
function M.ImTextStrToUtf8(out_buf,out_buf_size,in_text,in_text_end)
    return lib.igImTextStrToUtf8(out_buf,out_buf_size,in_text,in_text_end)
end
---@param c number
---@return number
function M.ImToUpper(c)
    return lib.igImToUpper(c)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@return number
function M.ImTriangleArea(a,b,c)
    return lib.igImTriangleArea(a,b,c)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@param out_u ffi.ct* float*
---@param out_v ffi.ct* float*
---@param out_w ffi.ct* float*
---@return nil
function M.ImTriangleBarycentricCoords(a,b,c,p,out_u,out_v,out_w)
    return lib.igImTriangleBarycentricCoords(a,b,c,p,out_u,out_v,out_w)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@return nil
function M.ImTriangleClosestPoint(a,b,c,p)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImTriangleClosestPoint(nonUDT_out,a,b,c,p)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@return boolean
function M.ImTriangleContainsPoint(a,b,c,p)
    return lib.igImTriangleContainsPoint(a,b,c,p)
end
---@param v number
---@return number
function M.ImUpperPowerOfTwo(v)
    return lib.igImUpperPowerOfTwo(v)
end
---@param user_texture_id ffi.ct* ImTextureID
---@param size ImVec2
---@param uv0 ImVec2?
---@param uv1 ImVec2?
---@param tint_col ffi.ct*? const ImVec4
---@param border_col ffi.ct*? const ImVec4
---@return nil
function M.Image(user_texture_id,size,uv0,uv1,tint_col,border_col)
    border_col = border_col or ImVec4(0,0,0,0)
    tint_col = tint_col or ImVec4(1,1,1,1)
    uv0 = uv0 or ImVec2(0,0)
    uv1 = uv1 or ImVec2(1,1)
    return lib.igImage(user_texture_id,size,uv0,uv1,tint_col,border_col)
end
---@param str_id string
---@param user_texture_id ffi.ct* ImTextureID
---@param size ImVec2
---@param uv0 ImVec2?
---@param uv1 ImVec2?
---@param bg_col ffi.ct*? const ImVec4
---@param tint_col ffi.ct*? const ImVec4
---@return boolean
function M.ImageButton(str_id,user_texture_id,size,uv0,uv1,bg_col,tint_col)
    bg_col = bg_col or ImVec4(0,0,0,0)
    tint_col = tint_col or ImVec4(1,1,1,1)
    uv0 = uv0 or ImVec2(0,0)
    uv1 = uv1 or ImVec2(1,1)
    return lib.igImageButton(str_id,user_texture_id,size,uv0,uv1,bg_col,tint_col)
end
---@param id number
---@param texture_id ffi.ct* ImTextureID
---@param size ImVec2
---@param uv0 ImVec2
---@param uv1 ImVec2
---@param bg_col ffi.ct* const ImVec4
---@param tint_col ffi.ct* const ImVec4
---@param flags number?
---@return boolean
function M.ImageButtonEx(id,texture_id,size,uv0,uv1,bg_col,tint_col,flags)
    flags = flags or 0
    return lib.igImageButtonEx(id,texture_id,size,uv0,uv1,bg_col,tint_col,flags)
end
---@param indent_w number?
---@return nil
function M.Indent(indent_w)
    indent_w = indent_w or 0.0
    return lib.igIndent(indent_w)
end
---@return nil
function M.Initialize()
    return lib.igInitialize()
end
---@param label string
---@param v ffi.ct* double*
---@param step number?
---@param step_fast number?
---@param format string?
---@param flags number?
---@return boolean
function M.InputDouble(label,v,step,step_fast,format,flags)
    flags = flags or 0
    format = format or "%.6f"
    step = step or 0
    step_fast = step_fast or 0
    return lib.igInputDouble(label,v,step,step_fast,format,flags)
end
---@param label string
---@param v ffi.ct* float*
---@param step number?
---@param step_fast number?
---@param format string?
---@param flags number?
---@return boolean
function M.InputFloat(label,v,step,step_fast,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    step = step or 0.0
    step_fast = step_fast or 0.0
    return lib.igInputFloat(label,v,step,step_fast,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param format string?
---@param flags number?
---@return boolean
function M.InputFloat2(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat2(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param format string?
---@param flags number?
---@return boolean
function M.InputFloat3(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat3(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param format string?
---@param flags number?
---@return boolean
function M.InputFloat4(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat4(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param step number?
---@param step_fast number?
---@param flags number?
---@return boolean
function M.InputInt(label,v,step,step_fast,flags)
    flags = flags or 0
    step = step or 1
    step_fast = step_fast or 100
    return lib.igInputInt(label,v,step,step_fast,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param flags number?
---@return boolean
function M.InputInt2(label,v,flags)
    flags = flags or 0
    return lib.igInputInt2(label,v,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param flags number?
---@return boolean
function M.InputInt3(label,v,flags)
    flags = flags or 0
    return lib.igInputInt3(label,v,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param flags number?
---@return boolean
function M.InputInt4(label,v,flags)
    flags = flags or 0
    return lib.igInputInt4(label,v,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param p_step ffi.ct*? const void*
---@param p_step_fast ffi.ct*? const void*
---@param format string?
---@param flags number?
---@return boolean
function M.InputScalar(label,data_type,p_data,p_step,p_step_fast,format,flags)
    flags = flags or 0
    format = format or nil
    p_step = p_step or nil
    p_step_fast = p_step_fast or nil
    return lib.igInputScalar(label,data_type,p_data,p_step,p_step_fast,format,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param components number
---@param p_step ffi.ct*? const void*
---@param p_step_fast ffi.ct*? const void*
---@param format string?
---@param flags number?
---@return boolean
function M.InputScalarN(label,data_type,p_data,components,p_step,p_step_fast,format,flags)
    flags = flags or 0
    format = format or nil
    p_step = p_step or nil
    p_step_fast = p_step_fast or nil
    return lib.igInputScalarN(label,data_type,p_data,components,p_step,p_step_fast,format,flags)
end
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number
---@param flags number?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputText(label,buf,buf_size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    user_data = user_data or nil
    return lib.igInputText(label,buf,buf_size,flags,callback,user_data)
end
---@param label string
---@param hint string
---@param buf ffi.ct* char*
---@param buf_size number
---@param size_arg ImVec2
---@param flags number
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextEx(label,hint,buf,buf_size,size_arg,flags,callback,user_data)
    callback = callback or nil
    user_data = user_data or nil
    return lib.igInputTextEx(label,hint,buf,buf_size,size_arg,flags,callback,user_data)
end
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number
---@param size ImVec2?
---@param flags number?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextMultiline(label,buf,buf_size,size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    size = size or ImVec2(0,0)
    user_data = user_data or nil
    return lib.igInputTextMultiline(label,buf,buf_size,size,flags,callback,user_data)
end
---@param label string
---@param hint string
---@param buf ffi.ct* char*
---@param buf_size number
---@param flags number?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextWithHint(label,hint,buf,buf_size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    user_data = user_data or nil
    return lib.igInputTextWithHint(label,hint,buf,buf_size,flags,callback,user_data)
end
---@param str_id string
---@param size ImVec2
---@param flags number?
---@return boolean
function M.InvisibleButton(str_id,size,flags)
    flags = flags or 0
    return lib.igInvisibleButton(str_id,size,flags)
end
---@param dir number
---@return boolean
function M.IsActiveIdUsingNavDir(dir)
    return lib.igIsActiveIdUsingNavDir(dir)
end
---@param key Key
---@return boolean
function M.IsAliasKey(key)
    return lib.igIsAliasKey(key)
end
---@return boolean
function M.IsAnyItemActive()
    return lib.igIsAnyItemActive()
end
---@return boolean
function M.IsAnyItemFocused()
    return lib.igIsAnyItemFocused()
end
---@return boolean
function M.IsAnyItemHovered()
    return lib.igIsAnyItemHovered()
end
---@return boolean
function M.IsAnyMouseDown()
    return lib.igIsAnyMouseDown()
end
---@param bb ImRect
---@param id number
---@return boolean
function M.IsClippedEx(bb,id)
    return lib.igIsClippedEx(bb,id)
end
---@return boolean
function M.IsDragDropActive()
    return lib.igIsDragDropActive()
end
---@return boolean
function M.IsDragDropPayloadBeingAccepted()
    return lib.igIsDragDropPayloadBeingAccepted()
end
---@param key Key
---@return boolean
function M.IsGamepadKey(key)
    return lib.igIsGamepadKey(key)
end
---@return boolean
function M.IsItemActivated()
    return lib.igIsItemActivated()
end
---@return boolean
function M.IsItemActive()
    return lib.igIsItemActive()
end
---@param mouse_button number?
---@return boolean
function M.IsItemClicked(mouse_button)
    mouse_button = mouse_button or 0
    return lib.igIsItemClicked(mouse_button)
end
---@return boolean
function M.IsItemDeactivated()
    return lib.igIsItemDeactivated()
end
---@return boolean
function M.IsItemDeactivatedAfterEdit()
    return lib.igIsItemDeactivatedAfterEdit()
end
---@return boolean
function M.IsItemEdited()
    return lib.igIsItemEdited()
end
---@return boolean
function M.IsItemFocused()
    return lib.igIsItemFocused()
end
---@param flags number?
---@return boolean
function M.IsItemHovered(flags)
    flags = flags or 0
    return lib.igIsItemHovered(flags)
end
---@return boolean
function M.IsItemToggledOpen()
    return lib.igIsItemToggledOpen()
end
---@return boolean
function M.IsItemToggledSelection()
    return lib.igIsItemToggledSelection()
end
---@return boolean
function M.IsItemVisible()
    return lib.igIsItemVisible()
end
---@param key Key
---@return boolean
function M.IsKeyDown_Nil(key)
    return lib.igIsKeyDown_Nil(key)
end
---@param key Key
---@param owner_id number
---@return boolean
function M.IsKeyDown_ID(key,owner_id)
    return lib.igIsKeyDown_ID(key,owner_id)
end
function M.IsKeyDown(a1,a2) -- generic version
    if a2==nil then return M.IsKeyDown_Nil(a1) end
    if ffi.istype('ImGuiID',a2) then return M.IsKeyDown_ID(a1,a2) end
    print(a1,a2)
    error'M.IsKeyDown could not find overloaded'
end
---@param key Key
---@param _repeat boolean?
---@return boolean
function M.IsKeyPressed_Bool(key,_repeat)
    if _repeat == nil then _repeat = true end
    return lib.igIsKeyPressed_Bool(key,_repeat)
end
---@param key Key
---@param owner_id number
---@param flags number?
---@return boolean
function M.IsKeyPressed_ID(key,owner_id,flags)
    flags = flags or 0
    return lib.igIsKeyPressed_ID(key,owner_id,flags)
end
function M.IsKeyPressed(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.IsKeyPressed_Bool(a1,a2) end
    if ffi.istype('ImGuiID',a2) then return M.IsKeyPressed_ID(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.IsKeyPressed could not find overloaded'
end
---@param key Key
---@param _repeat boolean?
---@return boolean
function M.IsKeyPressedMap(key,_repeat)
    if _repeat == nil then _repeat = true end
    return lib.igIsKeyPressedMap(key,_repeat)
end
---@param key Key
---@return boolean
function M.IsKeyReleased_Nil(key)
    return lib.igIsKeyReleased_Nil(key)
end
---@param key Key
---@param owner_id number
---@return boolean
function M.IsKeyReleased_ID(key,owner_id)
    return lib.igIsKeyReleased_ID(key,owner_id)
end
function M.IsKeyReleased(a1,a2) -- generic version
    if a2==nil then return M.IsKeyReleased_Nil(a1) end
    if ffi.istype('ImGuiID',a2) then return M.IsKeyReleased_ID(a1,a2) end
    print(a1,a2)
    error'M.IsKeyReleased could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsKeyboardKey(key)
    return lib.igIsKeyboardKey(key)
end
---@param key Key
---@return boolean
function M.IsLegacyKey(key)
    return lib.igIsLegacyKey(key)
end
---@param button number
---@param _repeat boolean?
---@return boolean
function M.IsMouseClicked_Bool(button,_repeat)
    _repeat = _repeat or false
    return lib.igIsMouseClicked_Bool(button,_repeat)
end
---@param button number
---@param owner_id number
---@param flags number?
---@return boolean
function M.IsMouseClicked_ID(button,owner_id,flags)
    flags = flags or 0
    return lib.igIsMouseClicked_ID(button,owner_id,flags)
end
function M.IsMouseClicked(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.IsMouseClicked_Bool(a1,a2) end
    if ffi.istype('ImGuiID',a2) then return M.IsMouseClicked_ID(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.IsMouseClicked could not find overloaded'
end
---@param button number
---@return boolean
function M.IsMouseDoubleClicked(button)
    return lib.igIsMouseDoubleClicked(button)
end
---@param button number
---@return boolean
function M.IsMouseDown_Nil(button)
    return lib.igIsMouseDown_Nil(button)
end
---@param button number
---@param owner_id number
---@return boolean
function M.IsMouseDown_ID(button,owner_id)
    return lib.igIsMouseDown_ID(button,owner_id)
end
function M.IsMouseDown(a1,a2) -- generic version
    if a2==nil then return M.IsMouseDown_Nil(a1) end
    if ffi.istype('ImGuiID',a2) then return M.IsMouseDown_ID(a1,a2) end
    print(a1,a2)
    error'M.IsMouseDown could not find overloaded'
end
---@param button number
---@param lock_threshold number?
---@return boolean
function M.IsMouseDragPastThreshold(button,lock_threshold)
    lock_threshold = lock_threshold or -1.0
    return lib.igIsMouseDragPastThreshold(button,lock_threshold)
end
---@param button number
---@param lock_threshold number?
---@return boolean
function M.IsMouseDragging(button,lock_threshold)
    lock_threshold = lock_threshold or -1.0
    return lib.igIsMouseDragging(button,lock_threshold)
end
---@param r_min ImVec2
---@param r_max ImVec2
---@param clip boolean?
---@return boolean
function M.IsMouseHoveringRect(r_min,r_max,clip)
    if clip == nil then clip = true end
    return lib.igIsMouseHoveringRect(r_min,r_max,clip)
end
---@param key Key
---@return boolean
function M.IsMouseKey(key)
    return lib.igIsMouseKey(key)
end
---@param mouse_pos ffi.ct*? const ImVec2*
---@return boolean
function M.IsMousePosValid(mouse_pos)
    mouse_pos = mouse_pos or nil
    return lib.igIsMousePosValid(mouse_pos)
end
---@param button number
---@return boolean
function M.IsMouseReleased_Nil(button)
    return lib.igIsMouseReleased_Nil(button)
end
---@param button number
---@param owner_id number
---@return boolean
function M.IsMouseReleased_ID(button,owner_id)
    return lib.igIsMouseReleased_ID(button,owner_id)
end
function M.IsMouseReleased(a1,a2) -- generic version
    if a2==nil then return M.IsMouseReleased_Nil(a1) end
    if ffi.istype('ImGuiID',a2) then return M.IsMouseReleased_ID(a1,a2) end
    print(a1,a2)
    error'M.IsMouseReleased could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsNamedKey(key)
    return lib.igIsNamedKey(key)
end
---@param key Key
---@return boolean
function M.IsNamedKeyOrModKey(key)
    return lib.igIsNamedKeyOrModKey(key)
end
---@param str_id string
---@param flags number?
---@return boolean
function M.IsPopupOpen_Str(str_id,flags)
    flags = flags or 0
    return lib.igIsPopupOpen_Str(str_id,flags)
end
---@param id number
---@param popup_flags number
---@return boolean
function M.IsPopupOpen_ID(id,popup_flags)
    return lib.igIsPopupOpen_ID(id,popup_flags)
end
function M.IsPopupOpen(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.IsPopupOpen_Str(a1,a2) end
    if ffi.istype('ImGuiID',a1) then return M.IsPopupOpen_ID(a1,a2) end
    print(a1,a2)
    error'M.IsPopupOpen could not find overloaded'
end
---@param size ImVec2
---@return boolean
function M.IsRectVisible_Nil(size)
    return lib.igIsRectVisible_Nil(size)
end
---@param rect_min ImVec2
---@param rect_max ImVec2
---@return boolean
function M.IsRectVisible_Vec2(rect_min,rect_max)
    return lib.igIsRectVisible_Vec2(rect_min,rect_max)
end
function M.IsRectVisible(a1,a2) -- generic version
    if a2==nil then return M.IsRectVisible_Nil(a1) end
    if ffi.istype('const ImVec2',a2) then return M.IsRectVisible_Vec2(a1,a2) end
    print(a1,a2)
    error'M.IsRectVisible could not find overloaded'
end
---@param potential_above ffi.ct* ImGuiWindow*
---@param potential_below ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowAbove(potential_above,potential_below)
    return lib.igIsWindowAbove(potential_above,potential_below)
end
---@return boolean
function M.IsWindowAppearing()
    return lib.igIsWindowAppearing()
end
---@param window ffi.ct* ImGuiWindow*
---@param potential_parent ffi.ct* ImGuiWindow*
---@param popup_hierarchy boolean
---@return boolean
function M.IsWindowChildOf(window,potential_parent,popup_hierarchy)
    return lib.igIsWindowChildOf(window,potential_parent,popup_hierarchy)
end
---@return boolean
function M.IsWindowCollapsed()
    return lib.igIsWindowCollapsed()
end
---@param flags number?
---@return boolean
function M.IsWindowFocused(flags)
    flags = flags or 0
    return lib.igIsWindowFocused(flags)
end
---@param flags number?
---@return boolean
function M.IsWindowHovered(flags)
    flags = flags or 0
    return lib.igIsWindowHovered(flags)
end
---@param window ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowNavFocusable(window)
    return lib.igIsWindowNavFocusable(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param potential_parent ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowWithinBeginStackOf(window,potential_parent)
    return lib.igIsWindowWithinBeginStackOf(window,potential_parent)
end
---@param bb ImRect
---@param id number
---@param nav_bb ffi.ct*? const ImRect*
---@param extra_flags number?
---@return boolean
function M.ItemAdd(bb,id,nav_bb,extra_flags)
    extra_flags = extra_flags or 0
    nav_bb = nav_bb or nil
    return lib.igItemAdd(bb,id,nav_bb,extra_flags)
end
---@param bb ImRect
---@param id number
---@return boolean
function M.ItemHoverable(bb,id)
    return lib.igItemHoverable(bb,id)
end
---@param size ImVec2
---@param text_baseline_y number?
---@return nil
function M.ItemSize_Vec2(size,text_baseline_y)
    text_baseline_y = text_baseline_y or -1.0
    return lib.igItemSize_Vec2(size,text_baseline_y)
end
---@param bb ImRect
---@param text_baseline_y number?
---@return nil
function M.ItemSize_Rect(bb,text_baseline_y)
    text_baseline_y = text_baseline_y or -1.0
    return lib.igItemSize_Rect(bb,text_baseline_y)
end
function M.ItemSize(a1,a2) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.ItemSize_Vec2(a1,a2) end
    if ffi.istype('const ImRect',a1) then return M.ItemSize_Rect(a1,a2) end
    print(a1,a2)
    error'M.ItemSize could not find overloaded'
end
---@param id number
---@return nil
function M.KeepAliveID(id)
    return lib.igKeepAliveID(id)
end
---@param label string
---@param fmt string
---@return nil
function M.LabelText(label,fmt,...)
    return lib.igLabelText(label,fmt,...)
end
---@param label string
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.LabelTextV(label,fmt,args)
    return lib.igLabelTextV(label,fmt,args)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items ffi.ct* const char* const[]
---@param items_count number
---@param height_in_items number?
---@return boolean
function M.ListBox_Str_arr(label,current_item,items,items_count,height_in_items)
    height_in_items = height_in_items or -1
    return lib.igListBox_Str_arr(label,current_item,items,items_count,height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items_getter ffi.ct* bool(*)(void* data,int idx,const char** out_text)
---@param data ffi.ct* void*
---@param items_count number
---@param height_in_items number?
---@return boolean
function M.ListBox_FnBoolPtr(label,current_item,items_getter,data,items_count,height_in_items)
    height_in_items = height_in_items or -1
    return lib.igListBox_FnBoolPtr(label,current_item,items_getter,data,items_count,height_in_items)
end
function M.ListBox(a1,a2,a3,a4,a5,a6) -- generic version
    if (ffi.istype('const char* const[]',a3) or ffi.istype('const char const[]',a3) or ffi.istype('const char const[][]',a3)) then return M.ListBox_Str_arr(a1,a2,a3,a4,a5) end
    if ffi.istype('bool(*)(void* data,int idx,const char** out_text)',a3) then return M.ListBox_FnBoolPtr(a1,a2,a3,a4,a5,a6) end
    print(a1,a2,a3,a4,a5,a6)
    error'M.ListBox could not find overloaded'
end
---@param ini_filename string
---@return nil
function M.LoadIniSettingsFromDisk(ini_filename)
    return lib.igLoadIniSettingsFromDisk(ini_filename)
end
---@param ini_data string
---@param ini_size number?
---@return nil
function M.LoadIniSettingsFromMemory(ini_data,ini_size)
    ini_size = ini_size or 0
    return lib.igLoadIniSettingsFromMemory(ini_data,ini_size)
end
---@param key LocKey
---@return string
function M.LocalizeGetMsg(key)
    return ffi.string(lib.igLocalizeGetMsg(key))
end
---@param entries ffi.ct* const ImGuiLocEntry*
---@param count number
---@return nil
function M.LocalizeRegisterEntries(entries,count)
    return lib.igLocalizeRegisterEntries(entries,count)
end
---@param type LogType
---@param auto_open_depth number
---@return nil
function M.LogBegin(type,auto_open_depth)
    return lib.igLogBegin(type,auto_open_depth)
end
---@return nil
function M.LogButtons()
    return lib.igLogButtons()
end
---@return nil
function M.LogFinish()
    return lib.igLogFinish()
end
---@param ref_pos ffi.ct* const ImVec2*
---@param text string
---@param text_end string?
---@return nil
function M.LogRenderedText(ref_pos,text,text_end)
    text_end = text_end or nil
    return lib.igLogRenderedText(ref_pos,text,text_end)
end
---@param prefix string
---@param suffix string
---@return nil
function M.LogSetNextTextDecoration(prefix,suffix)
    return lib.igLogSetNextTextDecoration(prefix,suffix)
end
---@param fmt string
---@return nil
function M.LogText(fmt,...)
    return lib.igLogText(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.LogTextV(fmt,args)
    return lib.igLogTextV(fmt,args)
end
---@param auto_open_depth number?
---@return nil
function M.LogToBuffer(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToBuffer(auto_open_depth)
end
---@param auto_open_depth number?
---@return nil
function M.LogToClipboard(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToClipboard(auto_open_depth)
end
---@param auto_open_depth number?
---@param filename string?
---@return nil
function M.LogToFile(auto_open_depth,filename)
    auto_open_depth = auto_open_depth or -1
    filename = filename or nil
    return lib.igLogToFile(auto_open_depth,filename)
end
---@param auto_open_depth number?
---@return nil
function M.LogToTTY(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToTTY(auto_open_depth)
end
---@return nil
function M.MarkIniSettingsDirty_Nil()
    return lib.igMarkIniSettingsDirty_Nil()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.MarkIniSettingsDirty_WindowPtr(window)
    return lib.igMarkIniSettingsDirty_WindowPtr(window)
end
function M.MarkIniSettingsDirty(a1) -- generic version
    if a1==nil then return M.MarkIniSettingsDirty_Nil() end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.MarkIniSettingsDirty_WindowPtr(a1) end
    print(a1)
    error'M.MarkIniSettingsDirty could not find overloaded'
end
---@param id number
---@return nil
function M.MarkItemEdited(id)
    return lib.igMarkItemEdited(id)
end
---@param size number
---@return ffi.ct* void*
function M.MemAlloc(size)
    return lib.igMemAlloc(size)
end
---@param ptr ffi.ct* void*
---@return nil
function M.MemFree(ptr)
    return lib.igMemFree(ptr)
end
---@param label string
---@param shortcut string?
---@param selected boolean?
---@param enabled boolean?
---@return boolean
function M.MenuItem_Bool(label,shortcut,selected,enabled)
    if enabled == nil then enabled = true end
    selected = selected or false
    shortcut = shortcut or nil
    return lib.igMenuItem_Bool(label,shortcut,selected,enabled)
end
---@param label string
---@param shortcut string
---@param p_selected ffi.ct* bool*
---@param enabled boolean?
---@return boolean
function M.MenuItem_BoolPtr(label,shortcut,p_selected,enabled)
    if enabled == nil then enabled = true end
    return lib.igMenuItem_BoolPtr(label,shortcut,p_selected,enabled)
end
function M.MenuItem(a1,a2,a3,a4) -- generic version
    if ((ffi.istype('bool',a3) or type(a3)=='boolean') or type(a3)=='nil') then return M.MenuItem_Bool(a1,a2,a3,a4) end
    if (ffi.istype('bool*',a3) or ffi.istype('bool',a3) or ffi.istype('bool[]',a3)) then return M.MenuItem_BoolPtr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.MenuItem could not find overloaded'
end
---@param label string
---@param icon string
---@param shortcut string?
---@param selected boolean?
---@param enabled boolean?
---@return boolean
function M.MenuItemEx(label,icon,shortcut,selected,enabled)
    if enabled == nil then enabled = true end
    selected = selected or false
    shortcut = shortcut or nil
    return lib.igMenuItemEx(label,icon,shortcut,selected,enabled)
end
---@param button number
---@return Key
function M.MouseButtonToKey(button)
    return lib.igMouseButtonToKey(button)
end
---@return nil
function M.NavInitRequestApplyResult()
    return lib.igNavInitRequestApplyResult()
end
---@param window ffi.ct* ImGuiWindow*
---@param force_reinit boolean
---@return nil
function M.NavInitWindow(window,force_reinit)
    return lib.igNavInitWindow(window,force_reinit)
end
---@return nil
function M.NavMoveRequestApplyResult()
    return lib.igNavMoveRequestApplyResult()
end
---@return boolean
function M.NavMoveRequestButNoResultYet()
    return lib.igNavMoveRequestButNoResultYet()
end
---@return nil
function M.NavMoveRequestCancel()
    return lib.igNavMoveRequestCancel()
end
---@param move_dir number
---@param clip_dir number
---@param move_flags number
---@param scroll_flags number
---@return nil
function M.NavMoveRequestForward(move_dir,clip_dir,move_flags,scroll_flags)
    return lib.igNavMoveRequestForward(move_dir,clip_dir,move_flags,scroll_flags)
end
---@param result ffi.ct* ImGuiNavItemData*
---@return nil
function M.NavMoveRequestResolveWithLastItem(result)
    return lib.igNavMoveRequestResolveWithLastItem(result)
end
---@param move_dir number
---@param clip_dir number
---@param move_flags number
---@param scroll_flags number
---@return nil
function M.NavMoveRequestSubmit(move_dir,clip_dir,move_flags,scroll_flags)
    return lib.igNavMoveRequestSubmit(move_dir,clip_dir,move_flags,scroll_flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param move_flags number
---@return nil
function M.NavMoveRequestTryWrapping(window,move_flags)
    return lib.igNavMoveRequestTryWrapping(window,move_flags)
end
---@return nil
function M.NewFrame()
    return lib.igNewFrame()
end
---@return nil
function M.NewLine()
    return lib.igNewLine()
end
---@return nil
function M.NextColumn()
    return lib.igNextColumn()
end
---@param str_id string
---@param popup_flags number?
---@return nil
function M.OpenPopup_Str(str_id,popup_flags)
    popup_flags = popup_flags or 0
    return lib.igOpenPopup_Str(str_id,popup_flags)
end
---@param id number
---@param popup_flags number?
---@return nil
function M.OpenPopup_ID(id,popup_flags)
    popup_flags = popup_flags or 0
    return lib.igOpenPopup_ID(id,popup_flags)
end
function M.OpenPopup(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.OpenPopup_Str(a1,a2) end
    if ffi.istype('ImGuiID',a1) then return M.OpenPopup_ID(a1,a2) end
    print(a1,a2)
    error'M.OpenPopup could not find overloaded'
end
---@param id number
---@param popup_flags number?
---@return nil
function M.OpenPopupEx(id,popup_flags)
    popup_flags = popup_flags or M.PopupFlags.None
    return lib.igOpenPopupEx(id,popup_flags)
end
---@param str_id string?
---@param popup_flags number?
---@return nil
function M.OpenPopupOnItemClick(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igOpenPopupOnItemClick(str_id,popup_flags)
end
---@param plot_type PlotType
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number
---@param values_offset number
---@param overlay_text string
---@param scale_min number
---@param scale_max number
---@param size_arg ImVec2
---@return number
function M.PlotEx(plot_type,label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,size_arg)
    return lib.igPlotEx(plot_type,label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,size_arg)
end
---@param label string
---@param values ffi.ct* const float*
---@param values_count number
---@param values_offset number?
---@param overlay_text string?
---@param scale_min number?
---@param scale_max number?
---@param graph_size ImVec2?
---@param stride number?
---@return nil
function M.PlotHistogram_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    stride = stride or ffi.sizeof("float")
    values_offset = values_offset or 0
    return lib.igPlotHistogram_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
end
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number
---@param values_offset number?
---@param overlay_text string?
---@param scale_min number?
---@param scale_max number?
---@param graph_size ImVec2?
---@return nil
function M.PlotHistogram_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    values_offset = values_offset or 0
    return lib.igPlotHistogram_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
end
function M.PlotHistogram(a1,a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if (ffi.istype('const float*',a2) or ffi.istype('float[]',a2)) then return M.PlotHistogram_FloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    if ffi.istype('float(*)(void* data,int idx)',a2) then return M.PlotHistogram_FnFloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a1,a2,a3,a4,a5,a6,a7,a8,a9)
    error'M.PlotHistogram could not find overloaded'
end
---@param label string
---@param values ffi.ct* const float*
---@param values_count number
---@param values_offset number?
---@param overlay_text string?
---@param scale_min number?
---@param scale_max number?
---@param graph_size ImVec2?
---@param stride number?
---@return nil
function M.PlotLines_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    stride = stride or ffi.sizeof("float")
    values_offset = values_offset or 0
    return lib.igPlotLines_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
end
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number
---@param values_offset number?
---@param overlay_text string?
---@param scale_min number?
---@param scale_max number?
---@param graph_size ImVec2?
---@return nil
function M.PlotLines_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    values_offset = values_offset or 0
    return lib.igPlotLines_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
end
function M.PlotLines(a1,a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if (ffi.istype('const float*',a2) or ffi.istype('float[]',a2)) then return M.PlotLines_FloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    if ffi.istype('float(*)(void* data,int idx)',a2) then return M.PlotLines_FnFloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a1,a2,a3,a4,a5,a6,a7,a8,a9)
    error'M.PlotLines could not find overloaded'
end
---@return nil
function M.PopAllowKeyboardFocus()
    return lib.igPopAllowKeyboardFocus()
end
---@return nil
function M.PopButtonRepeat()
    return lib.igPopButtonRepeat()
end
---@return nil
function M.PopClipRect()
    return lib.igPopClipRect()
end
---@return nil
function M.PopColumnsBackground()
    return lib.igPopColumnsBackground()
end
---@return nil
function M.PopFocusScope()
    return lib.igPopFocusScope()
end
---@return nil
function M.PopFont()
    return lib.igPopFont()
end
---@return nil
function M.PopID()
    return lib.igPopID()
end
---@return nil
function M.PopItemFlag()
    return lib.igPopItemFlag()
end
---@return nil
function M.PopItemWidth()
    return lib.igPopItemWidth()
end
---@param count number?
---@return nil
function M.PopStyleColor(count)
    count = count or 1
    return lib.igPopStyleColor(count)
end
---@param count number?
---@return nil
function M.PopStyleVar(count)
    count = count or 1
    return lib.igPopStyleVar(count)
end
---@return nil
function M.PopTextWrapPos()
    return lib.igPopTextWrapPos()
end
---@param fraction number
---@param size_arg ImVec2?
---@param overlay string?
---@return nil
function M.ProgressBar(fraction,size_arg,overlay)
    overlay = overlay or nil
    size_arg = size_arg or ImVec2(-M.FLT_MIN,0)
    return lib.igProgressBar(fraction,size_arg,overlay)
end
---@param allow_keyboard_focus boolean
---@return nil
function M.PushAllowKeyboardFocus(allow_keyboard_focus)
    return lib.igPushAllowKeyboardFocus(allow_keyboard_focus)
end
---@param _repeat boolean
---@return nil
function M.PushButtonRepeat(_repeat)
    return lib.igPushButtonRepeat(_repeat)
end
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect boolean
---@return nil
function M.PushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
    return lib.igPushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
end
---@param column_index number
---@return nil
function M.PushColumnClipRect(column_index)
    return lib.igPushColumnClipRect(column_index)
end
---@return nil
function M.PushColumnsBackground()
    return lib.igPushColumnsBackground()
end
---@param id number
---@return nil
function M.PushFocusScope(id)
    return lib.igPushFocusScope(id)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.PushFont(font)
    return lib.igPushFont(font)
end
---@param str_id string
---@return nil
function M.PushID_Str(str_id)
    return lib.igPushID_Str(str_id)
end
---@param str_id_begin string
---@param str_id_end string
---@return nil
function M.PushID_StrStr(str_id_begin,str_id_end)
    return lib.igPushID_StrStr(str_id_begin,str_id_end)
end
---@param ptr_id ffi.ct* const void*
---@return nil
function M.PushID_Ptr(ptr_id)
    return lib.igPushID_Ptr(ptr_id)
end
---@param int_id number
---@return nil
function M.PushID_Int(int_id)
    return lib.igPushID_Int(int_id)
end
function M.PushID(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.PushID_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.PushID_StrStr(a1,a2) end
    if ffi.istype('const void*',a1) then return M.PushID_Ptr(a1) end
    if (ffi.istype('int',a1) or type(a1)=='number') then return M.PushID_Int(a1) end
    print(a1,a2)
    error'M.PushID could not find overloaded'
end
---@param option number
---@param enabled boolean
---@return nil
function M.PushItemFlag(option,enabled)
    return lib.igPushItemFlag(option,enabled)
end
---@param item_width number
---@return nil
function M.PushItemWidth(item_width)
    return lib.igPushItemWidth(item_width)
end
---@param components number
---@param width_full number
---@return nil
function M.PushMultiItemsWidths(components,width_full)
    return lib.igPushMultiItemsWidths(components,width_full)
end
---@param id number
---@return nil
function M.PushOverrideID(id)
    return lib.igPushOverrideID(id)
end
---@param idx number
---@param col number
---@return nil
function M.PushStyleColor_U32(idx,col)
    return lib.igPushStyleColor_U32(idx,col)
end
---@param idx number
---@param col ffi.ct* const ImVec4
---@return nil
function M.PushStyleColor_Vec4(idx,col)
    return lib.igPushStyleColor_Vec4(idx,col)
end
function M.PushStyleColor(a1,a2) -- generic version
    if (ffi.istype('ImU32',a2) or type(a2)=='number') then return M.PushStyleColor_U32(a1,a2) end
    if ffi.istype('const ImVec4',a2) then return M.PushStyleColor_Vec4(a1,a2) end
    print(a1,a2)
    error'M.PushStyleColor could not find overloaded'
end
---@param idx number
---@param val number
---@return nil
function M.PushStyleVar_Float(idx,val)
    return lib.igPushStyleVar_Float(idx,val)
end
---@param idx number
---@param val ImVec2
---@return nil
function M.PushStyleVar_Vec2(idx,val)
    return lib.igPushStyleVar_Vec2(idx,val)
end
function M.PushStyleVar(a1,a2) -- generic version
    if (ffi.istype('float',a2) or type(a2)=='number') then return M.PushStyleVar_Float(a1,a2) end
    if ffi.istype('const ImVec2',a2) then return M.PushStyleVar_Vec2(a1,a2) end
    print(a1,a2)
    error'M.PushStyleVar could not find overloaded'
end
---@param wrap_local_pos_x number?
---@return nil
function M.PushTextWrapPos(wrap_local_pos_x)
    wrap_local_pos_x = wrap_local_pos_x or 0.0
    return lib.igPushTextWrapPos(wrap_local_pos_x)
end
---@param label string
---@param active boolean
---@return boolean
function M.RadioButton_Bool(label,active)
    return lib.igRadioButton_Bool(label,active)
end
---@param label string
---@param v ffi.ct* int*
---@param v_button number
---@return boolean
function M.RadioButton_IntPtr(label,v,v_button)
    return lib.igRadioButton_IntPtr(label,v,v_button)
end
function M.RadioButton(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.RadioButton_Bool(a1,a2) end
    if (ffi.istype('int*',a2) or ffi.istype('int[]',a2)) then return M.RadioButton_IntPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.RadioButton could not find overloaded'
end
---@param context ffi.ct* ImGuiContext*
---@param hook_to_remove number
---@return nil
function M.RemoveContextHook(context,hook_to_remove)
    return lib.igRemoveContextHook(context,hook_to_remove)
end
---@param type_name string
---@return nil
function M.RemoveSettingsHandler(type_name)
    return lib.igRemoveSettingsHandler(type_name)
end
---@return nil
function M.Render()
    return lib.igRender()
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number
---@param dir number
---@param scale number?
---@return nil
function M.RenderArrow(draw_list,pos,col,dir,scale)
    scale = scale or 1.0
    return lib.igRenderArrow(draw_list,pos,col,dir,scale)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param half_sz ImVec2
---@param direction number
---@param col number
---@return nil
function M.RenderArrowPointingAt(draw_list,pos,half_sz,direction,col)
    return lib.igRenderArrowPointingAt(draw_list,pos,half_sz,direction,col)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number
---@return nil
function M.RenderBullet(draw_list,pos,col)
    return lib.igRenderBullet(draw_list,pos,col)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number
---@param sz number
---@return nil
function M.RenderCheckMark(draw_list,pos,col,sz)
    return lib.igRenderCheckMark(draw_list,pos,col,sz)
end
---@param draw_list ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param fill_col number
---@param grid_step number
---@param grid_off ImVec2
---@param rounding number?
---@param flags number?
---@return nil
function M.RenderColorRectWithAlphaCheckerboard(draw_list,p_min,p_max,fill_col,grid_step,grid_off,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.igRenderColorRectWithAlphaCheckerboard(draw_list,p_min,p_max,fill_col,grid_step,grid_off,rounding,flags)
end
---@param bb ImRect
---@return nil
function M.RenderDragDropTargetRect(bb)
    return lib.igRenderDragDropTargetRect(bb)
end
---@param p_min ImVec2
---@param p_max ImVec2
---@param fill_col number
---@param border boolean?
---@param rounding number?
---@return nil
function M.RenderFrame(p_min,p_max,fill_col,border,rounding)
    if border == nil then border = true end
    rounding = rounding or 0.0
    return lib.igRenderFrame(p_min,p_max,fill_col,border,rounding)
end
---@param p_min ImVec2
---@param p_max ImVec2
---@param rounding number?
---@return nil
function M.RenderFrameBorder(p_min,p_max,rounding)
    rounding = rounding or 0.0
    return lib.igRenderFrameBorder(p_min,p_max,rounding)
end
---@param pos ImVec2
---@param scale number
---@param mouse_cursor number
---@param col_fill number
---@param col_border number
---@param col_shadow number
---@return nil
function M.RenderMouseCursor(pos,scale,mouse_cursor,col_fill,col_border,col_shadow)
    return lib.igRenderMouseCursor(pos,scale,mouse_cursor,col_fill,col_border,col_shadow)
end
---@param bb ImRect
---@param id number
---@param flags number?
---@return nil
function M.RenderNavHighlight(bb,id,flags)
    flags = flags or M.NavHighlightFlags.TypeDefault
    return lib.igRenderNavHighlight(bb,id,flags)
end
---@param draw_list ffi.ct* ImDrawList*
---@param rect ImRect
---@param col number
---@param x_start_norm number
---@param x_end_norm number
---@param rounding number
---@return nil
function M.RenderRectFilledRangeH(draw_list,rect,col,x_start_norm,x_end_norm,rounding)
    return lib.igRenderRectFilledRangeH(draw_list,rect,col,x_start_norm,x_end_norm,rounding)
end
---@param draw_list ffi.ct* ImDrawList*
---@param outer ImRect
---@param inner ImRect
---@param col number
---@param rounding number
---@return nil
function M.RenderRectFilledWithHole(draw_list,outer,inner,col,rounding)
    return lib.igRenderRectFilledWithHole(draw_list,outer,inner,col,rounding)
end
---@param pos ImVec2
---@param text string
---@param text_end string?
---@param hide_text_after_hash boolean?
---@return nil
function M.RenderText(pos,text,text_end,hide_text_after_hash)
    if hide_text_after_hash == nil then hide_text_after_hash = true end
    text_end = text_end or nil
    return lib.igRenderText(pos,text,text_end,hide_text_after_hash)
end
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@param align ImVec2?
---@param clip_rect ffi.ct*? const ImRect*
---@return nil
function M.RenderTextClipped(pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
    align = align or ImVec2(0,0)
    clip_rect = clip_rect or nil
    return lib.igRenderTextClipped(pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@param align ImVec2?
---@param clip_rect ffi.ct*? const ImRect*
---@return nil
function M.RenderTextClippedEx(draw_list,pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
    align = align or ImVec2(0,0)
    clip_rect = clip_rect or nil
    return lib.igRenderTextClippedEx(draw_list,pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param clip_max_x number
---@param ellipsis_max_x number
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@return nil
function M.RenderTextEllipsis(draw_list,pos_min,pos_max,clip_max_x,ellipsis_max_x,text,text_end,text_size_if_known)
    return lib.igRenderTextEllipsis(draw_list,pos_min,pos_max,clip_max_x,ellipsis_max_x,text,text_end,text_size_if_known)
end
---@param pos ImVec2
---@param text string
---@param text_end string
---@param wrap_width number
---@return nil
function M.RenderTextWrapped(pos,text,text_end,wrap_width)
    return lib.igRenderTextWrapped(pos,text,text_end,wrap_width)
end
---@param button number?
---@return nil
function M.ResetMouseDragDelta(button)
    button = button or 0
    return lib.igResetMouseDragDelta(button)
end
---@param offset_from_start_x number?
---@param spacing number?
---@return nil
function M.SameLine(offset_from_start_x,spacing)
    offset_from_start_x = offset_from_start_x or 0.0
    spacing = spacing or -1.0
    return lib.igSameLine(offset_from_start_x,spacing)
end
---@param ini_filename string
---@return nil
function M.SaveIniSettingsToDisk(ini_filename)
    return lib.igSaveIniSettingsToDisk(ini_filename)
end
---@param out_ini_size ffi.ct*? size_t*
---@return string
function M.SaveIniSettingsToMemory(out_ini_size)
    out_ini_size = out_ini_size or nil
    return ffi.string(lib.igSaveIniSettingsToMemory(out_ini_size))
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@return nil
function M.ScrollToBringRectIntoView(window,rect)
    return lib.igScrollToBringRectIntoView(window,rect)
end
---@param flags number?
---@return nil
function M.ScrollToItem(flags)
    flags = flags or 0
    return lib.igScrollToItem(flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@param flags number?
---@return nil
function M.ScrollToRect(window,rect,flags)
    flags = flags or 0
    return lib.igScrollToRect(window,rect,flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@param flags number?
---@return nil
function M.ScrollToRectEx(window,rect,flags)
    flags = flags or 0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igScrollToRectEx(nonUDT_out,window,rect,flags)
    return nonUDT_out
end
---@param axis Axis
---@return nil
function M.Scrollbar(axis)
    return lib.igScrollbar(axis)
end
---@param bb ImRect
---@param id number
---@param axis Axis
---@param p_scroll_v ffi.ct* ImS64*
---@param avail_v number
---@param contents_v number
---@param flags number
---@return boolean
function M.ScrollbarEx(bb,id,axis,p_scroll_v,avail_v,contents_v,flags)
    return lib.igScrollbarEx(bb,id,axis,p_scroll_v,avail_v,contents_v,flags)
end
---@param label string
---@param selected boolean?
---@param flags number?
---@param size ImVec2?
---@return boolean
function M.Selectable_Bool(label,selected,flags,size)
    flags = flags or 0
    selected = selected or false
    size = size or ImVec2(0,0)
    return lib.igSelectable_Bool(label,selected,flags,size)
end
---@param label string
---@param p_selected ffi.ct* bool*
---@param flags number?
---@param size ImVec2?
---@return boolean
function M.Selectable_BoolPtr(label,p_selected,flags,size)
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igSelectable_BoolPtr(label,p_selected,flags,size)
end
function M.Selectable(a1,a2,a3,a4) -- generic version
    if ((ffi.istype('bool',a2) or type(a2)=='boolean') or type(a2)=='nil') then return M.Selectable_Bool(a1,a2,a3,a4) end
    if (ffi.istype('bool*',a2) or ffi.istype('bool',a2) or ffi.istype('bool[]',a2)) then return M.Selectable_BoolPtr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.Selectable could not find overloaded'
end
---@return nil
function M.Separator()
    return lib.igSeparator()
end
---@param flags number
---@return nil
function M.SeparatorEx(flags)
    return lib.igSeparatorEx(flags)
end
---@param label string
---@return nil
function M.SeparatorText(label)
    return lib.igSeparatorText(label)
end
---@param id number
---@param label string
---@param label_end string
---@param extra_width number
---@return nil
function M.SeparatorTextEx(id,label,label_end,extra_width)
    return lib.igSeparatorTextEx(id,label,label_end,extra_width)
end
---@param id number
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetActiveID(id,window)
    return lib.igSetActiveID(id,window)
end
---@return nil
function M.SetActiveIdUsingAllKeyboardKeys()
    return lib.igSetActiveIdUsingAllKeyboardKeys()
end
---@param alloc_func ffi.ct* ImGuiMemAllocFunc
---@param free_func ffi.ct* ImGuiMemFreeFunc
---@param user_data ffi.ct*? void*
---@return nil
function M.SetAllocatorFunctions(alloc_func,free_func,user_data)
    user_data = user_data or nil
    return lib.igSetAllocatorFunctions(alloc_func,free_func,user_data)
end
---@param text string
---@return nil
function M.SetClipboardText(text)
    return lib.igSetClipboardText(text)
end
---@param flags number
---@return nil
function M.SetColorEditOptions(flags)
    return lib.igSetColorEditOptions(flags)
end
---@param column_index number
---@param offset_x number
---@return nil
function M.SetColumnOffset(column_index,offset_x)
    return lib.igSetColumnOffset(column_index,offset_x)
end
---@param column_index number
---@param width number
---@return nil
function M.SetColumnWidth(column_index,width)
    return lib.igSetColumnWidth(column_index,width)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.SetCurrentContext(ctx)
    return lib.igSetCurrentContext(ctx)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.SetCurrentFont(font)
    return lib.igSetCurrentFont(font)
end
---@param local_pos ImVec2
---@return nil
function M.SetCursorPos(local_pos)
    return lib.igSetCursorPos(local_pos)
end
---@param local_x number
---@return nil
function M.SetCursorPosX(local_x)
    return lib.igSetCursorPosX(local_x)
end
---@param local_y number
---@return nil
function M.SetCursorPosY(local_y)
    return lib.igSetCursorPosY(local_y)
end
---@param pos ImVec2
---@return nil
function M.SetCursorScreenPos(pos)
    return lib.igSetCursorScreenPos(pos)
end
---@param type string
---@param data ffi.ct* const void*
---@param sz number
---@param cond number?
---@return boolean
function M.SetDragDropPayload(type,data,sz,cond)
    cond = cond or 0
    return lib.igSetDragDropPayload(type,data,sz,cond)
end
---@param id number
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetFocusID(id,window)
    return lib.igSetFocusID(id,window)
end
---@param id number
---@return nil
function M.SetHoveredID(id)
    return lib.igSetHoveredID(id)
end
---@return nil
function M.SetItemAllowOverlap()
    return lib.igSetItemAllowOverlap()
end
---@return nil
function M.SetItemDefaultFocus()
    return lib.igSetItemDefaultFocus()
end
---@param key Key
---@param flags number?
---@return nil
function M.SetItemKeyOwner(key,flags)
    flags = flags or 0
    return lib.igSetItemKeyOwner(key,flags)
end
---@param key Key
---@param owner_id number
---@param flags number?
---@return nil
function M.SetKeyOwner(key,owner_id,flags)
    flags = flags or 0
    return lib.igSetKeyOwner(key,owner_id,flags)
end
---@param offset number?
---@return nil
function M.SetKeyboardFocusHere(offset)
    offset = offset or 0
    return lib.igSetKeyboardFocusHere(offset)
end
---@param item_id number
---@param in_flags number
---@param status_flags number
---@param item_rect ImRect
---@return nil
function M.SetLastItemData(item_id,in_flags,status_flags,item_rect)
    return lib.igSetLastItemData(item_id,in_flags,status_flags,item_rect)
end
---@param cursor_type number
---@return nil
function M.SetMouseCursor(cursor_type)
    return lib.igSetMouseCursor(cursor_type)
end
---@param id number
---@param nav_layer NavLayer
---@param focus_scope_id number
---@param rect_rel ImRect
---@return nil
function M.SetNavID(id,nav_layer,focus_scope_id,rect_rel)
    return lib.igSetNavID(id,nav_layer,focus_scope_id,rect_rel)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetNavWindow(window)
    return lib.igSetNavWindow(window)
end
---@param want_capture_keyboard boolean
---@return nil
function M.SetNextFrameWantCaptureKeyboard(want_capture_keyboard)
    return lib.igSetNextFrameWantCaptureKeyboard(want_capture_keyboard)
end
---@param want_capture_mouse boolean
---@return nil
function M.SetNextFrameWantCaptureMouse(want_capture_mouse)
    return lib.igSetNextFrameWantCaptureMouse(want_capture_mouse)
end
---@param is_open boolean
---@param cond number?
---@return nil
function M.SetNextItemOpen(is_open,cond)
    cond = cond or 0
    return lib.igSetNextItemOpen(is_open,cond)
end
---@param item_width number
---@return nil
function M.SetNextItemWidth(item_width)
    return lib.igSetNextItemWidth(item_width)
end
---@param alpha number
---@return nil
function M.SetNextWindowBgAlpha(alpha)
    return lib.igSetNextWindowBgAlpha(alpha)
end
---@param collapsed boolean
---@param cond number?
---@return nil
function M.SetNextWindowCollapsed(collapsed,cond)
    cond = cond or 0
    return lib.igSetNextWindowCollapsed(collapsed,cond)
end
---@param size ImVec2
---@return nil
function M.SetNextWindowContentSize(size)
    return lib.igSetNextWindowContentSize(size)
end
---@return nil
function M.SetNextWindowFocus()
    return lib.igSetNextWindowFocus()
end
---@param pos ImVec2
---@param cond number?
---@param pivot ImVec2?
---@return nil
function M.SetNextWindowPos(pos,cond,pivot)
    cond = cond or 0
    pivot = pivot or ImVec2(0,0)
    return lib.igSetNextWindowPos(pos,cond,pivot)
end
---@param scroll ImVec2
---@return nil
function M.SetNextWindowScroll(scroll)
    return lib.igSetNextWindowScroll(scroll)
end
---@param size ImVec2
---@param cond number?
---@return nil
function M.SetNextWindowSize(size,cond)
    cond = cond or 0
    return lib.igSetNextWindowSize(size,cond)
end
---@param size_min ImVec2
---@param size_max ImVec2
---@param custom_callback ffi.ct*? ImGuiSizeCallback
---@param custom_callback_data ffi.ct*? void*
---@return nil
function M.SetNextWindowSizeConstraints(size_min,size_max,custom_callback,custom_callback_data)
    custom_callback = custom_callback or nil
    custom_callback_data = custom_callback_data or nil
    return lib.igSetNextWindowSizeConstraints(size_min,size_max,custom_callback,custom_callback_data)
end
---@param local_x number
---@param center_x_ratio number?
---@return nil
function M.SetScrollFromPosX_Float(local_x,center_x_ratio)
    center_x_ratio = center_x_ratio or 0.5
    return lib.igSetScrollFromPosX_Float(local_x,center_x_ratio)
end
---@param window ffi.ct* ImGuiWindow*
---@param local_x number
---@param center_x_ratio number
---@return nil
function M.SetScrollFromPosX_WindowPtr(window,local_x,center_x_ratio)
    return lib.igSetScrollFromPosX_WindowPtr(window,local_x,center_x_ratio)
end
function M.SetScrollFromPosX(a1,a2,a3) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollFromPosX_Float(a1,a2) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollFromPosX_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetScrollFromPosX could not find overloaded'
end
---@param local_y number
---@param center_y_ratio number?
---@return nil
function M.SetScrollFromPosY_Float(local_y,center_y_ratio)
    center_y_ratio = center_y_ratio or 0.5
    return lib.igSetScrollFromPosY_Float(local_y,center_y_ratio)
end
---@param window ffi.ct* ImGuiWindow*
---@param local_y number
---@param center_y_ratio number
---@return nil
function M.SetScrollFromPosY_WindowPtr(window,local_y,center_y_ratio)
    return lib.igSetScrollFromPosY_WindowPtr(window,local_y,center_y_ratio)
end
function M.SetScrollFromPosY(a1,a2,a3) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollFromPosY_Float(a1,a2) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollFromPosY_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetScrollFromPosY could not find overloaded'
end
---@param center_x_ratio number?
---@return nil
function M.SetScrollHereX(center_x_ratio)
    center_x_ratio = center_x_ratio or 0.5
    return lib.igSetScrollHereX(center_x_ratio)
end
---@param center_y_ratio number?
---@return nil
function M.SetScrollHereY(center_y_ratio)
    center_y_ratio = center_y_ratio or 0.5
    return lib.igSetScrollHereY(center_y_ratio)
end
---@param scroll_x number
---@return nil
function M.SetScrollX_Float(scroll_x)
    return lib.igSetScrollX_Float(scroll_x)
end
---@param window ffi.ct* ImGuiWindow*
---@param scroll_x number
---@return nil
function M.SetScrollX_WindowPtr(window,scroll_x)
    return lib.igSetScrollX_WindowPtr(window,scroll_x)
end
function M.SetScrollX(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollX_Float(a1) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollX_WindowPtr(a1,a2) end
    print(a1,a2)
    error'M.SetScrollX could not find overloaded'
end
---@param scroll_y number
---@return nil
function M.SetScrollY_Float(scroll_y)
    return lib.igSetScrollY_Float(scroll_y)
end
---@param window ffi.ct* ImGuiWindow*
---@param scroll_y number
---@return nil
function M.SetScrollY_WindowPtr(window,scroll_y)
    return lib.igSetScrollY_WindowPtr(window,scroll_y)
end
function M.SetScrollY(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollY_Float(a1) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollY_WindowPtr(a1,a2) end
    print(a1,a2)
    error'M.SetScrollY could not find overloaded'
end
---@param key_chord number
---@param owner_id number?
---@param flags number?
---@return boolean
function M.SetShortcutRouting(key_chord,owner_id,flags)
    flags = flags or 0
    owner_id = owner_id or 0
    return lib.igSetShortcutRouting(key_chord,owner_id,flags)
end
---@param storage ffi.ct* ImGuiStorage*
---@return nil
function M.SetStateStorage(storage)
    return lib.igSetStateStorage(storage)
end
---@param tab_or_docked_window_label string
---@return nil
function M.SetTabItemClosed(tab_or_docked_window_label)
    return lib.igSetTabItemClosed(tab_or_docked_window_label)
end
---@param fmt string
---@return nil
function M.SetTooltip(fmt,...)
    return lib.igSetTooltip(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.SetTooltipV(fmt,args)
    return lib.igSetTooltipV(fmt,args)
end
---@param window ffi.ct* ImGuiWindow*
---@param clip_rect ImRect
---@return nil
function M.SetWindowClipRectBeforeSetChannel(window,clip_rect)
    return lib.igSetWindowClipRectBeforeSetChannel(window,clip_rect)
end
---@param collapsed boolean
---@param cond number?
---@return nil
function M.SetWindowCollapsed_Bool(collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_Bool(collapsed,cond)
end
---@param name string
---@param collapsed boolean
---@param cond number?
---@return nil
function M.SetWindowCollapsed_Str(name,collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_Str(name,collapsed,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param collapsed boolean
---@param cond number?
---@return nil
function M.SetWindowCollapsed_WindowPtr(window,collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_WindowPtr(window,collapsed,cond)
end
function M.SetWindowCollapsed(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a1) or type(a1)=='boolean') then return M.SetWindowCollapsed_Bool(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowCollapsed_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowCollapsed_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowCollapsed could not find overloaded'
end
---@return nil
function M.SetWindowFocus_Nil()
    return lib.igSetWindowFocus_Nil()
end
---@param name string
---@return nil
function M.SetWindowFocus_Str(name)
    return lib.igSetWindowFocus_Str(name)
end
function M.SetWindowFocus(a1) -- generic version
    if a1==nil then return M.SetWindowFocus_Nil() end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowFocus_Str(a1) end
    print(a1)
    error'M.SetWindowFocus could not find overloaded'
end
---@param scale number
---@return nil
function M.SetWindowFontScale(scale)
    return lib.igSetWindowFontScale(scale)
end
---@param window ffi.ct* ImGuiWindow*
---@param pos ImVec2
---@param size ImVec2
---@return nil
function M.SetWindowHitTestHole(window,pos,size)
    return lib.igSetWindowHitTestHole(window,pos,size)
end
---@param pos ImVec2
---@param cond number?
---@return nil
function M.SetWindowPos_Vec2(pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_Vec2(pos,cond)
end
---@param name string
---@param pos ImVec2
---@param cond number?
---@return nil
function M.SetWindowPos_Str(name,pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_Str(name,pos,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param pos ImVec2
---@param cond number?
---@return nil
function M.SetWindowPos_WindowPtr(window,pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_WindowPtr(window,pos,cond)
end
function M.SetWindowPos(a1,a2,a3) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.SetWindowPos_Vec2(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowPos_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowPos_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowPos could not find overloaded'
end
---@param size ImVec2
---@param cond number?
---@return nil
function M.SetWindowSize_Vec2(size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_Vec2(size,cond)
end
---@param name string
---@param size ImVec2
---@param cond number?
---@return nil
function M.SetWindowSize_Str(name,size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_Str(name,size,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param size ImVec2
---@param cond number?
---@return nil
function M.SetWindowSize_WindowPtr(window,size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_WindowPtr(window,size,cond)
end
function M.SetWindowSize(a1,a2,a3) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.SetWindowSize_Vec2(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowSize_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowSize_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowSize could not find overloaded'
end
---@param window ffi.ct* ImGuiWindow*
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.SetWindowViewport(window,viewport)
    return lib.igSetWindowViewport(window,viewport)
end
---@param draw_list ffi.ct* ImDrawList*
---@param vert_start_idx number
---@param vert_end_idx number
---@param gradient_p0 ImVec2
---@param gradient_p1 ImVec2
---@param col0 number
---@param col1 number
---@return nil
function M.ShadeVertsLinearColorGradientKeepAlpha(draw_list,vert_start_idx,vert_end_idx,gradient_p0,gradient_p1,col0,col1)
    return lib.igShadeVertsLinearColorGradientKeepAlpha(draw_list,vert_start_idx,vert_end_idx,gradient_p0,gradient_p1,col0,col1)
end
---@param draw_list ffi.ct* ImDrawList*
---@param vert_start_idx number
---@param vert_end_idx number
---@param a ImVec2
---@param b ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param clamp boolean
---@return nil
function M.ShadeVertsLinearUV(draw_list,vert_start_idx,vert_end_idx,a,b,uv_a,uv_b,clamp)
    return lib.igShadeVertsLinearUV(draw_list,vert_start_idx,vert_end_idx,a,b,uv_a,uv_b,clamp)
end
---@param key_chord number
---@param owner_id number?
---@param flags number?
---@return boolean
function M.Shortcut(key_chord,owner_id,flags)
    flags = flags or 0
    owner_id = owner_id or 0
    return lib.igShortcut(key_chord,owner_id,flags)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowAboutWindow(p_open)
    p_open = p_open or nil
    return lib.igShowAboutWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowDebugLogWindow(p_open)
    p_open = p_open or nil
    return lib.igShowDebugLogWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowDemoWindow(p_open)
    p_open = p_open or nil
    return lib.igShowDemoWindow(p_open)
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ShowFontAtlas(atlas)
    return lib.igShowFontAtlas(atlas)
end
---@param label string
---@return nil
function M.ShowFontSelector(label)
    return lib.igShowFontSelector(label)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowMetricsWindow(p_open)
    p_open = p_open or nil
    return lib.igShowMetricsWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowStackToolWindow(p_open)
    p_open = p_open or nil
    return lib.igShowStackToolWindow(p_open)
end
---@param ref ffi.ct*? ImGuiStyle*
---@return nil
function M.ShowStyleEditor(ref)
    ref = ref or nil
    return lib.igShowStyleEditor(ref)
end
---@param label string
---@return boolean
function M.ShowStyleSelector(label)
    return lib.igShowStyleSelector(label)
end
---@return nil
function M.ShowUserGuide()
    return lib.igShowUserGuide()
end
---@param items ffi.ct* ImGuiShrinkWidthItem*
---@param count number
---@param width_excess number
---@return nil
function M.ShrinkWidths(items,count,width_excess)
    return lib.igShrinkWidths(items,count,width_excess)
end
---@return nil
function M.Shutdown()
    return lib.igShutdown()
end
---@param label string
---@param v_rad ffi.ct* float*
---@param v_degrees_min number?
---@param v_degrees_max number?
---@param format string?
---@param flags number?
---@return boolean
function M.SliderAngle(label,v_rad,v_degrees_min,v_degrees_max,format,flags)
    flags = flags or 0
    format = format or "%.0f deg"
    v_degrees_max = v_degrees_max or 360.0
    v_degrees_min = v_degrees_min or -360.0
    return lib.igSliderAngle(label,v_rad,v_degrees_min,v_degrees_max,format,flags)
end
---@param bb ImRect
---@param id number
---@param data_type number
---@param p_v ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string
---@param flags number
---@param out_grab_bb ffi.ct* ImRect*
---@return boolean
function M.SliderBehavior(bb,id,data_type,p_v,p_min,p_max,format,flags,out_grab_bb)
    return lib.igSliderBehavior(bb,id,data_type,p_v,p_min,p_max,format,flags,out_grab_bb)
end
---@param label string
---@param v ffi.ct* float*
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderFloat(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderFloat2(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat2(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderFloat3(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat3(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderFloat4(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat4(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderInt(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderInt2(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt2(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderInt3(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt3(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.SliderInt4(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt4(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags number?
---@return boolean
function M.SliderScalar(label,data_type,p_data,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igSliderScalar(label,data_type,p_data,p_min,p_max,format,flags)
end
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param components number
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags number?
---@return boolean
function M.SliderScalarN(label,data_type,p_data,components,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igSliderScalarN(label,data_type,p_data,components,p_min,p_max,format,flags)
end
---@param label string
---@return boolean
function M.SmallButton(label)
    return lib.igSmallButton(label)
end
---@return nil
function M.Spacing()
    return lib.igSpacing()
end
---@param bb ImRect
---@param id number
---@param axis Axis
---@param size1 ffi.ct* float*
---@param size2 ffi.ct* float*
---@param min_size1 number
---@param min_size2 number
---@param hover_extend number?
---@param hover_visibility_delay number?
---@param bg_col number?
---@return boolean
function M.SplitterBehavior(bb,id,axis,size1,size2,min_size1,min_size2,hover_extend,hover_visibility_delay,bg_col)
    bg_col = bg_col or 0
    hover_extend = hover_extend or 0.0
    hover_visibility_delay = hover_visibility_delay or 0.0
    return lib.igSplitterBehavior(bb,id,axis,size1,size2,min_size1,min_size2,hover_extend,hover_visibility_delay,bg_col)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.StartMouseMovingWindow(window)
    return lib.igStartMouseMovingWindow(window)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsClassic(dst)
    dst = dst or nil
    return lib.igStyleColorsClassic(dst)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsDark(dst)
    dst = dst or nil
    return lib.igStyleColorsDark(dst)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsLight(dst)
    dst = dst or nil
    return lib.igStyleColorsLight(dst)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return nil
function M.TabBarCloseTab(tab_bar,tab)
    return lib.igTabBarCloseTab(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab_id number
---@return ffi.ct* ImGuiTabItem*
function M.TabBarFindTabByID(tab_bar,tab_id)
    return lib.igTabBarFindTabByID(tab_bar,tab_id)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param order number
---@return ffi.ct* ImGuiTabItem*
function M.TabBarFindTabByOrder(tab_bar,order)
    return lib.igTabBarFindTabByOrder(tab_bar,order)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return ffi.ct* ImGuiTabItem*
function M.TabBarGetCurrentTab(tab_bar)
    return lib.igTabBarGetCurrentTab(tab_bar)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return string
function M.TabBarGetTabName(tab_bar,tab)
    return ffi.string(lib.igTabBarGetTabName(tab_bar,tab))
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return number
function M.TabBarGetTabOrder(tab_bar,tab)
    return lib.igTabBarGetTabOrder(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return boolean
function M.TabBarProcessReorder(tab_bar)
    return lib.igTabBarProcessReorder(tab_bar)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return nil
function M.TabBarQueueFocus(tab_bar,tab)
    return lib.igTabBarQueueFocus(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@param offset number
---@return nil
function M.TabBarQueueReorder(tab_bar,tab,offset)
    return lib.igTabBarQueueReorder(tab_bar,tab,offset)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@param mouse_pos ImVec2
---@return nil
function M.TabBarQueueReorderFromMousePos(tab_bar,tab,mouse_pos)
    return lib.igTabBarQueueReorderFromMousePos(tab_bar,tab,mouse_pos)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab_id number
---@return nil
function M.TabBarRemoveTab(tab_bar,tab_id)
    return lib.igTabBarRemoveTab(tab_bar,tab_id)
end
---@param draw_list ffi.ct* ImDrawList*
---@param bb ImRect
---@param flags number
---@param col number
---@return nil
function M.TabItemBackground(draw_list,bb,flags,col)
    return lib.igTabItemBackground(draw_list,bb,flags,col)
end
---@param label string
---@param flags number?
---@return boolean
function M.TabItemButton(label,flags)
    flags = flags or 0
    return lib.igTabItemButton(label,flags)
end
---@param label string
---@param has_close_button_or_unsaved_marker boolean
---@return nil
function M.TabItemCalcSize_Str(label,has_close_button_or_unsaved_marker)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igTabItemCalcSize_Str(nonUDT_out,label,has_close_button_or_unsaved_marker)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.TabItemCalcSize_WindowPtr(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igTabItemCalcSize_WindowPtr(nonUDT_out,window)
    return nonUDT_out
end
function M.TabItemCalcSize(a2,a3) -- generic version
    if (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.TabItemCalcSize_Str(a2,a3) end
    if (ffi.istype('ImGuiWindow*',a2) or ffi.istype('ImGuiWindow',a2) or ffi.istype('ImGuiWindow[]',a2)) then return M.TabItemCalcSize_WindowPtr(a2) end
    print(a2,a3)
    error'M.TabItemCalcSize could not find overloaded'
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param label string
---@param p_open ffi.ct* bool*
---@param flags number
---@param docked_window ffi.ct* ImGuiWindow*
---@return boolean
function M.TabItemEx(tab_bar,label,p_open,flags,docked_window)
    return lib.igTabItemEx(tab_bar,label,p_open,flags,docked_window)
end
---@param draw_list ffi.ct* ImDrawList*
---@param bb ImRect
---@param flags number
---@param frame_padding ImVec2
---@param label string
---@param tab_id number
---@param close_button_id number
---@param is_contents_visible boolean
---@param out_just_closed ffi.ct* bool*
---@param out_text_clipped ffi.ct* bool*
---@return nil
function M.TabItemLabelAndCloseButton(draw_list,bb,flags,frame_padding,label,tab_id,close_button_id,is_contents_visible,out_just_closed,out_text_clipped)
    return lib.igTabItemLabelAndCloseButton(draw_list,bb,flags,frame_padding,label,tab_id,close_button_id,is_contents_visible,out_just_closed,out_text_clipped)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableBeginApplyRequests(table)
    return lib.igTableBeginApplyRequests(table)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number
---@return nil
function M.TableBeginCell(table,column_n)
    return lib.igTableBeginCell(table,column_n)
end
---@param table ffi.ct* ImGuiTable*
---@return boolean
function M.TableBeginContextMenuPopup(table)
    return lib.igTableBeginContextMenuPopup(table)
end
---@param table ffi.ct* ImGuiTable*
---@param columns_count number
---@return nil
function M.TableBeginInitMemory(table,columns_count)
    return lib.igTableBeginInitMemory(table,columns_count)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableBeginRow(table)
    return lib.igTableBeginRow(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableDrawBorders(table)
    return lib.igTableDrawBorders(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableDrawContextMenu(table)
    return lib.igTableDrawContextMenu(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableEndCell(table)
    return lib.igTableEndCell(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableEndRow(table)
    return lib.igTableEndRow(table)
end
---@param id number
---@return ffi.ct* ImGuiTable*
function M.TableFindByID(id)
    return lib.igTableFindByID(id)
end
---@param table ffi.ct* ImGuiTable*
---@param column ffi.ct* ImGuiTableColumn*
---@return nil
function M.TableFixColumnSortDirection(table,column)
    return lib.igTableFixColumnSortDirection(table,column)
end
---@return nil
function M.TableGcCompactSettings()
    return lib.igTableGcCompactSettings()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableGcCompactTransientBuffers_TablePtr(table)
    return lib.igTableGcCompactTransientBuffers_TablePtr(table)
end
---@param table ffi.ct* ImGuiTableTempData*
---@return nil
function M.TableGcCompactTransientBuffers_TableTempDataPtr(table)
    return lib.igTableGcCompactTransientBuffers_TableTempDataPtr(table)
end
function M.TableGcCompactTransientBuffers(a1) -- generic version
    if (ffi.istype('ImGuiTable*',a1) or ffi.istype('ImGuiTable',a1) or ffi.istype('ImGuiTable[]',a1)) then return M.TableGcCompactTransientBuffers_TablePtr(a1) end
    if (ffi.istype('ImGuiTableTempData*',a1) or ffi.istype('ImGuiTableTempData',a1) or ffi.istype('ImGuiTableTempData[]',a1)) then return M.TableGcCompactTransientBuffers_TableTempDataPtr(a1) end
    print(a1)
    error'M.TableGcCompactTransientBuffers could not find overloaded'
end
---@param table ffi.ct* ImGuiTable*
---@return ffi.ct* ImGuiTableSettings*
function M.TableGetBoundSettings(table)
    return lib.igTableGetBoundSettings(table)
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number
---@return nil
function M.TableGetCellBgRect(table,column_n)
    local nonUDT_out = ffi.new("ImRect")
    lib.igTableGetCellBgRect(nonUDT_out,table,column_n)
    return nonUDT_out
end
---@return number
function M.TableGetColumnCount()
    return lib.igTableGetColumnCount()
end
---@param column_n number?
---@return number
function M.TableGetColumnFlags(column_n)
    column_n = column_n or -1
    return lib.igTableGetColumnFlags(column_n)
end
---@return number
function M.TableGetColumnIndex()
    return lib.igTableGetColumnIndex()
end
---@param column_n number?
---@return string
function M.TableGetColumnName_Int(column_n)
    column_n = column_n or -1
    return ffi.string(lib.igTableGetColumnName_Int(column_n))
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number
---@return string
function M.TableGetColumnName_TablePtr(table,column_n)
    return ffi.string(lib.igTableGetColumnName_TablePtr(table,column_n))
end
function M.TableGetColumnName(a1,a2) -- generic version
    if ((ffi.istype('int',a1) or type(a1)=='number') or type(a1)=='nil') then return M.TableGetColumnName_Int(a1) end
    if (ffi.istype('const ImGuiTable*',a1) or ffi.istype('const ImGuiTable',a1) or ffi.istype('const ImGuiTable[]',a1)) then return M.TableGetColumnName_TablePtr(a1,a2) end
    print(a1,a2)
    error'M.TableGetColumnName could not find overloaded'
end
---@param column ffi.ct* ImGuiTableColumn*
---@return number
function M.TableGetColumnNextSortDirection(column)
    return lib.igTableGetColumnNextSortDirection(column)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number
---@param instance_no number?
---@return number
function M.TableGetColumnResizeID(table,column_n,instance_no)
    instance_no = instance_no or 0
    return lib.igTableGetColumnResizeID(table,column_n,instance_no)
end
---@param table ffi.ct* ImGuiTable*
---@param column ffi.ct* ImGuiTableColumn*
---@return number
function M.TableGetColumnWidthAuto(table,column)
    return lib.igTableGetColumnWidthAuto(table,column)
end
---@return number
function M.TableGetHeaderRowHeight()
    return lib.igTableGetHeaderRowHeight()
end
---@return number
function M.TableGetHoveredColumn()
    return lib.igTableGetHoveredColumn()
end
---@param table ffi.ct* ImGuiTable*
---@param instance_no number
---@return ffi.ct* ImGuiTableInstanceData*
function M.TableGetInstanceData(table,instance_no)
    return lib.igTableGetInstanceData(table,instance_no)
end
---@param table ffi.ct* ImGuiTable*
---@param instance_no number
---@return number
function M.TableGetInstanceID(table,instance_no)
    return lib.igTableGetInstanceID(table,instance_no)
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number
---@return number
function M.TableGetMaxColumnWidth(table,column_n)
    return lib.igTableGetMaxColumnWidth(table,column_n)
end
---@return number
function M.TableGetRowIndex()
    return lib.igTableGetRowIndex()
end
---@return ffi.ct* ImGuiTableSortSpecs*
function M.TableGetSortSpecs()
    return lib.igTableGetSortSpecs()
end
---@param label string
---@return nil
function M.TableHeader(label)
    return lib.igTableHeader(label)
end
---@return nil
function M.TableHeadersRow()
    return lib.igTableHeadersRow()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableLoadSettings(table)
    return lib.igTableLoadSettings(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableMergeDrawChannels(table)
    return lib.igTableMergeDrawChannels(table)
end
---@return boolean
function M.TableNextColumn()
    return lib.igTableNextColumn()
end
---@param row_flags number?
---@param min_row_height number?
---@return nil
function M.TableNextRow(row_flags,min_row_height)
    min_row_height = min_row_height or 0.0
    row_flags = row_flags or 0
    return lib.igTableNextRow(row_flags,min_row_height)
end
---@param column_n number?
---@return nil
function M.TableOpenContextMenu(column_n)
    column_n = column_n or -1
    return lib.igTableOpenContextMenu(column_n)
end
---@return nil
function M.TablePopBackgroundChannel()
    return lib.igTablePopBackgroundChannel()
end
---@return nil
function M.TablePushBackgroundChannel()
    return lib.igTablePushBackgroundChannel()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableRemove(table)
    return lib.igTableRemove(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableResetSettings(table)
    return lib.igTableResetSettings(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSaveSettings(table)
    return lib.igTableSaveSettings(table)
end
---@param target number
---@param color number
---@param column_n number?
---@return nil
function M.TableSetBgColor(target,color,column_n)
    column_n = column_n or -1
    return lib.igTableSetBgColor(target,color,column_n)
end
---@param column_n number
---@param v boolean
---@return nil
function M.TableSetColumnEnabled(column_n,v)
    return lib.igTableSetColumnEnabled(column_n,v)
end
---@param column_n number
---@return boolean
function M.TableSetColumnIndex(column_n)
    return lib.igTableSetColumnIndex(column_n)
end
---@param column_n number
---@param sort_direction number
---@param append_to_sort_specs boolean
---@return nil
function M.TableSetColumnSortDirection(column_n,sort_direction,append_to_sort_specs)
    return lib.igTableSetColumnSortDirection(column_n,sort_direction,append_to_sort_specs)
end
---@param column_n number
---@param width number
---@return nil
function M.TableSetColumnWidth(column_n,width)
    return lib.igTableSetColumnWidth(column_n,width)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSetColumnWidthAutoAll(table)
    return lib.igTableSetColumnWidthAutoAll(table)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number
---@return nil
function M.TableSetColumnWidthAutoSingle(table,column_n)
    return lib.igTableSetColumnWidthAutoSingle(table,column_n)
end
---@return nil
function M.TableSettingsAddSettingsHandler()
    return lib.igTableSettingsAddSettingsHandler()
end
---@param id number
---@param columns_count number
---@return ffi.ct* ImGuiTableSettings*
function M.TableSettingsCreate(id,columns_count)
    return lib.igTableSettingsCreate(id,columns_count)
end
---@param id number
---@return ffi.ct* ImGuiTableSettings*
function M.TableSettingsFindByID(id)
    return lib.igTableSettingsFindByID(id)
end
---@param label string
---@param flags number?
---@param init_width_or_weight number?
---@param user_id number?
---@return nil
function M.TableSetupColumn(label,flags,init_width_or_weight,user_id)
    flags = flags or 0
    init_width_or_weight = init_width_or_weight or 0.0
    user_id = user_id or 0
    return lib.igTableSetupColumn(label,flags,init_width_or_weight,user_id)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSetupDrawChannels(table)
    return lib.igTableSetupDrawChannels(table)
end
---@param cols number
---@param rows number
---@return nil
function M.TableSetupScrollFreeze(cols,rows)
    return lib.igTableSetupScrollFreeze(cols,rows)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSortSpecsBuild(table)
    return lib.igTableSortSpecsBuild(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSortSpecsSanitize(table)
    return lib.igTableSortSpecsSanitize(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateBorders(table)
    return lib.igTableUpdateBorders(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateColumnsWeightFromWidth(table)
    return lib.igTableUpdateColumnsWeightFromWidth(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateLayout(table)
    return lib.igTableUpdateLayout(table)
end
---@param id number
---@return boolean
function M.TempInputIsActive(id)
    return lib.igTempInputIsActive(id)
end
---@param bb ImRect
---@param id number
---@param label string
---@param data_type number
---@param p_data ffi.ct* void*
---@param format string
---@param p_clamp_min ffi.ct*? const void*
---@param p_clamp_max ffi.ct*? const void*
---@return boolean
function M.TempInputScalar(bb,id,label,data_type,p_data,format,p_clamp_min,p_clamp_max)
    p_clamp_max = p_clamp_max or nil
    p_clamp_min = p_clamp_min or nil
    return lib.igTempInputScalar(bb,id,label,data_type,p_data,format,p_clamp_min,p_clamp_max)
end
---@param bb ImRect
---@param id number
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number
---@param flags number
---@return boolean
function M.TempInputText(bb,id,label,buf,buf_size,flags)
    return lib.igTempInputText(bb,id,label,buf,buf_size,flags)
end
---@param key Key
---@param owner_id number
---@return boolean
function M.TestKeyOwner(key,owner_id)
    return lib.igTestKeyOwner(key,owner_id)
end
---@param key_chord number
---@param owner_id number
---@return boolean
function M.TestShortcutRouting(key_chord,owner_id)
    return lib.igTestShortcutRouting(key_chord,owner_id)
end
---@param fmt string
---@return nil
function M.Text(fmt,...)
    return lib.igText(fmt,...)
end
---@param col ffi.ct* const ImVec4
---@param fmt string
---@return nil
function M.TextColored(col,fmt,...)
    return lib.igTextColored(col,fmt,...)
end
---@param col ffi.ct* const ImVec4
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextColoredV(col,fmt,args)
    return lib.igTextColoredV(col,fmt,args)
end
---@param fmt string
---@return nil
function M.TextDisabled(fmt,...)
    return lib.igTextDisabled(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextDisabledV(fmt,args)
    return lib.igTextDisabledV(fmt,args)
end
---@param text string
---@param text_end string?
---@param flags number?
---@return nil
function M.TextEx(text,text_end,flags)
    flags = flags or 0
    text_end = text_end or nil
    return lib.igTextEx(text,text_end,flags)
end
---@param text string
---@param text_end string?
---@return nil
function M.TextUnformatted(text,text_end)
    text_end = text_end or nil
    return lib.igTextUnformatted(text,text_end)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextV(fmt,args)
    return lib.igTextV(fmt,args)
end
---@param fmt string
---@return nil
function M.TextWrapped(fmt,...)
    return lib.igTextWrapped(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextWrappedV(fmt,args)
    return lib.igTextWrappedV(fmt,args)
end
---@param label string
---@return boolean
function M.TreeNode_Str(label)
    return lib.igTreeNode_Str(label)
end
---@param str_id string
---@param fmt string
---@return boolean
function M.TreeNode_StrStr(str_id,fmt,...)
    return lib.igTreeNode_StrStr(str_id,fmt,...)
end
---@param ptr_id ffi.ct* const void*
---@param fmt string
---@return boolean
function M.TreeNode_Ptr(ptr_id,fmt,...)
    return lib.igTreeNode_Ptr(ptr_id,fmt,...)
end
function M.TreeNode(a1,a2,...) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.TreeNode_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.TreeNode_StrStr(a1,a2,...) end
    if ffi.istype('const void*',a1) then return M.TreeNode_Ptr(a1,a2,...) end
    print(a1,a2,...)
    error'M.TreeNode could not find overloaded'
end
---@param id number
---@param flags number
---@param label string
---@param label_end string?
---@return boolean
function M.TreeNodeBehavior(id,flags,label,label_end)
    label_end = label_end or nil
    return lib.igTreeNodeBehavior(id,flags,label,label_end)
end
---@param label string
---@param flags number?
---@return boolean
function M.TreeNodeEx_Str(label,flags)
    flags = flags or 0
    return lib.igTreeNodeEx_Str(label,flags)
end
---@param str_id string
---@param flags number
---@param fmt string
---@return boolean
function M.TreeNodeEx_StrStr(str_id,flags,fmt,...)
    return lib.igTreeNodeEx_StrStr(str_id,flags,fmt,...)
end
---@param ptr_id ffi.ct* const void*
---@param flags number
---@param fmt string
---@return boolean
function M.TreeNodeEx_Ptr(ptr_id,flags,fmt,...)
    return lib.igTreeNodeEx_Ptr(ptr_id,flags,fmt,...)
end
function M.TreeNodeEx(a1,a2,a3,...) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a3==nil then return M.TreeNodeEx_Str(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a3) or ffi.istype('char[]',a3) or type(a3)=='string') then return M.TreeNodeEx_StrStr(a1,a2,a3,...) end
    if ffi.istype('const void*',a1) then return M.TreeNodeEx_Ptr(a1,a2,a3,...) end
    print(a1,a2,a3,...)
    error'M.TreeNodeEx could not find overloaded'
end
---@param str_id string
---@param flags number
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeExV_Str(str_id,flags,fmt,args)
    return lib.igTreeNodeExV_Str(str_id,flags,fmt,args)
end
---@param ptr_id ffi.ct* const void*
---@param flags number
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeExV_Ptr(ptr_id,flags,fmt,args)
    return lib.igTreeNodeExV_Ptr(ptr_id,flags,fmt,args)
end
function M.TreeNodeExV(a1,a2,a3,a4) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreeNodeExV_Str(a1,a2,a3,a4) end
    if ffi.istype('const void*',a1) then return M.TreeNodeExV_Ptr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.TreeNodeExV could not find overloaded'
end
---@param id number
---@param open boolean
---@return nil
function M.TreeNodeSetOpen(id,open)
    return lib.igTreeNodeSetOpen(id,open)
end
---@param id number
---@param flags number
---@return boolean
function M.TreeNodeUpdateNextOpen(id,flags)
    return lib.igTreeNodeUpdateNextOpen(id,flags)
end
---@param str_id string
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeV_Str(str_id,fmt,args)
    return lib.igTreeNodeV_Str(str_id,fmt,args)
end
---@param ptr_id ffi.ct* const void*
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeV_Ptr(ptr_id,fmt,args)
    return lib.igTreeNodeV_Ptr(ptr_id,fmt,args)
end
function M.TreeNodeV(a1,a2,a3) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreeNodeV_Str(a1,a2,a3) end
    if ffi.istype('const void*',a1) then return M.TreeNodeV_Ptr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.TreeNodeV could not find overloaded'
end
---@return nil
function M.TreePop()
    return lib.igTreePop()
end
---@param str_id string
---@return nil
function M.TreePush_Str(str_id)
    return lib.igTreePush_Str(str_id)
end
---@param ptr_id ffi.ct* const void*
---@return nil
function M.TreePush_Ptr(ptr_id)
    return lib.igTreePush_Ptr(ptr_id)
end
function M.TreePush(a1) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreePush_Str(a1) end
    if ffi.istype('const void*',a1) then return M.TreePush_Ptr(a1) end
    print(a1)
    error'M.TreePush could not find overloaded'
end
---@param id number
---@return nil
function M.TreePushOverrideID(id)
    return lib.igTreePushOverrideID(id)
end
---@param indent_w number?
---@return nil
function M.Unindent(indent_w)
    indent_w = indent_w or 0.0
    return lib.igUnindent(indent_w)
end
---@return nil
function M.UpdateHoveredWindowAndCaptureFlags()
    return lib.igUpdateHoveredWindowAndCaptureFlags()
end
---@param trickle_fast_inputs boolean
---@return nil
function M.UpdateInputEvents(trickle_fast_inputs)
    return lib.igUpdateInputEvents(trickle_fast_inputs)
end
---@return nil
function M.UpdateMouseMovingWindowEndFrame()
    return lib.igUpdateMouseMovingWindowEndFrame()
end
---@return nil
function M.UpdateMouseMovingWindowNewFrame()
    return lib.igUpdateMouseMovingWindowNewFrame()
end
---@param window ffi.ct* ImGuiWindow*
---@param flags number
---@param parent_window ffi.ct* ImGuiWindow*
---@return nil
function M.UpdateWindowParentAndRootLinks(window,flags,parent_window)
    return lib.igUpdateWindowParentAndRootLinks(window,flags,parent_window)
end
---@param label string
---@param size ImVec2
---@param v ffi.ct* float*
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.VSliderFloat(label,size,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igVSliderFloat(label,size,v,v_min,v_max,format,flags)
end
---@param label string
---@param size ImVec2
---@param v ffi.ct* int*
---@param v_min number
---@param v_max number
---@param format string?
---@param flags number?
---@return boolean
function M.VSliderInt(label,size,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igVSliderInt(label,size,v,v_min,v_max,format,flags)
end
---@param label string
---@param size ImVec2
---@param data_type number
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags number?
---@return boolean
function M.VSliderScalar(label,size,data_type,p_data,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igVSliderScalar(label,size,data_type,p_data,p_min,p_max,format,flags)
end
---@param prefix string
---@param b boolean
---@return nil
function M.Value_Bool(prefix,b)
    return lib.igValue_Bool(prefix,b)
end
---@param prefix string
---@param v number
---@return nil
function M.Value_Int(prefix,v)
    return lib.igValue_Int(prefix,v)
end
---@param prefix string
---@param v number
---@return nil
function M.Value_Uint(prefix,v)
    return lib.igValue_Uint(prefix,v)
end
---@param prefix string
---@param v number
---@param float_format string?
---@return nil
function M.Value_Float(prefix,v,float_format)
    float_format = float_format or nil
    return lib.igValue_Float(prefix,v,float_format)
end
function M.Value(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.Value_Bool(a1,a2) end
    if (ffi.istype('int',a2) or type(a2)=='number') then return M.Value_Int(a1,a2) end
    if ffi.istype('unsigned int',a2) then return M.Value_Uint(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return M.Value_Float(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.Value could not find overloaded'
end
---@param window ffi.ct* ImGuiWindow*
---@param r ImRect
---@return nil
function M.WindowRectAbsToRel(window,r)
    local nonUDT_out = ffi.new("ImRect")
    lib.igWindowRectAbsToRel(nonUDT_out,window,r)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@param r ImRect
---@return nil
function M.WindowRectRelToAbs(window,r)
    local nonUDT_out = ffi.new("ImRect")
    lib.igWindowRectRelToAbs(nonUDT_out,window,r)
    return nonUDT_out
end
return M
----------END_AUTOGENERATED_LUA-----------------------------