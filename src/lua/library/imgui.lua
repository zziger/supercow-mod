local ffi = require "ffi"
local lib = ffi.C

-----------ImStr definition
local ImStrv
if pcall(function() local a = ffi.new("ImStrv")end) then

ImStrv= {}
function ImStrv.__new(ctype,a,b)
	b = b or ffi.new("const char*",a) + (a and #a or 0)
	return ffi.new(ctype,a,b)
end
function ImStrv.__tostring(is)
	return is.Begin~=nil and ffi.string(is.Begin,is.End~=nil and is.End-is.Begin or nil) or nil
end
ImStrv.__index = ImStrv
ImStrv = ffi.metatype("ImStrv",ImStrv)

end
-----------ImVec2 definition
---@class ImVec2 : ffi.ctype*
local ImVec2
ImVec2 = {
    __add = function(a,b) return ImVec2(a.x + b.x, a.y + b.y) end,
    __sub = function(a,b) return ImVec2(a.x - b.x, a.y - b.y) end,
    __unm = function(a) return ImVec2(-a.x,-a.y) end,
    __mul = function(a, b) --scalar mult
        if not ffi.istype(ImVec2, b) then
        return ImVec2(a.x * b, a.y * b) end
        return ImVec2(a * b.x, a * b.y)
    end,
	__len = function(a) return math.sqrt(a.x*a.x+a.y*a.y) end,
	norm = function(a)
		return math.sqrt(a.x*a.x+a.y*a.y)
	end,
    __tostring = function(v) return 'ImVec2<'..v.x..','..v.y..'>' end
}
ImVec2.__index = ImVec2
ImVec2 = ffi.metatype("ImVec2",ImVec2) --[[@as ImVec2]]
local ImVec4= {}
ImVec4.__index = ImVec4
ImVec4 = ffi.metatype("ImVec4",ImVec4)
--the module
local M = {ImVec2 = ImVec2, ImVec4 = ImVec4 , ImStrv = ImStrv, lib = lib}

if jit.os == "Windows" then
    function M.ToUTF(unc_str)
        local buf_len = lib.igImTextCountUtf8BytesFromStr(unc_str, nil) + 1;
        local buf_local = ffi.new("char[?]",buf_len)
        lib.igImTextStrToUtf8(buf_local, buf_len, unc_str, nil);
        return buf_local
    end

    function M.FromUTF(utf_str)
        local wbuf_length = lib.igImTextCountCharsFromUtf8(utf_str, nil) + 1;
        local buf_local = ffi.new("ImWchar[?]",wbuf_length)
        lib.igImTextStrFromUtf8(buf_local, wbuf_length, utf_str, nil,nil);
        return buf_local
    end
end

M.FLT_MAX = lib.igGET_FLT_MAX()
M.FLT_MIN = lib.igGET_FLT_MIN()

-----------Custom widgets
function M.HelpMarker(desc, icon)
    icon = icon or "\xee\xae\x8b"
    M.TextDisabled(icon)

    if M.IsItemHovered(M.HoveredFlags.DelayShort) then
        M.BeginTooltip()
        M.PushTextWrapPos(M.GetFontSize() * 35)
        M.TextUnformatted(desc)
        M.PopTextWrapPos()
        M.EndTooltip()
    end
end

---@param center bool? Should next modal be centered in main viewport? Default is true.
function M.FixNextPopupModal(center)
    center = center == nil and true or center
    local cls = M.ImGuiWindowClass()
    cls.ViewportFlagsOverrideSet = M.ViewportFlags.NoAutoMerge + M.ViewportFlags.TopMost
    M.SetNextWindowClass(cls)
    if center then
        M.SetNextWindowPos(M.GetMainViewport():GetCenter(), M.Cond.Appearing, ImVec2(0.5, 0.5))
    end
end

---@autogen----------BEGIN_AUTOGENERATED_LUA---------------------------
--------------------------ImDrawFlags----------------------------
---@enum ImDrawFlags
M.ImDrawFlags = {
    None = 0,
    Closed = 1,
    RoundCornersTopLeft = 16,
    RoundCornersTopRight = 32,
    RoundCornersBottomLeft = 64,
    RoundCornersBottomRight = 128,
    RoundCornersNone = 256,
    RoundCornersTop = 48,
    RoundCornersBottom = 192,
    RoundCornersLeft = 80,
    RoundCornersRight = 160,
    RoundCornersAll = 240,
    RoundCornersDefault_ = 240,
    RoundCornersMask_ = 496,
}
--------------------------ImDrawListFlags----------------------------
---@enum ImDrawListFlags
M.ImDrawListFlags = {
    None = 0,
    AntiAliasedLines = 1,
    AntiAliasedLinesUseTex = 2,
    AntiAliasedFill = 4,
    AllowVtxOffset = 8,
}
--------------------------ImFontAtlasFlags----------------------------
---@enum ImFontAtlasFlags
M.ImFontAtlasFlags = {
    None = 0,
    NoPowerOfTwoHeight = 1,
    NoMouseCursors = 2,
    NoBakedLines = 4,
}
--------------------------ActivateFlags----------------------------
---@enum ActivateFlags
M.ActivateFlags = {
    None = 0,
    PreferInput = 1,
    PreferTweak = 2,
    TryToPreserveState = 4,
    FromTabbing = 8,
    FromShortcut = 16,
}
--------------------------Axis----------------------------
---@enum Axis
M.Axis = {
    None = -1,
    X = 0,
    Y = 1,
}
--------------------------BackendFlags----------------------------
---@enum BackendFlags
M.BackendFlags = {
    None = 0,
    HasGamepad = 1,
    HasMouseCursors = 2,
    HasSetMousePos = 4,
    RendererHasVtxOffset = 8,
    PlatformHasViewports = 1024,
    HasMouseHoveredViewport = 2048,
    RendererHasViewports = 4096,
}
--------------------------ButtonFlagsPrivate----------------------------
---@enum ButtonFlagsPrivate
M.ButtonFlagsPrivate = {
    PressedOnClick = 16,
    PressedOnClickRelease = 32,
    PressedOnClickReleaseAnywhere = 64,
    PressedOnRelease = 128,
    PressedOnDoubleClick = 256,
    PressedOnDragDropHold = 512,
    Repeat = 1024,
    FlattenChildren = 2048,
    AllowOverlap = 4096,
    DontClosePopups = 8192,
    AlignTextBaseLine = 32768,
    NoKeyModifiers = 65536,
    NoHoldingActiveId = 131072,
    NoNavFocus = 262144,
    NoHoveredOnFocus = 524288,
    NoSetKeyOwner = 1048576,
    NoTestKeyOwner = 2097152,
    PressedOnMask_ = 1008,
    PressedOnDefault_ = 32,
}
--------------------------ButtonFlags----------------------------
---@enum ButtonFlags
M.ButtonFlags = {
    None = 0,
    MouseButtonLeft = 1,
    MouseButtonRight = 2,
    MouseButtonMiddle = 4,
    MouseButtonMask_ = 7,
    MouseButtonDefault_ = 1,
}
--------------------------ChildFlags----------------------------
---@enum ChildFlags
M.ChildFlags = {
    None = 0,
    Border = 1,
    AlwaysUseWindowPadding = 2,
    ResizeX = 4,
    ResizeY = 8,
    AutoResizeX = 16,
    AutoResizeY = 32,
    AlwaysAutoResize = 64,
    FrameStyle = 128,
}
--------------------------Col----------------------------
---@enum Col
M.Col = {
    Text = 0,
    TextDisabled = 1,
    WindowBg = 2,
    ChildBg = 3,
    PopupBg = 4,
    Border = 5,
    BorderShadow = 6,
    FrameBg = 7,
    FrameBgHovered = 8,
    FrameBgActive = 9,
    TitleBg = 10,
    TitleBgActive = 11,
    TitleBgCollapsed = 12,
    MenuBarBg = 13,
    ScrollbarBg = 14,
    ScrollbarGrab = 15,
    ScrollbarGrabHovered = 16,
    ScrollbarGrabActive = 17,
    CheckMark = 18,
    SliderGrab = 19,
    SliderGrabActive = 20,
    Button = 21,
    ButtonHovered = 22,
    ButtonActive = 23,
    Header = 24,
    HeaderHovered = 25,
    HeaderActive = 26,
    Separator = 27,
    SeparatorHovered = 28,
    SeparatorActive = 29,
    ResizeGrip = 30,
    ResizeGripHovered = 31,
    ResizeGripActive = 32,
    Tab = 33,
    TabHovered = 34,
    TabActive = 35,
    TabUnfocused = 36,
    TabUnfocusedActive = 37,
    DockingPreview = 38,
    DockingEmptyBg = 39,
    PlotLines = 40,
    PlotLinesHovered = 41,
    PlotHistogram = 42,
    PlotHistogramHovered = 43,
    TableHeaderBg = 44,
    TableBorderStrong = 45,
    TableBorderLight = 46,
    TableRowBg = 47,
    TableRowBgAlt = 48,
    TextSelectedBg = 49,
    DragDropTarget = 50,
    NavHighlight = 51,
    NavWindowingHighlight = 52,
    NavWindowingDimBg = 53,
    ModalWindowDimBg = 54,
    COUNT = 55,
}
--------------------------ColorEditFlags----------------------------
---@enum ColorEditFlags
M.ColorEditFlags = {
    None = 0,
    NoAlpha = 2,
    NoPicker = 4,
    NoOptions = 8,
    NoSmallPreview = 16,
    NoInputs = 32,
    NoTooltip = 64,
    NoLabel = 128,
    NoSidePreview = 256,
    NoDragDrop = 512,
    NoBorder = 1024,
    AlphaBar = 65536,
    AlphaPreview = 131072,
    AlphaPreviewHalf = 262144,
    HDR = 524288,
    DisplayRGB = 1048576,
    DisplayHSV = 2097152,
    DisplayHex = 4194304,
    Uint8 = 8388608,
    Float = 16777216,
    PickerHueBar = 33554432,
    PickerHueWheel = 67108864,
    InputRGB = 134217728,
    InputHSV = 268435456,
    DefaultOptions_ = 177209344,
    DisplayMask_ = 7340032,
    DataTypeMask_ = 25165824,
    PickerMask_ = 100663296,
    InputMask_ = 402653184,
}
--------------------------ComboFlagsPrivate----------------------------
---@enum ComboFlagsPrivate
M.ComboFlagsPrivate = {
    CustomPreview = 1048576,
}
--------------------------ComboFlags----------------------------
---@enum ComboFlags
M.ComboFlags = {
    None = 0,
    PopupAlignLeft = 1,
    HeightSmall = 2,
    HeightRegular = 4,
    HeightLarge = 8,
    HeightLargest = 16,
    NoArrowButton = 32,
    NoPreview = 64,
    WidthFitPreview = 128,
    HeightMask_ = 30,
}
--------------------------Cond----------------------------
---@enum Cond
M.Cond = {
    None = 0,
    Always = 1,
    Once = 2,
    FirstUseEver = 4,
    Appearing = 8,
}
--------------------------ConfigFlags----------------------------
---@enum ConfigFlags
M.ConfigFlags = {
    None = 0,
    NavEnableKeyboard = 1,
    NavEnableGamepad = 2,
    NavEnableSetMousePos = 4,
    NavNoCaptureKeyboard = 8,
    NoMouse = 16,
    NoMouseCursorChange = 32,
    DockingEnable = 64,
    ViewportsEnable = 1024,
    DpiEnableScaleViewports = 16384,
    DpiEnableScaleFonts = 32768,
    IsSRGB = 1048576,
    IsTouchScreen = 2097152,
}
--------------------------ContextHookType----------------------------
---@enum ContextHookType
M.ContextHookType = {
    NewFramePre = 0,
    NewFramePost = 1,
    EndFramePre = 2,
    EndFramePost = 3,
    RenderPre = 4,
    RenderPost = 5,
    Shutdown = 6,
    PendingRemoval_ = 7,
}
--------------------------DataAuthority----------------------------
---@enum DataAuthority
M.DataAuthority = {
    Auto = 0,
    DockNode = 1,
    Window = 2,
}
--------------------------DataTypePrivate----------------------------
---@enum DataTypePrivate
M.DataTypePrivate = {
    String = 11,
    Pointer = 12,
    ID = 13,
}
--------------------------DataType----------------------------
---@enum DataType
M.DataType = {
    S8 = 0,
    U8 = 1,
    S16 = 2,
    U16 = 3,
    S32 = 4,
    U32 = 5,
    S64 = 6,
    U64 = 7,
    Float = 8,
    Double = 9,
    COUNT = 10,
}
--------------------------DebugLogFlags----------------------------
---@enum DebugLogFlags
M.DebugLogFlags = {
    None = 0,
    EventActiveId = 1,
    EventFocus = 2,
    EventPopup = 4,
    EventNav = 8,
    EventClipper = 16,
    EventSelection = 32,
    EventIO = 64,
    EventInputRouting = 128,
    EventDocking = 256,
    EventViewport = 512,
    EventMask_ = 1023,
    OutputToTTY = 1048576,
    OutputToTestEngine = 2097152,
}
--------------------------Dir----------------------------
---@enum Dir
M.Dir = {
    None = -1,
    Left = 0,
    Right = 1,
    Up = 2,
    Down = 3,
    COUNT = 4,
}
--------------------------DockNodeFlagsPrivate----------------------------
---@enum DockNodeFlagsPrivate
M.DockNodeFlagsPrivate = {
    DockSpace = 1024,
    CentralNode = 2048,
    NoTabBar = 4096,
    HiddenTabBar = 8192,
    NoWindowMenuButton = 16384,
    NoCloseButton = 32768,
    NoResizeX = 65536,
    NoResizeY = 131072,
    DockedWindowsInFocusRoute = 262144,
    NoDockingSplitOther = 524288,
    NoDockingOverMe = 1048576,
    NoDockingOverOther = 2097152,
    NoDockingOverEmpty = 4194304,
    NoDocking = 7864336,
    SharedFlagsInheritMask_ = -1,
    NoResizeFlagsMask_ = 196640,
    LocalFlagsTransferMask_ = 260208,
    SavedFlagsMask_ = 261152,
}
--------------------------DockNodeFlags----------------------------
---@enum DockNodeFlags
M.DockNodeFlags = {
    None = 0,
    KeepAliveOnly = 1,
    NoDockingOverCentralNode = 4,
    PassthruCentralNode = 8,
    NoDockingSplit = 16,
    NoResize = 32,
    AutoHideTabBar = 64,
    NoUndocking = 128,
}
--------------------------DockNodeState----------------------------
---@enum DockNodeState
M.DockNodeState = {
    Unknown = 0,
    HostWindowHiddenBecauseSingleWindow = 1,
    HostWindowHiddenBecauseWindowsAreResizing = 2,
    HostWindowVisible = 3,
}
--------------------------DragDropFlags----------------------------
---@enum DragDropFlags
M.DragDropFlags = {
    None = 0,
    SourceNoPreviewTooltip = 1,
    SourceNoDisableHover = 2,
    SourceNoHoldToOpenOthers = 4,
    SourceAllowNullID = 8,
    SourceExtern = 16,
    SourceAutoExpirePayload = 32,
    AcceptBeforeDelivery = 1024,
    AcceptNoDrawDefaultRect = 2048,
    AcceptNoPreviewTooltip = 4096,
    AcceptPeekOnly = 3072,
}
--------------------------FocusRequestFlags----------------------------
---@enum FocusRequestFlags
M.FocusRequestFlags = {
    None = 0,
    RestoreFocusedChild = 1,
    UnlessBelowModal = 2,
}
--------------------------FocusedFlags----------------------------
---@enum FocusedFlags
M.FocusedFlags = {
    None = 0,
    ChildWindows = 1,
    RootWindow = 2,
    AnyWindow = 4,
    NoPopupHierarchy = 8,
    DockHierarchy = 16,
    RootAndChildWindows = 3,
}
--------------------------HoveredFlagsPrivate----------------------------
---@enum HoveredFlagsPrivate
M.HoveredFlagsPrivate = {
    DelayMask_ = 245760,
    AllowedMaskForIsWindowHovered = 12479,
    AllowedMaskForIsItemHovered = 262048,
}
--------------------------HoveredFlags----------------------------
---@enum HoveredFlags
M.HoveredFlags = {
    None = 0,
    ChildWindows = 1,
    RootWindow = 2,
    AnyWindow = 4,
    NoPopupHierarchy = 8,
    DockHierarchy = 16,
    AllowWhenBlockedByPopup = 32,
    AllowWhenBlockedByActiveItem = 128,
    AllowWhenOverlappedByItem = 256,
    AllowWhenOverlappedByWindow = 512,
    AllowWhenDisabled = 1024,
    NoNavOverride = 2048,
    AllowWhenOverlapped = 768,
    RectOnly = 928,
    RootAndChildWindows = 3,
    ForTooltip = 4096,
    Stationary = 8192,
    DelayNone = 16384,
    DelayShort = 32768,
    DelayNormal = 65536,
    NoSharedDelay = 131072,
}
--------------------------InputEventType----------------------------
---@enum InputEventType
M.InputEventType = {
    None = 0,
    MousePos = 1,
    MouseWheel = 2,
    MouseButton = 3,
    MouseViewport = 4,
    Key = 5,
    Text = 6,
    Focus = 7,
    COUNT = 8,
}
--------------------------InputFlags----------------------------
---@enum InputFlags
M.InputFlags = {
    None = 0,
    Repeat = 1,
    RepeatRateDefault = 2,
    RepeatRateNavMove = 4,
    RepeatRateNavTweak = 8,
    RepeatUntilRelease = 16,
    RepeatUntilKeyModsChange = 32,
    RepeatUntilKeyModsChangeFromNone = 64,
    RepeatUntilOtherKeyPress = 128,
    CondHovered = 256,
    CondActive = 512,
    CondDefault_ = 768,
    LockThisFrame = 1024,
    LockUntilRelease = 2048,
    RouteFocused = 4096,
    RouteGlobalLow = 8192,
    RouteGlobal = 16384,
    RouteGlobalHigh = 32768,
    RouteAlways = 65536,
    RouteUnlessBgFocused = 131072,
    RepeatRateMask_ = 14,
    RepeatUntilMask_ = 240,
    RepeatMask_ = 255,
    CondMask_ = 768,
    RouteMask_ = 61440,
    SupportedByIsKeyPressed = 255,
    SupportedByIsMouseClicked = 1,
    SupportedByShortcut = 258303,
    SupportedBySetKeyOwner = 3072,
    SupportedBySetItemKeyOwner = 3840,
}
--------------------------InputSource----------------------------
---@enum InputSource
M.InputSource = {
    None = 0,
    Mouse = 1,
    Keyboard = 2,
    Gamepad = 3,
    Clipboard = 4,
    COUNT = 5,
}
--------------------------InputTextFlagsPrivate----------------------------
---@enum InputTextFlagsPrivate
M.InputTextFlagsPrivate = {
    Multiline = 67108864,
    NoMarkEdited = 134217728,
    MergedItem = 268435456,
}
--------------------------InputTextFlags----------------------------
---@enum InputTextFlags
M.InputTextFlags = {
    None = 0,
    CharsDecimal = 1,
    CharsHexadecimal = 2,
    CharsUppercase = 4,
    CharsNoBlank = 8,
    AutoSelectAll = 16,
    EnterReturnsTrue = 32,
    CallbackCompletion = 64,
    CallbackHistory = 128,
    CallbackAlways = 256,
    CallbackCharFilter = 512,
    AllowTabInput = 1024,
    CtrlEnterForNewLine = 2048,
    NoHorizontalScroll = 4096,
    AlwaysOverwrite = 8192,
    ReadOnly = 16384,
    Password = 32768,
    NoUndoRedo = 65536,
    CharsScientific = 131072,
    CallbackResize = 262144,
    CallbackEdit = 524288,
    EscapeClearsAll = 1048576,
}
--------------------------ItemFlags----------------------------
---@enum ItemFlags
M.ItemFlags = {
    None = 0,
    NoTabStop = 1,
    ButtonRepeat = 2,
    Disabled = 4,
    NoNav = 8,
    NoNavDefaultFocus = 16,
    SelectableDontClosePopup = 32,
    MixedValue = 64,
    ReadOnly = 128,
    NoWindowHoverableCheck = 256,
    AllowOverlap = 512,
    Inputable = 1024,
    HasSelectionUserData = 2048,
}
--------------------------ItemStatusFlags----------------------------
---@enum ItemStatusFlags
M.ItemStatusFlags = {
    None = 0,
    HoveredRect = 1,
    HasDisplayRect = 2,
    Edited = 4,
    ToggledSelection = 8,
    ToggledOpen = 16,
    HasDeactivated = 32,
    Deactivated = 64,
    HoveredWindow = 128,
    Visible = 256,
    HasClipRect = 512,
}
--------------------------Key----------------------------
---@enum Key
M.Key = {
    None = 0,
    Tab = 512,
    LeftArrow = 513,
    RightArrow = 514,
    UpArrow = 515,
    DownArrow = 516,
    PageUp = 517,
    PageDown = 518,
    Home = 519,
    End = 520,
    Insert = 521,
    Delete = 522,
    Backspace = 523,
    Space = 524,
    Enter = 525,
    Escape = 526,
    LeftCtrl = 527,
    LeftShift = 528,
    LeftAlt = 529,
    LeftSuper = 530,
    RightCtrl = 531,
    RightShift = 532,
    RightAlt = 533,
    RightSuper = 534,
    Menu = 535,
    _0 = 536,
    _1 = 537,
    _2 = 538,
    _3 = 539,
    _4 = 540,
    _5 = 541,
    _6 = 542,
    _7 = 543,
    _8 = 544,
    _9 = 545,
    A = 546,
    B = 547,
    C = 548,
    D = 549,
    E = 550,
    F = 551,
    G = 552,
    H = 553,
    I = 554,
    J = 555,
    K = 556,
    L = 557,
    M = 558,
    N = 559,
    O = 560,
    P = 561,
    Q = 562,
    R = 563,
    S = 564,
    T = 565,
    U = 566,
    V = 567,
    W = 568,
    X = 569,
    Y = 570,
    Z = 571,
    F1 = 572,
    F2 = 573,
    F3 = 574,
    F4 = 575,
    F5 = 576,
    F6 = 577,
    F7 = 578,
    F8 = 579,
    F9 = 580,
    F10 = 581,
    F11 = 582,
    F12 = 583,
    F13 = 584,
    F14 = 585,
    F15 = 586,
    F16 = 587,
    F17 = 588,
    F18 = 589,
    F19 = 590,
    F20 = 591,
    F21 = 592,
    F22 = 593,
    F23 = 594,
    F24 = 595,
    Apostrophe = 596,
    Comma = 597,
    Minus = 598,
    Period = 599,
    Slash = 600,
    Semicolon = 601,
    Equal = 602,
    LeftBracket = 603,
    Backslash = 604,
    RightBracket = 605,
    GraveAccent = 606,
    CapsLock = 607,
    ScrollLock = 608,
    NumLock = 609,
    PrintScreen = 610,
    Pause = 611,
    Keypad0 = 612,
    Keypad1 = 613,
    Keypad2 = 614,
    Keypad3 = 615,
    Keypad4 = 616,
    Keypad5 = 617,
    Keypad6 = 618,
    Keypad7 = 619,
    Keypad8 = 620,
    Keypad9 = 621,
    KeypadDecimal = 622,
    KeypadDivide = 623,
    KeypadMultiply = 624,
    KeypadSubtract = 625,
    KeypadAdd = 626,
    KeypadEnter = 627,
    KeypadEqual = 628,
    AppBack = 629,
    AppForward = 630,
    GamepadStart = 631,
    GamepadBack = 632,
    GamepadFaceLeft = 633,
    GamepadFaceRight = 634,
    GamepadFaceUp = 635,
    GamepadFaceDown = 636,
    GamepadDpadLeft = 637,
    GamepadDpadRight = 638,
    GamepadDpadUp = 639,
    GamepadDpadDown = 640,
    GamepadL1 = 641,
    GamepadR1 = 642,
    GamepadL2 = 643,
    GamepadR2 = 644,
    GamepadL3 = 645,
    GamepadR3 = 646,
    GamepadLStickLeft = 647,
    GamepadLStickRight = 648,
    GamepadLStickUp = 649,
    GamepadLStickDown = 650,
    GamepadRStickLeft = 651,
    GamepadRStickRight = 652,
    GamepadRStickUp = 653,
    GamepadRStickDown = 654,
    MouseLeft = 655,
    MouseRight = 656,
    MouseMiddle = 657,
    MouseX1 = 658,
    MouseX2 = 659,
    MouseWheelX = 660,
    MouseWheelY = 661,
    ReservedForModCtrl = 662,
    ReservedForModShift = 663,
    ReservedForModAlt = 664,
    ReservedForModSuper = 665,
    COUNT = 666,
    ImGuiMod_None = 0,
    ImGuiMod_Ctrl = 4096,
    ImGuiMod_Shift = 8192,
    ImGuiMod_Alt = 16384,
    ImGuiMod_Super = 32768,
    ImGuiMod_Shortcut = 2048,
    ImGuiMod_Mask_ = 63488,
    NamedKey_BEGIN = 512,
    NamedKey_END = 666,
    NamedKey_COUNT = 154,
    KeysData_SIZE = 154,
    KeysData_OFFSET = 512,
}
--------------------------LayoutType----------------------------
---@enum LayoutType
M.LayoutType = {
    Horizontal = 0,
    Vertical = 1,
}
--------------------------LocKey----------------------------
---@enum LocKey
M.LocKey = {
    VersionStr = 0,
    TableSizeOne = 1,
    TableSizeAllFit = 2,
    TableSizeAllDefault = 3,
    TableResetOrder = 4,
    WindowingMainMenuBar = 5,
    WindowingPopup = 6,
    WindowingUntitled = 7,
    DockingHideTabBar = 8,
    DockingHoldShiftToDock = 9,
    DockingDragToUndockOrMoveNode = 10,
    COUNT = 11,
}
--------------------------LogType----------------------------
---@enum LogType
M.LogType = {
    None = 0,
    TTY = 1,
    File = 2,
    Buffer = 3,
    Clipboard = 4,
}
--------------------------MouseButton----------------------------
---@enum MouseButton
M.MouseButton = {
    Left = 0,
    Right = 1,
    Middle = 2,
    COUNT = 5,
}
--------------------------MouseCursor----------------------------
---@enum MouseCursor
M.MouseCursor = {
    None = -1,
    Arrow = 0,
    TextInput = 1,
    ResizeAll = 2,
    ResizeNS = 3,
    ResizeEW = 4,
    ResizeNESW = 5,
    ResizeNWSE = 6,
    Hand = 7,
    NotAllowed = 8,
    COUNT = 9,
}
--------------------------MouseSource----------------------------
---@enum MouseSource
M.MouseSource = {
    Mouse = 0,
    TouchScreen = 1,
    Pen = 2,
    COUNT = 3,
}
--------------------------NavHighlightFlags----------------------------
---@enum NavHighlightFlags
M.NavHighlightFlags = {
    None = 0,
    Compact = 2,
    AlwaysDraw = 4,
    NoRounding = 8,
}
--------------------------NavLayer----------------------------
---@enum NavLayer
M.NavLayer = {
    Main = 0,
    Menu = 1,
    COUNT = 2,
}
--------------------------NavMoveFlags----------------------------
---@enum NavMoveFlags
M.NavMoveFlags = {
    None = 0,
    LoopX = 1,
    LoopY = 2,
    WrapX = 4,
    WrapY = 8,
    WrapMask_ = 15,
    AllowCurrentNavId = 16,
    AlsoScoreVisibleSet = 32,
    ScrollToEdgeY = 64,
    Forwarded = 128,
    DebugNoResult = 256,
    FocusApi = 512,
    IsTabbing = 1024,
    IsPageMove = 2048,
    Activate = 4096,
    NoSelect = 8192,
    NoSetNavHighlight = 16384,
}
--------------------------NextItemDataFlags----------------------------
---@enum NextItemDataFlags
M.NextItemDataFlags = {
    None = 0,
    HasWidth = 1,
    HasOpen = 2,
    HasShortcut = 4,
}
--------------------------NextWindowDataFlags----------------------------
---@enum NextWindowDataFlags
M.NextWindowDataFlags = {
    None = 0,
    HasPos = 1,
    HasSize = 2,
    HasContentSize = 4,
    HasCollapsed = 8,
    HasSizeConstraint = 16,
    HasFocus = 32,
    HasBgAlpha = 64,
    HasScroll = 128,
    HasChildFlags = 256,
    HasViewport = 512,
    HasDock = 1024,
    HasWindowClass = 2048,
}
--------------------------OldColumnFlags----------------------------
---@enum OldColumnFlags
M.OldColumnFlags = {
    None = 0,
    NoBorder = 1,
    NoResize = 2,
    NoPreserveWidths = 4,
    NoForceWithinWindow = 8,
    GrowParentContentsSize = 16,
}
--------------------------PlotType----------------------------
---@enum PlotType
M.PlotType = {
    Lines = 0,
    Histogram = 1,
}
--------------------------PopupFlags----------------------------
---@enum PopupFlags
M.PopupFlags = {
    None = 0,
    MouseButtonLeft = 0,
    MouseButtonRight = 1,
    MouseButtonMiddle = 2,
    MouseButtonMask_ = 31,
    MouseButtonDefault_ = 1,
    NoReopen = 32,
    NoOpenOverExistingPopup = 128,
    NoOpenOverItems = 256,
    AnyPopupId = 1024,
    AnyPopupLevel = 2048,
    AnyPopup = 3072,
}
--------------------------PopupPositionPolicy----------------------------
---@enum PopupPositionPolicy
M.PopupPositionPolicy = {
    Default = 0,
    ComboBox = 1,
    Tooltip = 2,
}
--------------------------ScrollFlags----------------------------
---@enum ScrollFlags
M.ScrollFlags = {
    None = 0,
    KeepVisibleEdgeX = 1,
    KeepVisibleEdgeY = 2,
    KeepVisibleCenterX = 4,
    KeepVisibleCenterY = 8,
    AlwaysCenterX = 16,
    AlwaysCenterY = 32,
    NoScrollParent = 64,
    MaskX_ = 21,
    MaskY_ = 42,
}
--------------------------SelectableFlagsPrivate----------------------------
---@enum SelectableFlagsPrivate
M.SelectableFlagsPrivate = {
    NoHoldingActiveID = 1048576,
    SelectOnNav = 2097152,
    SelectOnClick = 4194304,
    SelectOnRelease = 8388608,
    SpanAvailWidth = 16777216,
    SetNavIdOnHover = 33554432,
    NoPadWithHalfSpacing = 67108864,
    NoSetKeyOwner = 134217728,
}
--------------------------SelectableFlags----------------------------
---@enum SelectableFlags
M.SelectableFlags = {
    None = 0,
    DontClosePopups = 1,
    SpanAllColumns = 2,
    AllowDoubleClick = 4,
    Disabled = 8,
    AllowOverlap = 16,
}
--------------------------SeparatorFlags----------------------------
---@enum SeparatorFlags
M.SeparatorFlags = {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    SpanAllColumns = 4,
}
--------------------------SliderFlagsPrivate----------------------------
---@enum SliderFlagsPrivate
M.SliderFlagsPrivate = {
    Vertical = 1048576,
    ReadOnly = 2097152,
}
--------------------------SliderFlags----------------------------
---@enum SliderFlags
M.SliderFlags = {
    None = 0,
    AlwaysClamp = 16,
    Logarithmic = 32,
    NoRoundToFormat = 64,
    NoInput = 128,
    InvalidMask_ = 1879048207,
}
--------------------------SortDirection----------------------------
---@enum SortDirection
M.SortDirection = {
    None = 0,
    Ascending = 1,
    Descending = 2,
}
--------------------------StyleVar----------------------------
---@enum StyleVar
M.StyleVar = {
    Alpha = 0,
    DisabledAlpha = 1,
    WindowPadding = 2,
    WindowRounding = 3,
    WindowBorderSize = 4,
    WindowMinSize = 5,
    WindowTitleAlign = 6,
    ChildRounding = 7,
    ChildBorderSize = 8,
    PopupRounding = 9,
    PopupBorderSize = 10,
    FramePadding = 11,
    FrameRounding = 12,
    FrameBorderSize = 13,
    ItemSpacing = 14,
    ItemInnerSpacing = 15,
    IndentSpacing = 16,
    CellPadding = 17,
    ScrollbarSize = 18,
    ScrollbarRounding = 19,
    GrabMinSize = 20,
    GrabRounding = 21,
    TabRounding = 22,
    TabBarBorderSize = 23,
    ButtonTextAlign = 24,
    SelectableTextAlign = 25,
    SeparatorTextBorderSize = 26,
    SeparatorTextAlign = 27,
    SeparatorTextPadding = 28,
    DockingSeparatorSize = 29,
    COUNT = 30,
}
--------------------------TabBarFlagsPrivate----------------------------
---@enum TabBarFlagsPrivate
M.TabBarFlagsPrivate = {
    DockNode = 1048576,
    IsFocused = 2097152,
    SaveSettings = 4194304,
}
--------------------------TabBarFlags----------------------------
---@enum TabBarFlags
M.TabBarFlags = {
    None = 0,
    Reorderable = 1,
    AutoSelectNewTabs = 2,
    TabListPopupButton = 4,
    NoCloseWithMiddleMouseButton = 8,
    NoTabListScrollingButtons = 16,
    NoTooltip = 32,
    FittingPolicyResizeDown = 64,
    FittingPolicyScroll = 128,
    FittingPolicyMask_ = 192,
    FittingPolicyDefault_ = 64,
}
--------------------------TabItemFlagsPrivate----------------------------
---@enum TabItemFlagsPrivate
M.TabItemFlagsPrivate = {
    SectionMask_ = 192,
    NoCloseButton = 1048576,
    Button = 2097152,
    Unsorted = 4194304,
}
--------------------------TabItemFlags----------------------------
---@enum TabItemFlags
M.TabItemFlags = {
    None = 0,
    UnsavedDocument = 1,
    SetSelected = 2,
    NoCloseWithMiddleMouseButton = 4,
    NoPushId = 8,
    NoTooltip = 16,
    NoReorder = 32,
    Leading = 64,
    Trailing = 128,
    NoAssumedClosure = 256,
}
--------------------------TableBgTarget----------------------------
---@enum TableBgTarget
M.TableBgTarget = {
    None = 0,
    RowBg0 = 1,
    RowBg1 = 2,
    CellBg = 3,
}
--------------------------TableColumnFlags----------------------------
---@enum TableColumnFlags
M.TableColumnFlags = {
    None = 0,
    Disabled = 1,
    DefaultHide = 2,
    DefaultSort = 4,
    WidthStretch = 8,
    WidthFixed = 16,
    NoResize = 32,
    NoReorder = 64,
    NoHide = 128,
    NoClip = 256,
    NoSort = 512,
    NoSortAscending = 1024,
    NoSortDescending = 2048,
    NoHeaderLabel = 4096,
    NoHeaderWidth = 8192,
    PreferSortAscending = 16384,
    PreferSortDescending = 32768,
    IndentEnable = 65536,
    IndentDisable = 131072,
    AngledHeader = 262144,
    IsEnabled = 16777216,
    IsVisible = 33554432,
    IsSorted = 67108864,
    IsHovered = 134217728,
    WidthMask_ = 24,
    IndentMask_ = 196608,
    StatusMask_ = 251658240,
    NoDirectResize_ = 1073741824,
}
--------------------------TableFlags----------------------------
---@enum TableFlags
M.TableFlags = {
    None = 0,
    Resizable = 1,
    Reorderable = 2,
    Hideable = 4,
    Sortable = 8,
    NoSavedSettings = 16,
    ContextMenuInBody = 32,
    RowBg = 64,
    BordersInnerH = 128,
    BordersOuterH = 256,
    BordersInnerV = 512,
    BordersOuterV = 1024,
    BordersH = 384,
    BordersV = 1536,
    BordersInner = 640,
    BordersOuter = 1280,
    Borders = 1920,
    NoBordersInBody = 2048,
    NoBordersInBodyUntilResize = 4096,
    SizingFixedFit = 8192,
    SizingFixedSame = 16384,
    SizingStretchProp = 24576,
    SizingStretchSame = 32768,
    NoHostExtendX = 65536,
    NoHostExtendY = 131072,
    NoKeepColumnsVisible = 262144,
    PreciseWidths = 524288,
    NoClip = 1048576,
    PadOuterX = 2097152,
    NoPadOuterX = 4194304,
    NoPadInnerX = 8388608,
    ScrollX = 16777216,
    ScrollY = 33554432,
    SortMulti = 67108864,
    SortTristate = 134217728,
    HighlightHoveredColumn = 268435456,
    SizingMask_ = 57344,
}
--------------------------TableRowFlags----------------------------
---@enum TableRowFlags
M.TableRowFlags = {
    None = 0,
    Headers = 1,
}
--------------------------TextFlags----------------------------
---@enum TextFlags
M.TextFlags = {
    None = 0,
    NoWidthForLargeClippedText = 1,
}
--------------------------TooltipFlags----------------------------
---@enum TooltipFlags
M.TooltipFlags = {
    None = 0,
    OverridePrevious = 2,
}
--------------------------TreeNodeFlagsPrivate----------------------------
---@enum TreeNodeFlagsPrivate
M.TreeNodeFlagsPrivate = {
    ClipLabelForTrailingButton = 1048576,
    UpsideDownArrow = 2097152,
}
--------------------------TreeNodeFlags----------------------------
---@enum TreeNodeFlags
M.TreeNodeFlags = {
    None = 0,
    Selected = 1,
    Framed = 2,
    AllowOverlap = 4,
    NoTreePushOnOpen = 8,
    NoAutoOpenOnLog = 16,
    DefaultOpen = 32,
    OpenOnDoubleClick = 64,
    OpenOnArrow = 128,
    Leaf = 256,
    Bullet = 512,
    FramePadding = 1024,
    SpanAvailWidth = 2048,
    SpanFullWidth = 4096,
    SpanAllColumns = 8192,
    NavLeftJumpsBackHere = 16384,
    CollapsingHeader = 26,
}
--------------------------TypingSelectFlags----------------------------
---@enum TypingSelectFlags
M.TypingSelectFlags = {
    None = 0,
    AllowBackspace = 1,
    AllowSingleCharMode = 2,
}
--------------------------ViewportFlags----------------------------
---@enum ViewportFlags
M.ViewportFlags = {
    None = 0,
    IsPlatformWindow = 1,
    IsPlatformMonitor = 2,
    OwnedByApp = 4,
    NoDecoration = 8,
    NoTaskBarIcon = 16,
    NoFocusOnAppearing = 32,
    NoFocusOnClick = 64,
    NoInputs = 128,
    NoRendererClear = 256,
    NoAutoMerge = 512,
    TopMost = 1024,
    CanHostOtherWindows = 2048,
    IsMinimized = 4096,
    IsFocused = 8192,
}
--------------------------WindowDockStyleCol----------------------------
---@enum WindowDockStyleCol
M.WindowDockStyleCol = {
    Text = 0,
    Tab = 1,
    TabHovered = 2,
    TabActive = 3,
    TabUnfocused = 4,
    TabUnfocusedActive = 5,
    COUNT = 6,
}
--------------------------WindowFlags----------------------------
---@enum WindowFlags
M.WindowFlags = {
    None = 0,
    NoTitleBar = 1,
    NoResize = 2,
    NoMove = 4,
    NoScrollbar = 8,
    NoScrollWithMouse = 16,
    NoCollapse = 32,
    AlwaysAutoResize = 64,
    NoBackground = 128,
    NoSavedSettings = 256,
    NoMouseInputs = 512,
    MenuBar = 1024,
    HorizontalScrollbar = 2048,
    NoFocusOnAppearing = 4096,
    NoBringToFrontOnFocus = 8192,
    AlwaysVerticalScrollbar = 16384,
    AlwaysHorizontalScrollbar = 32768,
    NoNavInputs = 65536,
    NoNavFocus = 131072,
    UnsavedDocument = 262144,
    NoDocking = 524288,
    NoNav = 196608,
    NoDecoration = 43,
    NoInputs = 197120,
    NavFlattened = 8388608,
    ChildWindow = 16777216,
    Tooltip = 33554432,
    Popup = 67108864,
    Modal = 134217728,
    ChildMenu = 268435456,
    DockNodeHost = 536870912,
}
--------------------------ImBitVector----------------------------
---@class ImBitVector
local ImBitVector= {}
ImBitVector.__index = ImBitVector
---@param self ffi.ct* ImBitVector*
---@return nil
function ImBitVector:Clear()
    return lib.ImBitVector_Clear(self)
end
---@param self ffi.ct* ImBitVector*
---@param n number int
---@return nil
function ImBitVector:ClearBit(n)
    return lib.ImBitVector_ClearBit(self,n)
end
---@param self ffi.ct* ImBitVector*
---@param sz number int
---@return nil
function ImBitVector:Create(sz)
    return lib.ImBitVector_Create(self,sz)
end
---@param self ffi.ct* ImBitVector*
---@param n number int
---@return nil
function ImBitVector:SetBit(n)
    return lib.ImBitVector_SetBit(self,n)
end
---@param self ffi.ct* ImBitVector*
---@param n number int
---@return boolean
function ImBitVector:TestBit(n)
    return lib.ImBitVector_TestBit(self,n)
end
M.ImBitVector = ffi.metatype("ImBitVector",ImBitVector)
--------------------------ImColor----------------------------
---@class ImColor
local ImColor= {}
ImColor.__index = ImColor
---@param h number float
---@param s number float
---@param v number float
---@param a number? float
---@return nil
function M.ImColor_HSV(h,s,v,a)
    a = a or 1.0
    local nonUDT_out = ffi.new("ImColor")
    lib.ImColor_HSV(nonUDT_out,h,s,v,a)
    return nonUDT_out
end
function ImColor.ImColor_Nil()
    local ptr = lib.ImColor_ImColor_Nil()
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Float(r,g,b,a)
    if a == nil then a = 1.0 end
    local ptr = lib.ImColor_ImColor_Float(r,g,b,a)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Vec4(col)
    local ptr = lib.ImColor_ImColor_Vec4(col)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_Int(r,g,b,a)
    if a == nil then a = 255 end
    local ptr = lib.ImColor_ImColor_Int(r,g,b,a)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.ImColor_U32(rgba)
    local ptr = lib.ImColor_ImColor_U32(rgba)
    return ffi.gc(ptr,lib.ImColor_destroy)
end
function ImColor.__new(ctype,a1,a2,a3,a4) -- generic version
    if a1==nil then return ImColor.ImColor_Nil() end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImColor.ImColor_Float(a1,a2,a3,a4) end
    if ffi.istype('const ImVec4',a1) then return ImColor.ImColor_Vec4(a1) end
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return ImColor.ImColor_Int(a1,a2,a3,a4) end
    if (ffi.istype('uint32_t',a1) or type(a1)=='number') then return ImColor.ImColor_U32(a1) end
    print(ctype,a1,a2,a3,a4)
    error'ImColor.__new could not find overloaded'
end
---@param self ffi.ct* ImColor*
---@param h number float
---@param s number float
---@param v number float
---@param a number? float
---@return nil
function ImColor:SetHSV(h,s,v,a)
    a = a or 1.0
    return lib.ImColor_SetHSV(self,h,s,v,a)
end
M.ImColor = ffi.metatype("ImColor",ImColor)
--------------------------ImDrawCmd----------------------------
---@class ImDrawCmd
local ImDrawCmd= {}
ImDrawCmd.__index = ImDrawCmd
---@param self ffi.ct* ImDrawCmd*
---@return number ImTextureID
function ImDrawCmd:GetTexID()
    return lib.ImDrawCmd_GetTexID(self)
end
function ImDrawCmd.__new(ctype)
    local ptr = lib.ImDrawCmd_ImDrawCmd()
    return ffi.gc(ptr,lib.ImDrawCmd_destroy)
end
M.ImDrawCmd = ffi.metatype("ImDrawCmd",ImDrawCmd)
--------------------------ImDrawData----------------------------
---@class ImDrawData
local ImDrawData= {}
ImDrawData.__index = ImDrawData
---@param self ffi.ct* ImDrawData*
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function ImDrawData:AddDrawList(draw_list)
    return lib.ImDrawData_AddDrawList(self,draw_list)
end
---@param self ffi.ct* ImDrawData*
---@return nil
function ImDrawData:Clear()
    return lib.ImDrawData_Clear(self)
end
---@param self ffi.ct* ImDrawData*
---@return nil
function ImDrawData:DeIndexAllBuffers()
    return lib.ImDrawData_DeIndexAllBuffers(self)
end
function ImDrawData.__new(ctype)
    local ptr = lib.ImDrawData_ImDrawData()
    return ffi.gc(ptr,lib.ImDrawData_destroy)
end
---@param self ffi.ct* ImDrawData*
---@param fb_scale ImVec2
---@return nil
function ImDrawData:ScaleClipRects(fb_scale)
    return lib.ImDrawData_ScaleClipRects(self,fb_scale)
end
M.ImDrawData = ffi.metatype("ImDrawData",ImDrawData)
--------------------------ImDrawDataBuilder----------------------------
---@class ImDrawDataBuilder
local ImDrawDataBuilder= {}
ImDrawDataBuilder.__index = ImDrawDataBuilder
function ImDrawDataBuilder.__new(ctype)
    local ptr = lib.ImDrawDataBuilder_ImDrawDataBuilder()
    return ffi.gc(ptr,lib.ImDrawDataBuilder_destroy)
end
M.ImDrawDataBuilder = ffi.metatype("ImDrawDataBuilder",ImDrawDataBuilder)
--------------------------ImDrawList----------------------------
---@class ImDrawList
local ImDrawList= {}
ImDrawList.__index = ImDrawList
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number ImU32
---@param thickness number float
---@param num_segments number? int
---@return nil
function ImDrawList:AddBezierCubic(p1,p2,p3,p4,col,thickness,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddBezierCubic(self,p1,p2,p3,p4,col,thickness,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number ImU32
---@param thickness number float
---@param num_segments number? int
---@return nil
function ImDrawList:AddBezierQuadratic(p1,p2,p3,col,thickness,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddBezierQuadratic(self,p1,p2,p3,col,thickness,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param callback ffi.ct* ImDrawCallback
---@param callback_data ffi.ct* void*
---@return nil
function ImDrawList:AddCallback(callback,callback_data)
    return lib.ImDrawList_AddCallback(self,callback,callback_data)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param col number ImU32
---@param num_segments number? int
---@param thickness number? float
---@return nil
function ImDrawList:AddCircle(center,radius,col,num_segments,thickness)
    num_segments = num_segments or 0
    thickness = thickness or 1.0
    return lib.ImDrawList_AddCircle(self,center,radius,col,num_segments,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param col number ImU32
---@param num_segments number? int
---@return nil
function ImDrawList:AddCircleFilled(center,radius,col,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_AddCircleFilled(self,center,radius,col,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param points ffi.ct* const ImVec2*
---@param num_points number int
---@param col number ImU32
---@return nil
function ImDrawList:AddConvexPolyFilled(points,num_points,col)
    return lib.ImDrawList_AddConvexPolyFilled(self,points,num_points,col)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:AddDrawCmd()
    return lib.ImDrawList_AddDrawCmd(self)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius_x number float
---@param radius_y number float
---@param col number ImU32
---@param rot number? float
---@param num_segments number? int
---@param thickness number? float
---@return nil
function ImDrawList:AddEllipse(center,radius_x,radius_y,col,rot,num_segments,thickness)
    num_segments = num_segments or 0
    rot = rot or 0.0
    thickness = thickness or 1.0
    return lib.ImDrawList_AddEllipse(self,center,radius_x,radius_y,col,rot,num_segments,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius_x number float
---@param radius_y number float
---@param col number ImU32
---@param rot number? float
---@param num_segments number? int
---@return nil
function ImDrawList:AddEllipseFilled(center,radius_x,radius_y,col,rot,num_segments)
    num_segments = num_segments or 0
    rot = rot or 0.0
    return lib.ImDrawList_AddEllipseFilled(self,center,radius_x,radius_y,col,rot,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id number ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2?
---@param uv_max ImVec2?
---@param col number? ImU32
---@return nil
function ImDrawList:AddImage(user_texture_id,p_min,p_max,uv_min,uv_max,col)
    col = col or 4294967295
    uv_max = uv_max or ImVec2(1,1)
    uv_min = uv_min or ImVec2(0,0)
    return lib.ImDrawList_AddImage(self,user_texture_id,p_min,p_max,uv_min,uv_max,col)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id number ImTextureID
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param uv1 ImVec2?
---@param uv2 ImVec2?
---@param uv3 ImVec2?
---@param uv4 ImVec2?
---@param col number? ImU32
---@return nil
function ImDrawList:AddImageQuad(user_texture_id,p1,p2,p3,p4,uv1,uv2,uv3,uv4,col)
    col = col or 4294967295
    uv1 = uv1 or ImVec2(0,0)
    uv2 = uv2 or ImVec2(1,0)
    uv3 = uv3 or ImVec2(1,1)
    uv4 = uv4 or ImVec2(0,1)
    return lib.ImDrawList_AddImageQuad(self,user_texture_id,p1,p2,p3,p4,uv1,uv2,uv3,uv4,col)
end
---@param self ffi.ct* ImDrawList*
---@param user_texture_id number ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2
---@param uv_max ImVec2
---@param col number ImU32
---@param rounding number float
---@param flags ImDrawFlags?
---@return nil
function ImDrawList:AddImageRounded(user_texture_id,p_min,p_max,uv_min,uv_max,col,rounding,flags)
    flags = flags or 0
    return lib.ImDrawList_AddImageRounded(self,user_texture_id,p_min,p_max,uv_min,uv_max,col,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param col number ImU32
---@param thickness number? float
---@return nil
function ImDrawList:AddLine(p1,p2,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddLine(self,p1,p2,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param col number ImU32
---@param num_segments number int
---@param thickness number? float
---@return nil
function ImDrawList:AddNgon(center,radius,col,num_segments,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddNgon(self,center,radius,col,num_segments,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param col number ImU32
---@param num_segments number int
---@return nil
function ImDrawList:AddNgonFilled(center,radius,col,num_segments)
    return lib.ImDrawList_AddNgonFilled(self,center,radius,col,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param points ffi.ct* const ImVec2*
---@param num_points number int
---@param col number ImU32
---@param flags ImDrawFlags
---@param thickness number float
---@return nil
function ImDrawList:AddPolyline(points,num_points,col,flags,thickness)
    return lib.ImDrawList_AddPolyline(self,points,num_points,col,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number ImU32
---@param thickness number? float
---@return nil
function ImDrawList:AddQuad(p1,p2,p3,p4,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddQuad(self,p1,p2,p3,p4,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:AddQuadFilled(p1,p2,p3,p4,col)
    return lib.ImDrawList_AddQuadFilled(self,p1,p2,p3,p4,col)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col number ImU32
---@param rounding number? float
---@param flags ImDrawFlags?
---@param thickness number? float
---@return nil
function ImDrawList:AddRect(p_min,p_max,col,rounding,flags,thickness)
    flags = flags or 0
    rounding = rounding or 0.0
    thickness = thickness or 1.0
    return lib.ImDrawList_AddRect(self,p_min,p_max,col,rounding,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col number ImU32
---@param rounding number? float
---@param flags ImDrawFlags?
---@return nil
function ImDrawList:AddRectFilled(p_min,p_max,col,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.ImDrawList_AddRectFilled(self,p_min,p_max,col,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col_upr_left number ImU32
---@param col_upr_right number ImU32
---@param col_bot_right number ImU32
---@param col_bot_left number ImU32
---@return nil
function ImDrawList:AddRectFilledMultiColor(p_min,p_max,col_upr_left,col_upr_right,col_bot_right,col_bot_left)
    return lib.ImDrawList_AddRectFilledMultiColor(self,p_min,p_max,col_upr_left,col_upr_right,col_bot_right,col_bot_left)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number ImU32
---@param text_begin string
---@param text_end string?
---@return nil
function ImDrawList:AddText_Vec2(pos,col,text_begin,text_end)
    text_end = text_end or nil
    return lib.ImDrawList_AddText_Vec2(self,pos,col,text_begin,text_end)
end
---@param self ffi.ct* ImDrawList*
---@param font ffi.ct* const ImFont*
---@param font_size number float
---@param pos ImVec2
---@param col number ImU32
---@param text_begin string
---@param text_end string?
---@param wrap_width number? float
---@param cpu_fine_clip_rect ffi.ct*? const ImVec4*
---@return nil
function ImDrawList:AddText_FontPtr(font,font_size,pos,col,text_begin,text_end,wrap_width,cpu_fine_clip_rect)
    cpu_fine_clip_rect = cpu_fine_clip_rect or nil
    text_end = text_end or nil
    wrap_width = wrap_width or 0.0
    return lib.ImDrawList_AddText_FontPtr(self,font,font_size,pos,col,text_begin,text_end,wrap_width,cpu_fine_clip_rect)
end
function ImDrawList:AddText(a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:AddText_Vec2(a2,a3,a4,a5) end
    if (ffi.istype('const ImFont*',a2) or ffi.istype('const ImFont',a2) or ffi.istype('const ImFont[]',a2)) then return self:AddText_FontPtr(a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a2,a3,a4,a5,a6,a7,a8,a9)
    error'ImDrawList:AddText could not find overloaded'
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number ImU32
---@param thickness number? float
---@return nil
function ImDrawList:AddTriangle(p1,p2,p3,col,thickness)
    thickness = thickness or 1.0
    return lib.ImDrawList_AddTriangle(self,p1,p2,p3,col,thickness)
end
---@param self ffi.ct* ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:AddTriangleFilled(p1,p2,p3,col)
    return lib.ImDrawList_AddTriangleFilled(self,p1,p2,p3,col)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:ChannelsMerge()
    return lib.ImDrawList_ChannelsMerge(self)
end
---@param self ffi.ct* ImDrawList*
---@param n number int
---@return nil
function ImDrawList:ChannelsSetCurrent(n)
    return lib.ImDrawList_ChannelsSetCurrent(self,n)
end
---@param self ffi.ct* ImDrawList*
---@param count number int
---@return nil
function ImDrawList:ChannelsSplit(count)
    return lib.ImDrawList_ChannelsSplit(self,count)
end
---@param self ffi.ct* ImDrawList*
---@return ffi.ct* ImDrawList*
function ImDrawList:CloneOutput()
    return lib.ImDrawList_CloneOutput(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:GetClipRectMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImDrawList_GetClipRectMax(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:GetClipRectMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImDrawList_GetClipRectMin(nonUDT_out,self)
    return nonUDT_out
end
function ImDrawList.__new(ctype,shared_data)
    local ptr = lib.ImDrawList_ImDrawList(shared_data)
    return ffi.gc(ptr,lib.ImDrawList_destroy)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param a_min number float
---@param a_max number float
---@param num_segments number? int
---@return nil
function ImDrawList:PathArcTo(center,radius,a_min,a_max,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathArcTo(self,center,radius,a_min,a_max,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param a_min_of_12 number int
---@param a_max_of_12 number int
---@return nil
function ImDrawList:PathArcToFast(center,radius,a_min_of_12,a_max_of_12)
    return lib.ImDrawList_PathArcToFast(self,center,radius,a_min_of_12,a_max_of_12)
end
---@param self ffi.ct* ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param num_segments number? int
---@return nil
function ImDrawList:PathBezierCubicCurveTo(p2,p3,p4,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathBezierCubicCurveTo(self,p2,p3,p4,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param num_segments number? int
---@return nil
function ImDrawList:PathBezierQuadraticCurveTo(p2,p3,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathBezierQuadraticCurveTo(self,p2,p3,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PathClear()
    return lib.ImDrawList_PathClear(self)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius_x number float
---@param radius_y number float
---@param rot number float
---@param a_min number float
---@param a_max number float
---@param num_segments number? int
---@return nil
function ImDrawList:PathEllipticalArcTo(center,radius_x,radius_y,rot,a_min,a_max,num_segments)
    num_segments = num_segments or 0
    return lib.ImDrawList_PathEllipticalArcTo(self,center,radius_x,radius_y,rot,a_min,a_max,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@param col number ImU32
---@return nil
function ImDrawList:PathFillConvex(col)
    return lib.ImDrawList_PathFillConvex(self,col)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@return nil
function ImDrawList:PathLineTo(pos)
    return lib.ImDrawList_PathLineTo(self,pos)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@return nil
function ImDrawList:PathLineToMergeDuplicate(pos)
    return lib.ImDrawList_PathLineToMergeDuplicate(self,pos)
end
---@param self ffi.ct* ImDrawList*
---@param rect_min ImVec2
---@param rect_max ImVec2
---@param rounding number? float
---@param flags ImDrawFlags?
---@return nil
function ImDrawList:PathRect(rect_min,rect_max,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.ImDrawList_PathRect(self,rect_min,rect_max,rounding,flags)
end
---@param self ffi.ct* ImDrawList*
---@param col number ImU32
---@param flags ImDrawFlags?
---@param thickness number? float
---@return nil
function ImDrawList:PathStroke(col,flags,thickness)
    flags = flags or 0
    thickness = thickness or 1.0
    return lib.ImDrawList_PathStroke(self,col,flags,thickness)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PopClipRect()
    return lib.ImDrawList_PopClipRect(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PopTextureID()
    return lib.ImDrawList_PopTextureID(self)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param d ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param uv_c ImVec2
---@param uv_d ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:PrimQuadUV(a,b,c,d,uv_a,uv_b,uv_c,uv_d,col)
    return lib.ImDrawList_PrimQuadUV(self,a,b,c,d,uv_a,uv_b,uv_c,uv_d,col)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:PrimRect(a,b,col)
    return lib.ImDrawList_PrimRect(self,a,b,col)
end
---@param self ffi.ct* ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:PrimRectUV(a,b,uv_a,uv_b,col)
    return lib.ImDrawList_PrimRectUV(self,a,b,uv_a,uv_b,col)
end
---@param self ffi.ct* ImDrawList*
---@param idx_count number int
---@param vtx_count number int
---@return nil
function ImDrawList:PrimReserve(idx_count,vtx_count)
    return lib.ImDrawList_PrimReserve(self,idx_count,vtx_count)
end
---@param self ffi.ct* ImDrawList*
---@param idx_count number int
---@param vtx_count number int
---@return nil
function ImDrawList:PrimUnreserve(idx_count,vtx_count)
    return lib.ImDrawList_PrimUnreserve(self,idx_count,vtx_count)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:PrimVtx(pos,uv,col)
    return lib.ImDrawList_PrimVtx(self,pos,uv,col)
end
---@param self ffi.ct* ImDrawList*
---@param idx number ImDrawIdx
---@return nil
function ImDrawList:PrimWriteIdx(idx)
    return lib.ImDrawList_PrimWriteIdx(self,idx)
end
---@param self ffi.ct* ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col number ImU32
---@return nil
function ImDrawList:PrimWriteVtx(pos,uv,col)
    return lib.ImDrawList_PrimWriteVtx(self,pos,uv,col)
end
---@param self ffi.ct* ImDrawList*
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect boolean?
---@return nil
function ImDrawList:PushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
    intersect_with_current_clip_rect = intersect_with_current_clip_rect or false
    return lib.ImDrawList_PushClipRect(self,clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:PushClipRectFullScreen()
    return lib.ImDrawList_PushClipRectFullScreen(self)
end
---@param self ffi.ct* ImDrawList*
---@param texture_id number ImTextureID
---@return nil
function ImDrawList:PushTextureID(texture_id)
    return lib.ImDrawList_PushTextureID(self,texture_id)
end
---@param self ffi.ct* ImDrawList*
---@param radius number float
---@return number int
function ImDrawList:_CalcCircleAutoSegmentCount(radius)
    return lib.ImDrawList__CalcCircleAutoSegmentCount(self,radius)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_ClearFreeMemory()
    return lib.ImDrawList__ClearFreeMemory(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedClipRect()
    return lib.ImDrawList__OnChangedClipRect(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedTextureID()
    return lib.ImDrawList__OnChangedTextureID(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_OnChangedVtxOffset()
    return lib.ImDrawList__OnChangedVtxOffset(self)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param a_min_sample number int
---@param a_max_sample number int
---@param a_step number int
---@return nil
function ImDrawList:_PathArcToFastEx(center,radius,a_min_sample,a_max_sample,a_step)
    return lib.ImDrawList__PathArcToFastEx(self,center,radius,a_min_sample,a_max_sample,a_step)
end
---@param self ffi.ct* ImDrawList*
---@param center ImVec2
---@param radius number float
---@param a_min number float
---@param a_max number float
---@param num_segments number int
---@return nil
function ImDrawList:_PathArcToN(center,radius,a_min,a_max,num_segments)
    return lib.ImDrawList__PathArcToN(self,center,radius,a_min,a_max,num_segments)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_PopUnusedDrawCmd()
    return lib.ImDrawList__PopUnusedDrawCmd(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_ResetForNewFrame()
    return lib.ImDrawList__ResetForNewFrame(self)
end
---@param self ffi.ct* ImDrawList*
---@return nil
function ImDrawList:_TryMergeDrawCmds()
    return lib.ImDrawList__TryMergeDrawCmds(self)
end
M.ImDrawList = ffi.metatype("ImDrawList",ImDrawList)
--------------------------ImDrawListSharedData----------------------------
---@class ImDrawListSharedData
local ImDrawListSharedData= {}
ImDrawListSharedData.__index = ImDrawListSharedData
function ImDrawListSharedData.__new(ctype)
    local ptr = lib.ImDrawListSharedData_ImDrawListSharedData()
    return ffi.gc(ptr,lib.ImDrawListSharedData_destroy)
end
---@param self ffi.ct* ImDrawListSharedData*
---@param max_error number float
---@return nil
function ImDrawListSharedData:SetCircleTessellationMaxError(max_error)
    return lib.ImDrawListSharedData_SetCircleTessellationMaxError(self,max_error)
end
M.ImDrawListSharedData = ffi.metatype("ImDrawListSharedData",ImDrawListSharedData)
--------------------------ImDrawListSplitter----------------------------
---@class ImDrawListSplitter
local ImDrawListSplitter= {}
ImDrawListSplitter.__index = ImDrawListSplitter
---@param self ffi.ct* ImDrawListSplitter*
---@return nil
function ImDrawListSplitter:Clear()
    return lib.ImDrawListSplitter_Clear(self)
end
---@param self ffi.ct* ImDrawListSplitter*
---@return nil
function ImDrawListSplitter:ClearFreeMemory()
    return lib.ImDrawListSplitter_ClearFreeMemory(self)
end
function ImDrawListSplitter.__new(ctype)
    local ptr = lib.ImDrawListSplitter_ImDrawListSplitter()
    return ffi.gc(ptr,lib.ImDrawListSplitter_destroy)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function ImDrawListSplitter:Merge(draw_list)
    return lib.ImDrawListSplitter_Merge(self,draw_list)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@param channel_idx number int
---@return nil
function ImDrawListSplitter:SetCurrentChannel(draw_list,channel_idx)
    return lib.ImDrawListSplitter_SetCurrentChannel(self,draw_list,channel_idx)
end
---@param self ffi.ct* ImDrawListSplitter*
---@param draw_list ffi.ct* ImDrawList*
---@param count number int
---@return nil
function ImDrawListSplitter:Split(draw_list,count)
    return lib.ImDrawListSplitter_Split(self,draw_list,count)
end
M.ImDrawListSplitter = ffi.metatype("ImDrawListSplitter",ImDrawListSplitter)
--------------------------ImFont----------------------------
---@class ImFont
local ImFont= {}
ImFont.__index = ImFont
---@param self ffi.ct* ImFont*
---@param src_cfg ffi.ct* const ImFontConfig*
---@param c number ImWchar
---@param x0 number float
---@param y0 number float
---@param x1 number float
---@param y1 number float
---@param u0 number float
---@param v0 number float
---@param u1 number float
---@param v1 number float
---@param advance_x number float
---@return nil
function ImFont:AddGlyph(src_cfg,c,x0,y0,x1,y1,u0,v0,u1,v1,advance_x)
    return lib.ImFont_AddGlyph(self,src_cfg,c,x0,y0,x1,y1,u0,v0,u1,v1,advance_x)
end
---@param self ffi.ct* ImFont*
---@param dst number ImWchar
---@param src number ImWchar
---@param overwrite_dst boolean?
---@return nil
function ImFont:AddRemapChar(dst,src,overwrite_dst)
    if overwrite_dst == nil then overwrite_dst = true end
    return lib.ImFont_AddRemapChar(self,dst,src,overwrite_dst)
end
---@param self ffi.ct* ImFont*
---@return nil
function ImFont:BuildLookupTable()
    return lib.ImFont_BuildLookupTable(self)
end
---@param self ffi.ct* ImFont*
---@param size number float
---@param max_width number float
---@param wrap_width number float
---@param text_begin string
---@param text_end string?
---@param remaining ffi.ct*? const char**
---@return nil
function ImFont:CalcTextSizeA(size,max_width,wrap_width,text_begin,text_end,remaining)
    remaining = remaining or nil
    text_end = text_end or nil
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImFont_CalcTextSizeA(nonUDT_out,self,size,max_width,wrap_width,text_begin,text_end,remaining)
    return nonUDT_out
end
---@param self ffi.ct* ImFont*
---@param scale number float
---@param text string
---@param text_end string
---@param wrap_width number float
---@return string
function ImFont:CalcWordWrapPositionA(scale,text,text_end,wrap_width)
    return ffi.string(lib.ImFont_CalcWordWrapPositionA(self,scale,text,text_end,wrap_width))
end
---@param self ffi.ct* ImFont*
---@return nil
function ImFont:ClearOutputData()
    return lib.ImFont_ClearOutputData(self)
end
---@param self ffi.ct* ImFont*
---@param c number ImWchar
---@return ffi.ct* const ImFontGlyph*
function ImFont:FindGlyph(c)
    return lib.ImFont_FindGlyph(self,c)
end
---@param self ffi.ct* ImFont*
---@param c number ImWchar
---@return ffi.ct* const ImFontGlyph*
function ImFont:FindGlyphNoFallback(c)
    return lib.ImFont_FindGlyphNoFallback(self,c)
end
---@param self ffi.ct* ImFont*
---@param c number ImWchar
---@return number float
function ImFont:GetCharAdvance(c)
    return lib.ImFont_GetCharAdvance(self,c)
end
---@param self ffi.ct* ImFont*
---@return string
function ImFont:GetDebugName()
    return ffi.string(lib.ImFont_GetDebugName(self))
end
---@param self ffi.ct* ImFont*
---@param new_size number int
---@return nil
function ImFont:GrowIndex(new_size)
    return lib.ImFont_GrowIndex(self,new_size)
end
function ImFont.__new(ctype)
    local ptr = lib.ImFont_ImFont()
    return ffi.gc(ptr,lib.ImFont_destroy)
end
---@param self ffi.ct* ImFont*
---@param c_begin number unsigned int
---@param c_last number unsigned int
---@return boolean
function ImFont:IsGlyphRangeUnused(c_begin,c_last)
    return lib.ImFont_IsGlyphRangeUnused(self,c_begin,c_last)
end
---@param self ffi.ct* ImFont*
---@return boolean
function ImFont:IsLoaded()
    return lib.ImFont_IsLoaded(self)
end
---@param self ffi.ct* ImFont*
---@param draw_list ffi.ct* ImDrawList*
---@param size number float
---@param pos ImVec2
---@param col number ImU32
---@param c number ImWchar
---@return nil
function ImFont:RenderChar(draw_list,size,pos,col,c)
    return lib.ImFont_RenderChar(self,draw_list,size,pos,col,c)
end
---@param self ffi.ct* ImFont*
---@param draw_list ffi.ct* ImDrawList*
---@param size number float
---@param pos ImVec2
---@param col number ImU32
---@param clip_rect ffi.ct* const ImVec4
---@param text_begin string
---@param text_end string
---@param wrap_width number? float
---@param cpu_fine_clip boolean?
---@return nil
function ImFont:RenderText(draw_list,size,pos,col,clip_rect,text_begin,text_end,wrap_width,cpu_fine_clip)
    cpu_fine_clip = cpu_fine_clip or false
    wrap_width = wrap_width or 0.0
    return lib.ImFont_RenderText(self,draw_list,size,pos,col,clip_rect,text_begin,text_end,wrap_width,cpu_fine_clip)
end
---@param self ffi.ct* ImFont*
---@param c number ImWchar
---@param visible boolean
---@return nil
function ImFont:SetGlyphVisible(c,visible)
    return lib.ImFont_SetGlyphVisible(self,c,visible)
end
M.ImFont = ffi.metatype("ImFont",ImFont)
--------------------------ImFontAtlas----------------------------
---@class ImFontAtlas
local ImFontAtlas= {}
ImFontAtlas.__index = ImFontAtlas
---@param self ffi.ct* ImFontAtlas*
---@param font ffi.ct* ImFont*
---@param id number ImWchar
---@param width number int
---@param height number int
---@param advance_x number float
---@param offset ImVec2?
---@return number int
function ImFontAtlas:AddCustomRectFontGlyph(font,id,width,height,advance_x,offset)
    offset = offset or ImVec2(0,0)
    return lib.ImFontAtlas_AddCustomRectFontGlyph(self,font,id,width,height,advance_x,offset)
end
---@param self ffi.ct* ImFontAtlas*
---@param width number int
---@param height number int
---@return number int
function ImFontAtlas:AddCustomRectRegular(width,height)
    return lib.ImFontAtlas_AddCustomRectRegular(self,width,height)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_cfg ffi.ct* const ImFontConfig*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFont(font_cfg)
    return lib.ImFontAtlas_AddFont(self,font_cfg)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_cfg ffi.ct*? const ImFontConfig*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontDefault(font_cfg)
    font_cfg = font_cfg or nil
    return lib.ImFontAtlas_AddFontDefault(self,font_cfg)
end
---@param self ffi.ct* ImFontAtlas*
---@param filename string
---@param size_pixels number float
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromFileTTF(filename,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromFileTTF(self,filename,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param compressed_font_data_base85 string
---@param size_pixels number float
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryCompressedBase85TTF(compressed_font_data_base85,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self,compressed_font_data_base85,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param compressed_font_data ffi.ct* const void*
---@param compressed_font_data_size number int
---@param size_pixels number float
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryCompressedTTF(compressed_font_data,compressed_font_data_size,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryCompressedTTF(self,compressed_font_data,compressed_font_data_size,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@param font_data ffi.ct* void*
---@param font_data_size number int
---@param size_pixels number float
---@param font_cfg ffi.ct*? const ImFontConfig*
---@param glyph_ranges ffi.ct*? const ImWchar*
---@return ffi.ct* ImFont*
function ImFontAtlas:AddFontFromMemoryTTF(font_data,font_data_size,size_pixels,font_cfg,glyph_ranges)
    font_cfg = font_cfg or nil
    glyph_ranges = glyph_ranges or nil
    return lib.ImFontAtlas_AddFontFromMemoryTTF(self,font_data,font_data_size,size_pixels,font_cfg,glyph_ranges)
end
---@param self ffi.ct* ImFontAtlas*
---@return boolean
function ImFontAtlas:Build()
    return lib.ImFontAtlas_Build(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param rect ffi.ct* const ImFontAtlasCustomRect*
---@param out_uv_min ffi.ct* ImVec2*
---@param out_uv_max ffi.ct* ImVec2*
---@return nil
function ImFontAtlas:CalcCustomRectUV(rect,out_uv_min,out_uv_max)
    return lib.ImFontAtlas_CalcCustomRectUV(self,rect,out_uv_min,out_uv_max)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:Clear()
    return lib.ImFontAtlas_Clear(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearFonts()
    return lib.ImFontAtlas_ClearFonts(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearInputData()
    return lib.ImFontAtlas_ClearInputData(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return nil
function ImFontAtlas:ClearTexData()
    return lib.ImFontAtlas_ClearTexData(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param index number int
---@return ffi.ct* ImFontAtlasCustomRect*
function ImFontAtlas:GetCustomRectByIndex(index)
    return lib.ImFontAtlas_GetCustomRectByIndex(self,index)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesChineseFull()
    return lib.ImFontAtlas_GetGlyphRangesChineseFull(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesChineseSimplifiedCommon()
    return lib.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesCyrillic()
    return lib.ImFontAtlas_GetGlyphRangesCyrillic(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesDefault()
    return lib.ImFontAtlas_GetGlyphRangesDefault(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesGreek()
    return lib.ImFontAtlas_GetGlyphRangesGreek(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesJapanese()
    return lib.ImFontAtlas_GetGlyphRangesJapanese(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesKorean()
    return lib.ImFontAtlas_GetGlyphRangesKorean(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesThai()
    return lib.ImFontAtlas_GetGlyphRangesThai(self)
end
---@param self ffi.ct* ImFontAtlas*
---@return ffi.ct* const ImWchar*
function ImFontAtlas:GetGlyphRangesVietnamese()
    return lib.ImFontAtlas_GetGlyphRangesVietnamese(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param cursor MouseCursor
---@param out_offset ffi.ct* ImVec2*
---@param out_size ffi.ct* ImVec2*
---@param out_uv_border ffi.ct* ImVec2[2]
---@param out_uv_fill ffi.ct* ImVec2[2]
---@return boolean
function ImFontAtlas:GetMouseCursorTexData(cursor,out_offset,out_size,out_uv_border,out_uv_fill)
    return lib.ImFontAtlas_GetMouseCursorTexData(self,cursor,out_offset,out_size,out_uv_border,out_uv_fill)
end
---@param self ffi.ct* ImFontAtlas*
---@param out_pixels ffi.ct* unsigned char**
---@param out_width ffi.ct* int*
---@param out_height ffi.ct* int*
---@param out_bytes_per_pixel ffi.ct*? int*
---@return nil
function ImFontAtlas:GetTexDataAsAlpha8(out_pixels,out_width,out_height,out_bytes_per_pixel)
    out_bytes_per_pixel = out_bytes_per_pixel or nil
    return lib.ImFontAtlas_GetTexDataAsAlpha8(self,out_pixels,out_width,out_height,out_bytes_per_pixel)
end
---@param self ffi.ct* ImFontAtlas*
---@param out_pixels ffi.ct* unsigned char**
---@param out_width ffi.ct* int*
---@param out_height ffi.ct* int*
---@param out_bytes_per_pixel ffi.ct*? int*
---@return nil
function ImFontAtlas:GetTexDataAsRGBA32(out_pixels,out_width,out_height,out_bytes_per_pixel)
    out_bytes_per_pixel = out_bytes_per_pixel or nil
    return lib.ImFontAtlas_GetTexDataAsRGBA32(self,out_pixels,out_width,out_height,out_bytes_per_pixel)
end
function ImFontAtlas.__new(ctype)
    local ptr = lib.ImFontAtlas_ImFontAtlas()
    return ffi.gc(ptr,lib.ImFontAtlas_destroy)
end
---@param self ffi.ct* ImFontAtlas*
---@return boolean
function ImFontAtlas:IsBuilt()
    return lib.ImFontAtlas_IsBuilt(self)
end
---@param self ffi.ct* ImFontAtlas*
---@param id number ImTextureID
---@return nil
function ImFontAtlas:SetTexID(id)
    return lib.ImFontAtlas_SetTexID(self,id)
end
M.ImFontAtlas = ffi.metatype("ImFontAtlas",ImFontAtlas)
--------------------------ImFontAtlasCustomRect----------------------------
---@class ImFontAtlasCustomRect
local ImFontAtlasCustomRect= {}
ImFontAtlasCustomRect.__index = ImFontAtlasCustomRect
function ImFontAtlasCustomRect.__new(ctype)
    local ptr = lib.ImFontAtlasCustomRect_ImFontAtlasCustomRect()
    return ffi.gc(ptr,lib.ImFontAtlasCustomRect_destroy)
end
---@param self ffi.ct* ImFontAtlasCustomRect*
---@return boolean
function ImFontAtlasCustomRect:IsPacked()
    return lib.ImFontAtlasCustomRect_IsPacked(self)
end
M.ImFontAtlasCustomRect = ffi.metatype("ImFontAtlasCustomRect",ImFontAtlasCustomRect)
--------------------------ImFontConfig----------------------------
---@class ImFontConfig
local ImFontConfig= {}
ImFontConfig.__index = ImFontConfig
function ImFontConfig.__new(ctype)
    local ptr = lib.ImFontConfig_ImFontConfig()
    return ffi.gc(ptr,lib.ImFontConfig_destroy)
end
M.ImFontConfig = ffi.metatype("ImFontConfig",ImFontConfig)
--------------------------ImFontGlyphRangesBuilder----------------------------
---@class ImFontGlyphRangesBuilder
local ImFontGlyphRangesBuilder= {}
ImFontGlyphRangesBuilder.__index = ImFontGlyphRangesBuilder
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param c number ImWchar
---@return nil
function ImFontGlyphRangesBuilder:AddChar(c)
    return lib.ImFontGlyphRangesBuilder_AddChar(self,c)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param ranges ffi.ct* const ImWchar*
---@return nil
function ImFontGlyphRangesBuilder:AddRanges(ranges)
    return lib.ImFontGlyphRangesBuilder_AddRanges(self,ranges)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param text string
---@param text_end string?
---@return nil
function ImFontGlyphRangesBuilder:AddText(text,text_end)
    text_end = text_end or nil
    return lib.ImFontGlyphRangesBuilder_AddText(self,text,text_end)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param out_ranges ffi.ct* ImVector_ImWchar*
---@return nil
function ImFontGlyphRangesBuilder:BuildRanges(out_ranges)
    return lib.ImFontGlyphRangesBuilder_BuildRanges(self,out_ranges)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@return nil
function ImFontGlyphRangesBuilder:Clear()
    return lib.ImFontGlyphRangesBuilder_Clear(self)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param n number size_t
---@return boolean
function ImFontGlyphRangesBuilder:GetBit(n)
    return lib.ImFontGlyphRangesBuilder_GetBit(self,n)
end
function ImFontGlyphRangesBuilder.__new(ctype)
    local ptr = lib.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder()
    return ffi.gc(ptr,lib.ImFontGlyphRangesBuilder_destroy)
end
---@param self ffi.ct* ImFontGlyphRangesBuilder*
---@param n number size_t
---@return nil
function ImFontGlyphRangesBuilder:SetBit(n)
    return lib.ImFontGlyphRangesBuilder_SetBit(self,n)
end
M.ImFontGlyphRangesBuilder = ffi.metatype("ImFontGlyphRangesBuilder",ImFontGlyphRangesBuilder)
--------------------------ImGuiComboPreviewData----------------------------
---@class ImGuiComboPreviewData
local ImGuiComboPreviewData= {}
ImGuiComboPreviewData.__index = ImGuiComboPreviewData
function ImGuiComboPreviewData.__new(ctype)
    local ptr = lib.ImGuiComboPreviewData_ImGuiComboPreviewData()
    return ffi.gc(ptr,lib.ImGuiComboPreviewData_destroy)
end
M.ImGuiComboPreviewData = ffi.metatype("ImGuiComboPreviewData",ImGuiComboPreviewData)
--------------------------ImGuiContext----------------------------
---@class ImGuiContext
local ImGuiContext= {}
ImGuiContext.__index = ImGuiContext
function ImGuiContext.__new(ctype,shared_font_atlas)
    local ptr = lib.ImGuiContext_ImGuiContext(shared_font_atlas)
    return ffi.gc(ptr,lib.ImGuiContext_destroy)
end
M.ImGuiContext = ffi.metatype("ImGuiContext",ImGuiContext)
--------------------------ImGuiContextHook----------------------------
---@class ImGuiContextHook
local ImGuiContextHook= {}
ImGuiContextHook.__index = ImGuiContextHook
function ImGuiContextHook.__new(ctype)
    local ptr = lib.ImGuiContextHook_ImGuiContextHook()
    return ffi.gc(ptr,lib.ImGuiContextHook_destroy)
end
M.ImGuiContextHook = ffi.metatype("ImGuiContextHook",ImGuiContextHook)
--------------------------ImGuiDataVarInfo----------------------------
---@class ImGuiDataVarInfo
local ImGuiDataVarInfo= {}
ImGuiDataVarInfo.__index = ImGuiDataVarInfo
---@param self ffi.ct* ImGuiDataVarInfo*
---@param parent ffi.ct* void*
---@return ffi.ct* void*
function ImGuiDataVarInfo:GetVarPtr(parent)
    return lib.ImGuiDataVarInfo_GetVarPtr(self,parent)
end
M.ImGuiDataVarInfo = ffi.metatype("ImGuiDataVarInfo",ImGuiDataVarInfo)
--------------------------ImGuiDebugAllocInfo----------------------------
---@class ImGuiDebugAllocInfo
local ImGuiDebugAllocInfo= {}
ImGuiDebugAllocInfo.__index = ImGuiDebugAllocInfo
function ImGuiDebugAllocInfo.__new(ctype)
    local ptr = lib.ImGuiDebugAllocInfo_ImGuiDebugAllocInfo()
    return ffi.gc(ptr,lib.ImGuiDebugAllocInfo_destroy)
end
M.ImGuiDebugAllocInfo = ffi.metatype("ImGuiDebugAllocInfo",ImGuiDebugAllocInfo)
--------------------------ImGuiDockContext----------------------------
---@class ImGuiDockContext
local ImGuiDockContext= {}
ImGuiDockContext.__index = ImGuiDockContext
function ImGuiDockContext.__new(ctype)
    local ptr = lib.ImGuiDockContext_ImGuiDockContext()
    return ffi.gc(ptr,lib.ImGuiDockContext_destroy)
end
M.ImGuiDockContext = ffi.metatype("ImGuiDockContext",ImGuiDockContext)
--------------------------ImGuiDockNode----------------------------
---@class ImGuiDockNode
local ImGuiDockNode= {}
ImGuiDockNode.__index = ImGuiDockNode
function ImGuiDockNode.__new(ctype,id)
    local ptr = lib.ImGuiDockNode_ImGuiDockNode(id)
    return ffi.gc(ptr,lib.ImGuiDockNode_destroy)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsCentralNode()
    return lib.ImGuiDockNode_IsCentralNode(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsDockSpace()
    return lib.ImGuiDockNode_IsDockSpace(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsEmpty()
    return lib.ImGuiDockNode_IsEmpty(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsFloatingNode()
    return lib.ImGuiDockNode_IsFloatingNode(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsHiddenTabBar()
    return lib.ImGuiDockNode_IsHiddenTabBar(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsLeafNode()
    return lib.ImGuiDockNode_IsLeafNode(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsNoTabBar()
    return lib.ImGuiDockNode_IsNoTabBar(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsRootNode()
    return lib.ImGuiDockNode_IsRootNode(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return boolean
function ImGuiDockNode:IsSplitNode()
    return lib.ImGuiDockNode_IsSplitNode(self)
end
---@param self ffi.ct* ImGuiDockNode*
---@return nil
function ImGuiDockNode:Rect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiDockNode_Rect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiDockNode*
---@param flags DockNodeFlags
---@return nil
function ImGuiDockNode:SetLocalFlags(flags)
    return lib.ImGuiDockNode_SetLocalFlags(self,flags)
end
---@param self ffi.ct* ImGuiDockNode*
---@return nil
function ImGuiDockNode:UpdateMergedFlags()
    return lib.ImGuiDockNode_UpdateMergedFlags(self)
end
M.ImGuiDockNode = ffi.metatype("ImGuiDockNode",ImGuiDockNode)
--------------------------ImGuiIDStackTool----------------------------
---@class ImGuiIDStackTool
local ImGuiIDStackTool= {}
ImGuiIDStackTool.__index = ImGuiIDStackTool
function ImGuiIDStackTool.__new(ctype)
    local ptr = lib.ImGuiIDStackTool_ImGuiIDStackTool()
    return ffi.gc(ptr,lib.ImGuiIDStackTool_destroy)
end
M.ImGuiIDStackTool = ffi.metatype("ImGuiIDStackTool",ImGuiIDStackTool)
--------------------------ImGuiIO----------------------------
---@class ImGuiIO
local ImGuiIO= {}
ImGuiIO.__index = ImGuiIO
---@param self ffi.ct* ImGuiIO*
---@param focused boolean
---@return nil
function ImGuiIO:AddFocusEvent(focused)
    return lib.ImGuiIO_AddFocusEvent(self,focused)
end
---@param self ffi.ct* ImGuiIO*
---@param c number unsigned int
---@return nil
function ImGuiIO:AddInputCharacter(c)
    return lib.ImGuiIO_AddInputCharacter(self,c)
end
---@param self ffi.ct* ImGuiIO*
---@param c number ImWchar16
---@return nil
function ImGuiIO:AddInputCharacterUTF16(c)
    return lib.ImGuiIO_AddInputCharacterUTF16(self,c)
end
---@param self ffi.ct* ImGuiIO*
---@param str string
---@return nil
function ImGuiIO:AddInputCharactersUTF8(str)
    return lib.ImGuiIO_AddInputCharactersUTF8(self,str)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param down boolean
---@param v number float
---@return nil
function ImGuiIO:AddKeyAnalogEvent(key,down,v)
    return lib.ImGuiIO_AddKeyAnalogEvent(self,key,down,v)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param down boolean
---@return nil
function ImGuiIO:AddKeyEvent(key,down)
    return lib.ImGuiIO_AddKeyEvent(self,key,down)
end
---@param self ffi.ct* ImGuiIO*
---@param button number int
---@param down boolean
---@return nil
function ImGuiIO:AddMouseButtonEvent(button,down)
    return lib.ImGuiIO_AddMouseButtonEvent(self,button,down)
end
---@param self ffi.ct* ImGuiIO*
---@param x number float
---@param y number float
---@return nil
function ImGuiIO:AddMousePosEvent(x,y)
    return lib.ImGuiIO_AddMousePosEvent(self,x,y)
end
---@param self ffi.ct* ImGuiIO*
---@param source MouseSource
---@return nil
function ImGuiIO:AddMouseSourceEvent(source)
    return lib.ImGuiIO_AddMouseSourceEvent(self,source)
end
---@param self ffi.ct* ImGuiIO*
---@param id number ImGuiID
---@return nil
function ImGuiIO:AddMouseViewportEvent(id)
    return lib.ImGuiIO_AddMouseViewportEvent(self,id)
end
---@param self ffi.ct* ImGuiIO*
---@param wheel_x number float
---@param wheel_y number float
---@return nil
function ImGuiIO:AddMouseWheelEvent(wheel_x,wheel_y)
    return lib.ImGuiIO_AddMouseWheelEvent(self,wheel_x,wheel_y)
end
---@param self ffi.ct* ImGuiIO*
---@return nil
function ImGuiIO:ClearEventsQueue()
    return lib.ImGuiIO_ClearEventsQueue(self)
end
---@param self ffi.ct* ImGuiIO*
---@return nil
function ImGuiIO:ClearInputKeys()
    return lib.ImGuiIO_ClearInputKeys(self)
end
function ImGuiIO.__new(ctype)
    local ptr = lib.ImGuiIO_ImGuiIO()
    return ffi.gc(ptr,lib.ImGuiIO_destroy)
end
---@param self ffi.ct* ImGuiIO*
---@param accepting_events boolean
---@return nil
function ImGuiIO:SetAppAcceptingEvents(accepting_events)
    return lib.ImGuiIO_SetAppAcceptingEvents(self,accepting_events)
end
---@param self ffi.ct* ImGuiIO*
---@param key Key
---@param native_keycode number int
---@param native_scancode number int
---@param native_legacy_index number? int
---@return nil
function ImGuiIO:SetKeyEventNativeData(key,native_keycode,native_scancode,native_legacy_index)
    native_legacy_index = native_legacy_index or -1
    return lib.ImGuiIO_SetKeyEventNativeData(self,key,native_keycode,native_scancode,native_legacy_index)
end
M.ImGuiIO = ffi.metatype("ImGuiIO",ImGuiIO)
--------------------------ImGuiInputEvent----------------------------
---@class ImGuiInputEvent
local ImGuiInputEvent= {}
ImGuiInputEvent.__index = ImGuiInputEvent
function ImGuiInputEvent.__new(ctype)
    local ptr = lib.ImGuiInputEvent_ImGuiInputEvent()
    return ffi.gc(ptr,lib.ImGuiInputEvent_destroy)
end
M.ImGuiInputEvent = ffi.metatype("ImGuiInputEvent",ImGuiInputEvent)
--------------------------ImGuiInputTextCallbackData----------------------------
---@class ImGuiInputTextCallbackData
local ImGuiInputTextCallbackData= {}
ImGuiInputTextCallbackData.__index = ImGuiInputTextCallbackData
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return nil
function ImGuiInputTextCallbackData:ClearSelection()
    return lib.ImGuiInputTextCallbackData_ClearSelection(self)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@param pos number int
---@param bytes_count number int
---@return nil
function ImGuiInputTextCallbackData:DeleteChars(pos,bytes_count)
    return lib.ImGuiInputTextCallbackData_DeleteChars(self,pos,bytes_count)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return boolean
function ImGuiInputTextCallbackData:HasSelection()
    return lib.ImGuiInputTextCallbackData_HasSelection(self)
end
function ImGuiInputTextCallbackData.__new(ctype)
    local ptr = lib.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData()
    return ffi.gc(ptr,lib.ImGuiInputTextCallbackData_destroy)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@param pos number int
---@param text string
---@param text_end string?
---@return nil
function ImGuiInputTextCallbackData:InsertChars(pos,text,text_end)
    text_end = text_end or nil
    return lib.ImGuiInputTextCallbackData_InsertChars(self,pos,text,text_end)
end
---@param self ffi.ct* ImGuiInputTextCallbackData*
---@return nil
function ImGuiInputTextCallbackData:SelectAll()
    return lib.ImGuiInputTextCallbackData_SelectAll(self)
end
M.ImGuiInputTextCallbackData = ffi.metatype("ImGuiInputTextCallbackData",ImGuiInputTextCallbackData)
--------------------------ImGuiInputTextDeactivatedState----------------------------
---@class ImGuiInputTextDeactivatedState
local ImGuiInputTextDeactivatedState= {}
ImGuiInputTextDeactivatedState.__index = ImGuiInputTextDeactivatedState
---@param self ffi.ct* ImGuiInputTextDeactivatedState*
---@return nil
function ImGuiInputTextDeactivatedState:ClearFreeMemory()
    return lib.ImGuiInputTextDeactivatedState_ClearFreeMemory(self)
end
function ImGuiInputTextDeactivatedState.__new(ctype)
    local ptr = lib.ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState()
    return ffi.gc(ptr,lib.ImGuiInputTextDeactivatedState_destroy)
end
M.ImGuiInputTextDeactivatedState = ffi.metatype("ImGuiInputTextDeactivatedState",ImGuiInputTextDeactivatedState)
--------------------------ImGuiInputTextState----------------------------
---@class ImGuiInputTextState
local ImGuiInputTextState= {}
ImGuiInputTextState.__index = ImGuiInputTextState
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearFreeMemory()
    return lib.ImGuiInputTextState_ClearFreeMemory(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearSelection()
    return lib.ImGuiInputTextState_ClearSelection(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ClearText()
    return lib.ImGuiInputTextState_ClearText(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:CursorAnimReset()
    return lib.ImGuiInputTextState_CursorAnimReset(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:CursorClamp()
    return lib.ImGuiInputTextState_CursorClamp(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number int
function ImGuiInputTextState:GetCursorPos()
    return lib.ImGuiInputTextState_GetCursorPos(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number int
function ImGuiInputTextState:GetRedoAvailCount()
    return lib.ImGuiInputTextState_GetRedoAvailCount(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number int
function ImGuiInputTextState:GetSelectionEnd()
    return lib.ImGuiInputTextState_GetSelectionEnd(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number int
function ImGuiInputTextState:GetSelectionStart()
    return lib.ImGuiInputTextState_GetSelectionStart(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return number int
function ImGuiInputTextState:GetUndoAvailCount()
    return lib.ImGuiInputTextState_GetUndoAvailCount(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return boolean
function ImGuiInputTextState:HasSelection()
    return lib.ImGuiInputTextState_HasSelection(self)
end
function ImGuiInputTextState.__new(ctype)
    local ptr = lib.ImGuiInputTextState_ImGuiInputTextState()
    return ffi.gc(ptr,lib.ImGuiInputTextState_destroy)
end
---@param self ffi.ct* ImGuiInputTextState*
---@param key number int
---@return nil
function ImGuiInputTextState:OnKeyPressed(key)
    return lib.ImGuiInputTextState_OnKeyPressed(self,key)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ReloadUserBufAndKeepSelection()
    return lib.ImGuiInputTextState_ReloadUserBufAndKeepSelection(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ReloadUserBufAndMoveToEnd()
    return lib.ImGuiInputTextState_ReloadUserBufAndMoveToEnd(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:ReloadUserBufAndSelectAll()
    return lib.ImGuiInputTextState_ReloadUserBufAndSelectAll(self)
end
---@param self ffi.ct* ImGuiInputTextState*
---@return nil
function ImGuiInputTextState:SelectAll()
    return lib.ImGuiInputTextState_SelectAll(self)
end
M.ImGuiInputTextState = ffi.metatype("ImGuiInputTextState",ImGuiInputTextState)
--------------------------ImGuiKeyOwnerData----------------------------
---@class ImGuiKeyOwnerData
local ImGuiKeyOwnerData= {}
ImGuiKeyOwnerData.__index = ImGuiKeyOwnerData
function ImGuiKeyOwnerData.__new(ctype)
    local ptr = lib.ImGuiKeyOwnerData_ImGuiKeyOwnerData()
    return ffi.gc(ptr,lib.ImGuiKeyOwnerData_destroy)
end
M.ImGuiKeyOwnerData = ffi.metatype("ImGuiKeyOwnerData",ImGuiKeyOwnerData)
--------------------------ImGuiKeyRoutingData----------------------------
---@class ImGuiKeyRoutingData
local ImGuiKeyRoutingData= {}
ImGuiKeyRoutingData.__index = ImGuiKeyRoutingData
function ImGuiKeyRoutingData.__new(ctype)
    local ptr = lib.ImGuiKeyRoutingData_ImGuiKeyRoutingData()
    return ffi.gc(ptr,lib.ImGuiKeyRoutingData_destroy)
end
M.ImGuiKeyRoutingData = ffi.metatype("ImGuiKeyRoutingData",ImGuiKeyRoutingData)
--------------------------ImGuiKeyRoutingTable----------------------------
---@class ImGuiKeyRoutingTable
local ImGuiKeyRoutingTable= {}
ImGuiKeyRoutingTable.__index = ImGuiKeyRoutingTable
---@param self ffi.ct* ImGuiKeyRoutingTable*
---@return nil
function ImGuiKeyRoutingTable:Clear()
    return lib.ImGuiKeyRoutingTable_Clear(self)
end
function ImGuiKeyRoutingTable.__new(ctype)
    local ptr = lib.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable()
    return ffi.gc(ptr,lib.ImGuiKeyRoutingTable_destroy)
end
M.ImGuiKeyRoutingTable = ffi.metatype("ImGuiKeyRoutingTable",ImGuiKeyRoutingTable)
--------------------------ImGuiLastItemData----------------------------
---@class ImGuiLastItemData
local ImGuiLastItemData= {}
ImGuiLastItemData.__index = ImGuiLastItemData
function ImGuiLastItemData.__new(ctype)
    local ptr = lib.ImGuiLastItemData_ImGuiLastItemData()
    return ffi.gc(ptr,lib.ImGuiLastItemData_destroy)
end
M.ImGuiLastItemData = ffi.metatype("ImGuiLastItemData",ImGuiLastItemData)
--------------------------ImGuiListClipper----------------------------
---@class ImGuiListClipper
local ImGuiListClipper= {}
ImGuiListClipper.__index = ImGuiListClipper
---@param self ffi.ct* ImGuiListClipper*
---@param items_count number int
---@param items_height number? float
---@return nil
function ImGuiListClipper:Begin(items_count,items_height)
    items_height = items_height or -1.0
    return lib.ImGuiListClipper_Begin(self,items_count,items_height)
end
---@param self ffi.ct* ImGuiListClipper*
---@return nil
function ImGuiListClipper:End()
    return lib.ImGuiListClipper_End(self)
end
function ImGuiListClipper.__new(ctype)
    local ptr = lib.ImGuiListClipper_ImGuiListClipper()
    return ffi.gc(ptr,lib.ImGuiListClipper_destroy)
end
---@param self ffi.ct* ImGuiListClipper*
---@param item_index number int
---@return nil
function ImGuiListClipper:IncludeItemByIndex(item_index)
    return lib.ImGuiListClipper_IncludeItemByIndex(self,item_index)
end
---@param self ffi.ct* ImGuiListClipper*
---@param item_begin number int
---@param item_end number int
---@return nil
function ImGuiListClipper:IncludeItemsByIndex(item_begin,item_end)
    return lib.ImGuiListClipper_IncludeItemsByIndex(self,item_begin,item_end)
end
---@param self ffi.ct* ImGuiListClipper*
---@return boolean
function ImGuiListClipper:Step()
    return lib.ImGuiListClipper_Step(self)
end
M.ImGuiListClipper = ffi.metatype("ImGuiListClipper",ImGuiListClipper)
--------------------------ImGuiListClipperData----------------------------
---@class ImGuiListClipperData
local ImGuiListClipperData= {}
ImGuiListClipperData.__index = ImGuiListClipperData
function ImGuiListClipperData.__new(ctype)
    local ptr = lib.ImGuiListClipperData_ImGuiListClipperData()
    return ffi.gc(ptr,lib.ImGuiListClipperData_destroy)
end
---@param self ffi.ct* ImGuiListClipperData*
---@param clipper ffi.ct* ImGuiListClipper*
---@return nil
function ImGuiListClipperData:Reset(clipper)
    return lib.ImGuiListClipperData_Reset(self,clipper)
end
M.ImGuiListClipperData = ffi.metatype("ImGuiListClipperData",ImGuiListClipperData)
--------------------------ImGuiListClipperRange----------------------------
---@class ImGuiListClipperRange
local ImGuiListClipperRange= {}
ImGuiListClipperRange.__index = ImGuiListClipperRange
---@param min number int
---@param max number int
---@return ImGuiListClipperRange
function M.ImGuiListClipperRange_FromIndices(min,max)
    return lib.ImGuiListClipperRange_FromIndices(min,max)
end
---@param y1 number float
---@param y2 number float
---@param off_min number int
---@param off_max number int
---@return ImGuiListClipperRange
function M.ImGuiListClipperRange_FromPositions(y1,y2,off_min,off_max)
    return lib.ImGuiListClipperRange_FromPositions(y1,y2,off_min,off_max)
end
M.ImGuiListClipperRange = ffi.metatype("ImGuiListClipperRange",ImGuiListClipperRange)
--------------------------ImGuiMenuColumns----------------------------
---@class ImGuiMenuColumns
local ImGuiMenuColumns= {}
ImGuiMenuColumns.__index = ImGuiMenuColumns
---@param self ffi.ct* ImGuiMenuColumns*
---@param update_offsets boolean
---@return nil
function ImGuiMenuColumns:CalcNextTotalWidth(update_offsets)
    return lib.ImGuiMenuColumns_CalcNextTotalWidth(self,update_offsets)
end
---@param self ffi.ct* ImGuiMenuColumns*
---@param w_icon number float
---@param w_label number float
---@param w_shortcut number float
---@param w_mark number float
---@return number float
function ImGuiMenuColumns:DeclColumns(w_icon,w_label,w_shortcut,w_mark)
    return lib.ImGuiMenuColumns_DeclColumns(self,w_icon,w_label,w_shortcut,w_mark)
end
function ImGuiMenuColumns.__new(ctype)
    local ptr = lib.ImGuiMenuColumns_ImGuiMenuColumns()
    return ffi.gc(ptr,lib.ImGuiMenuColumns_destroy)
end
---@param self ffi.ct* ImGuiMenuColumns*
---@param spacing number float
---@param window_reappearing boolean
---@return nil
function ImGuiMenuColumns:Update(spacing,window_reappearing)
    return lib.ImGuiMenuColumns_Update(self,spacing,window_reappearing)
end
M.ImGuiMenuColumns = ffi.metatype("ImGuiMenuColumns",ImGuiMenuColumns)
--------------------------ImGuiNavItemData----------------------------
---@class ImGuiNavItemData
local ImGuiNavItemData= {}
ImGuiNavItemData.__index = ImGuiNavItemData
---@param self ffi.ct* ImGuiNavItemData*
---@return nil
function ImGuiNavItemData:Clear()
    return lib.ImGuiNavItemData_Clear(self)
end
function ImGuiNavItemData.__new(ctype)
    local ptr = lib.ImGuiNavItemData_ImGuiNavItemData()
    return ffi.gc(ptr,lib.ImGuiNavItemData_destroy)
end
M.ImGuiNavItemData = ffi.metatype("ImGuiNavItemData",ImGuiNavItemData)
--------------------------ImGuiNextItemData----------------------------
---@class ImGuiNextItemData
local ImGuiNextItemData= {}
ImGuiNextItemData.__index = ImGuiNextItemData
---@param self ffi.ct* ImGuiNextItemData*
---@return nil
function ImGuiNextItemData:ClearFlags()
    return lib.ImGuiNextItemData_ClearFlags(self)
end
function ImGuiNextItemData.__new(ctype)
    local ptr = lib.ImGuiNextItemData_ImGuiNextItemData()
    return ffi.gc(ptr,lib.ImGuiNextItemData_destroy)
end
M.ImGuiNextItemData = ffi.metatype("ImGuiNextItemData",ImGuiNextItemData)
--------------------------ImGuiNextWindowData----------------------------
---@class ImGuiNextWindowData
local ImGuiNextWindowData= {}
ImGuiNextWindowData.__index = ImGuiNextWindowData
---@param self ffi.ct* ImGuiNextWindowData*
---@return nil
function ImGuiNextWindowData:ClearFlags()
    return lib.ImGuiNextWindowData_ClearFlags(self)
end
function ImGuiNextWindowData.__new(ctype)
    local ptr = lib.ImGuiNextWindowData_ImGuiNextWindowData()
    return ffi.gc(ptr,lib.ImGuiNextWindowData_destroy)
end
M.ImGuiNextWindowData = ffi.metatype("ImGuiNextWindowData",ImGuiNextWindowData)
--------------------------ImGuiOldColumnData----------------------------
---@class ImGuiOldColumnData
local ImGuiOldColumnData= {}
ImGuiOldColumnData.__index = ImGuiOldColumnData
function ImGuiOldColumnData.__new(ctype)
    local ptr = lib.ImGuiOldColumnData_ImGuiOldColumnData()
    return ffi.gc(ptr,lib.ImGuiOldColumnData_destroy)
end
M.ImGuiOldColumnData = ffi.metatype("ImGuiOldColumnData",ImGuiOldColumnData)
--------------------------ImGuiOldColumns----------------------------
---@class ImGuiOldColumns
local ImGuiOldColumns= {}
ImGuiOldColumns.__index = ImGuiOldColumns
function ImGuiOldColumns.__new(ctype)
    local ptr = lib.ImGuiOldColumns_ImGuiOldColumns()
    return ffi.gc(ptr,lib.ImGuiOldColumns_destroy)
end
M.ImGuiOldColumns = ffi.metatype("ImGuiOldColumns",ImGuiOldColumns)
--------------------------ImGuiOnceUponAFrame----------------------------
---@class ImGuiOnceUponAFrame
local ImGuiOnceUponAFrame= {}
ImGuiOnceUponAFrame.__index = ImGuiOnceUponAFrame
function ImGuiOnceUponAFrame.__new(ctype)
    local ptr = lib.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame()
    return ffi.gc(ptr,lib.ImGuiOnceUponAFrame_destroy)
end
M.ImGuiOnceUponAFrame = ffi.metatype("ImGuiOnceUponAFrame",ImGuiOnceUponAFrame)
--------------------------ImGuiPayload----------------------------
---@class ImGuiPayload
local ImGuiPayload= {}
ImGuiPayload.__index = ImGuiPayload
---@param self ffi.ct* ImGuiPayload*
---@return nil
function ImGuiPayload:Clear()
    return lib.ImGuiPayload_Clear(self)
end
function ImGuiPayload.__new(ctype)
    local ptr = lib.ImGuiPayload_ImGuiPayload()
    return ffi.gc(ptr,lib.ImGuiPayload_destroy)
end
---@param self ffi.ct* ImGuiPayload*
---@param type string
---@return boolean
function ImGuiPayload:IsDataType(type)
    return lib.ImGuiPayload_IsDataType(self,type)
end
---@param self ffi.ct* ImGuiPayload*
---@return boolean
function ImGuiPayload:IsDelivery()
    return lib.ImGuiPayload_IsDelivery(self)
end
---@param self ffi.ct* ImGuiPayload*
---@return boolean
function ImGuiPayload:IsPreview()
    return lib.ImGuiPayload_IsPreview(self)
end
M.ImGuiPayload = ffi.metatype("ImGuiPayload",ImGuiPayload)
--------------------------ImGuiPlatformIO----------------------------
---@class ImGuiPlatformIO
local ImGuiPlatformIO= {}
ImGuiPlatformIO.__index = ImGuiPlatformIO
function ImGuiPlatformIO.__new(ctype)
    local ptr = lib.ImGuiPlatformIO_ImGuiPlatformIO()
    return ffi.gc(ptr,lib.ImGuiPlatformIO_destroy)
end
M.ImGuiPlatformIO = ffi.metatype("ImGuiPlatformIO",ImGuiPlatformIO)
--------------------------ImGuiPlatformImeData----------------------------
---@class ImGuiPlatformImeData
local ImGuiPlatformImeData= {}
ImGuiPlatformImeData.__index = ImGuiPlatformImeData
function ImGuiPlatformImeData.__new(ctype)
    local ptr = lib.ImGuiPlatformImeData_ImGuiPlatformImeData()
    return ffi.gc(ptr,lib.ImGuiPlatformImeData_destroy)
end
M.ImGuiPlatformImeData = ffi.metatype("ImGuiPlatformImeData",ImGuiPlatformImeData)
--------------------------ImGuiPlatformMonitor----------------------------
---@class ImGuiPlatformMonitor
local ImGuiPlatformMonitor= {}
ImGuiPlatformMonitor.__index = ImGuiPlatformMonitor
function ImGuiPlatformMonitor.__new(ctype)
    local ptr = lib.ImGuiPlatformMonitor_ImGuiPlatformMonitor()
    return ffi.gc(ptr,lib.ImGuiPlatformMonitor_destroy)
end
M.ImGuiPlatformMonitor = ffi.metatype("ImGuiPlatformMonitor",ImGuiPlatformMonitor)
--------------------------ImGuiPopupData----------------------------
---@class ImGuiPopupData
local ImGuiPopupData= {}
ImGuiPopupData.__index = ImGuiPopupData
function ImGuiPopupData.__new(ctype)
    local ptr = lib.ImGuiPopupData_ImGuiPopupData()
    return ffi.gc(ptr,lib.ImGuiPopupData_destroy)
end
M.ImGuiPopupData = ffi.metatype("ImGuiPopupData",ImGuiPopupData)
--------------------------ImGuiPtrOrIndex----------------------------
---@class ImGuiPtrOrIndex
local ImGuiPtrOrIndex= {}
ImGuiPtrOrIndex.__index = ImGuiPtrOrIndex
function ImGuiPtrOrIndex.ImGuiPtrOrIndex_Ptr(ptr)
    local ptr = lib.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(ptr)
    return ffi.gc(ptr,lib.ImGuiPtrOrIndex_destroy)
end
function ImGuiPtrOrIndex.ImGuiPtrOrIndex_Int(index)
    local ptr = lib.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(index)
    return ffi.gc(ptr,lib.ImGuiPtrOrIndex_destroy)
end
function ImGuiPtrOrIndex.__new(ctype,a1) -- generic version
    if ffi.istype('void *',a1) then return ImGuiPtrOrIndex.ImGuiPtrOrIndex_Ptr(a1) end
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return ImGuiPtrOrIndex.ImGuiPtrOrIndex_Int(a1) end
    print(ctype,a1)
    error'ImGuiPtrOrIndex.__new could not find overloaded'
end
M.ImGuiPtrOrIndex = ffi.metatype("ImGuiPtrOrIndex",ImGuiPtrOrIndex)
--------------------------ImGuiSettingsHandler----------------------------
---@class ImGuiSettingsHandler
local ImGuiSettingsHandler= {}
ImGuiSettingsHandler.__index = ImGuiSettingsHandler
function ImGuiSettingsHandler.__new(ctype)
    local ptr = lib.ImGuiSettingsHandler_ImGuiSettingsHandler()
    return ffi.gc(ptr,lib.ImGuiSettingsHandler_destroy)
end
M.ImGuiSettingsHandler = ffi.metatype("ImGuiSettingsHandler",ImGuiSettingsHandler)
--------------------------ImGuiStackLevelInfo----------------------------
---@class ImGuiStackLevelInfo
local ImGuiStackLevelInfo= {}
ImGuiStackLevelInfo.__index = ImGuiStackLevelInfo
function ImGuiStackLevelInfo.__new(ctype)
    local ptr = lib.ImGuiStackLevelInfo_ImGuiStackLevelInfo()
    return ffi.gc(ptr,lib.ImGuiStackLevelInfo_destroy)
end
M.ImGuiStackLevelInfo = ffi.metatype("ImGuiStackLevelInfo",ImGuiStackLevelInfo)
--------------------------ImGuiStackSizes----------------------------
---@class ImGuiStackSizes
local ImGuiStackSizes= {}
ImGuiStackSizes.__index = ImGuiStackSizes
---@param self ffi.ct* ImGuiStackSizes*
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function ImGuiStackSizes:CompareWithContextState(ctx)
    return lib.ImGuiStackSizes_CompareWithContextState(self,ctx)
end
function ImGuiStackSizes.__new(ctype)
    local ptr = lib.ImGuiStackSizes_ImGuiStackSizes()
    return ffi.gc(ptr,lib.ImGuiStackSizes_destroy)
end
---@param self ffi.ct* ImGuiStackSizes*
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function ImGuiStackSizes:SetToContextState(ctx)
    return lib.ImGuiStackSizes_SetToContextState(self,ctx)
end
M.ImGuiStackSizes = ffi.metatype("ImGuiStackSizes",ImGuiStackSizes)
--------------------------ImGuiStorage----------------------------
---@class ImGuiStorage
local ImGuiStorage= {}
ImGuiStorage.__index = ImGuiStorage
---@param self ffi.ct* ImGuiStorage*
---@return nil
function ImGuiStorage:BuildSortByKey()
    return lib.ImGuiStorage_BuildSortByKey(self)
end
---@param self ffi.ct* ImGuiStorage*
---@return nil
function ImGuiStorage:Clear()
    return lib.ImGuiStorage_Clear(self)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val boolean?
---@return boolean
function ImGuiStorage:GetBool(key,default_val)
    default_val = default_val or false
    return lib.ImGuiStorage_GetBool(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val boolean?
---@return ffi.ct* bool*
function ImGuiStorage:GetBoolRef(key,default_val)
    default_val = default_val or false
    return lib.ImGuiStorage_GetBoolRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val number? float
---@return number float
function ImGuiStorage:GetFloat(key,default_val)
    default_val = default_val or 0.0
    return lib.ImGuiStorage_GetFloat(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val number? float
---@return ffi.ct* float*
function ImGuiStorage:GetFloatRef(key,default_val)
    default_val = default_val or 0.0
    return lib.ImGuiStorage_GetFloatRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val number? int
---@return number int
function ImGuiStorage:GetInt(key,default_val)
    default_val = default_val or 0
    return lib.ImGuiStorage_GetInt(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val number? int
---@return ffi.ct* int*
function ImGuiStorage:GetIntRef(key,default_val)
    default_val = default_val or 0
    return lib.ImGuiStorage_GetIntRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@return ffi.ct* void*
function ImGuiStorage:GetVoidPtr(key)
    return lib.ImGuiStorage_GetVoidPtr(self,key)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param default_val ffi.ct*? void*
---@return ffi.ct* void**
function ImGuiStorage:GetVoidPtrRef(key,default_val)
    default_val = default_val or nil
    return lib.ImGuiStorage_GetVoidPtrRef(self,key,default_val)
end
---@param self ffi.ct* ImGuiStorage*
---@param val number int
---@return nil
function ImGuiStorage:SetAllInt(val)
    return lib.ImGuiStorage_SetAllInt(self,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param val boolean
---@return nil
function ImGuiStorage:SetBool(key,val)
    return lib.ImGuiStorage_SetBool(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param val number float
---@return nil
function ImGuiStorage:SetFloat(key,val)
    return lib.ImGuiStorage_SetFloat(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param val number int
---@return nil
function ImGuiStorage:SetInt(key,val)
    return lib.ImGuiStorage_SetInt(self,key,val)
end
---@param self ffi.ct* ImGuiStorage*
---@param key number ImGuiID
---@param val ffi.ct* void*
---@return nil
function ImGuiStorage:SetVoidPtr(key,val)
    return lib.ImGuiStorage_SetVoidPtr(self,key,val)
end
M.ImGuiStorage = ffi.metatype("ImGuiStorage",ImGuiStorage)
--------------------------ImGuiStoragePair----------------------------
---@class ImGuiStoragePair
local ImGuiStoragePair= {}
ImGuiStoragePair.__index = ImGuiStoragePair
function ImGuiStoragePair.ImGuiStoragePair_Int(_key,_val)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Int(_key,_val)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.ImGuiStoragePair_Float(_key,_val)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Float(_key,_val)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.ImGuiStoragePair_Ptr(_key,_val)
    local ptr = lib.ImGuiStoragePair_ImGuiStoragePair_Ptr(_key,_val)
    return ffi.gc(ptr,lib.ImGuiStoragePair_destroy)
end
function ImGuiStoragePair.__new(ctype,a1,a2) -- generic version
    if (ffi.istype('int32_t',a2) or type(a2)=='number') then return ImGuiStoragePair.ImGuiStoragePair_Int(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return ImGuiStoragePair.ImGuiStoragePair_Float(a1,a2) end
    if ffi.istype('void *',a2) then return ImGuiStoragePair.ImGuiStoragePair_Ptr(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiStoragePair.__new could not find overloaded'
end
M.ImGuiStoragePair = ffi.metatype("ImGuiStoragePair",ImGuiStoragePair)
--------------------------ImGuiStyle----------------------------
---@class ImGuiStyle
local ImGuiStyle= {}
ImGuiStyle.__index = ImGuiStyle
function ImGuiStyle.__new(ctype)
    local ptr = lib.ImGuiStyle_ImGuiStyle()
    return ffi.gc(ptr,lib.ImGuiStyle_destroy)
end
---@param self ffi.ct* ImGuiStyle*
---@param scale_factor number float
---@return nil
function ImGuiStyle:ScaleAllSizes(scale_factor)
    return lib.ImGuiStyle_ScaleAllSizes(self,scale_factor)
end
M.ImGuiStyle = ffi.metatype("ImGuiStyle",ImGuiStyle)
--------------------------ImGuiStyleMod----------------------------
---@class ImGuiStyleMod
local ImGuiStyleMod= {}
ImGuiStyleMod.__index = ImGuiStyleMod
function ImGuiStyleMod.ImGuiStyleMod_Int(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Int(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.ImGuiStyleMod_Float(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Float(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.ImGuiStyleMod_Vec2(idx,v)
    local ptr = lib.ImGuiStyleMod_ImGuiStyleMod_Vec2(idx,v)
    return ffi.gc(ptr,lib.ImGuiStyleMod_destroy)
end
function ImGuiStyleMod.__new(ctype,a1,a2) -- generic version
    if (ffi.istype('int32_t',a2) or type(a2)=='number') then return ImGuiStyleMod.ImGuiStyleMod_Int(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return ImGuiStyleMod.ImGuiStyleMod_Float(a1,a2) end
    if ffi.istype('ImVec2',a2) then return ImGuiStyleMod.ImGuiStyleMod_Vec2(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiStyleMod.__new could not find overloaded'
end
M.ImGuiStyleMod = ffi.metatype("ImGuiStyleMod",ImGuiStyleMod)
--------------------------ImGuiTabBar----------------------------
---@class ImGuiTabBar
local ImGuiTabBar= {}
ImGuiTabBar.__index = ImGuiTabBar
function ImGuiTabBar.__new(ctype)
    local ptr = lib.ImGuiTabBar_ImGuiTabBar()
    return ffi.gc(ptr,lib.ImGuiTabBar_destroy)
end
M.ImGuiTabBar = ffi.metatype("ImGuiTabBar",ImGuiTabBar)
--------------------------ImGuiTabItem----------------------------
---@class ImGuiTabItem
local ImGuiTabItem= {}
ImGuiTabItem.__index = ImGuiTabItem
function ImGuiTabItem.__new(ctype)
    local ptr = lib.ImGuiTabItem_ImGuiTabItem()
    return ffi.gc(ptr,lib.ImGuiTabItem_destroy)
end
M.ImGuiTabItem = ffi.metatype("ImGuiTabItem",ImGuiTabItem)
--------------------------ImGuiTable----------------------------
---@class ImGuiTable
local ImGuiTable= {}
ImGuiTable.__index = ImGuiTable
function ImGuiTable.__new(ctype)
    local ptr = lib.ImGuiTable_ImGuiTable()
    return ffi.gc(ptr,lib.ImGuiTable_destroy)
end
M.ImGuiTable = ffi.metatype("ImGuiTable",ImGuiTable)
--------------------------ImGuiTableColumn----------------------------
---@class ImGuiTableColumn
local ImGuiTableColumn= {}
ImGuiTableColumn.__index = ImGuiTableColumn
function ImGuiTableColumn.__new(ctype)
    local ptr = lib.ImGuiTableColumn_ImGuiTableColumn()
    return ffi.gc(ptr,lib.ImGuiTableColumn_destroy)
end
M.ImGuiTableColumn = ffi.metatype("ImGuiTableColumn",ImGuiTableColumn)
--------------------------ImGuiTableColumnSettings----------------------------
---@class ImGuiTableColumnSettings
local ImGuiTableColumnSettings= {}
ImGuiTableColumnSettings.__index = ImGuiTableColumnSettings
function ImGuiTableColumnSettings.__new(ctype)
    local ptr = lib.ImGuiTableColumnSettings_ImGuiTableColumnSettings()
    return ffi.gc(ptr,lib.ImGuiTableColumnSettings_destroy)
end
M.ImGuiTableColumnSettings = ffi.metatype("ImGuiTableColumnSettings",ImGuiTableColumnSettings)
--------------------------ImGuiTableColumnSortSpecs----------------------------
---@class ImGuiTableColumnSortSpecs
local ImGuiTableColumnSortSpecs= {}
ImGuiTableColumnSortSpecs.__index = ImGuiTableColumnSortSpecs
function ImGuiTableColumnSortSpecs.__new(ctype)
    local ptr = lib.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs()
    return ffi.gc(ptr,lib.ImGuiTableColumnSortSpecs_destroy)
end
M.ImGuiTableColumnSortSpecs = ffi.metatype("ImGuiTableColumnSortSpecs",ImGuiTableColumnSortSpecs)
--------------------------ImGuiTableInstanceData----------------------------
---@class ImGuiTableInstanceData
local ImGuiTableInstanceData= {}
ImGuiTableInstanceData.__index = ImGuiTableInstanceData
function ImGuiTableInstanceData.__new(ctype)
    local ptr = lib.ImGuiTableInstanceData_ImGuiTableInstanceData()
    return ffi.gc(ptr,lib.ImGuiTableInstanceData_destroy)
end
M.ImGuiTableInstanceData = ffi.metatype("ImGuiTableInstanceData",ImGuiTableInstanceData)
--------------------------ImGuiTableSettings----------------------------
---@class ImGuiTableSettings
local ImGuiTableSettings= {}
ImGuiTableSettings.__index = ImGuiTableSettings
---@param self ffi.ct* ImGuiTableSettings*
---@return ffi.ct* ImGuiTableColumnSettings*
function ImGuiTableSettings:GetColumnSettings()
    return lib.ImGuiTableSettings_GetColumnSettings(self)
end
function ImGuiTableSettings.__new(ctype)
    local ptr = lib.ImGuiTableSettings_ImGuiTableSettings()
    return ffi.gc(ptr,lib.ImGuiTableSettings_destroy)
end
M.ImGuiTableSettings = ffi.metatype("ImGuiTableSettings",ImGuiTableSettings)
--------------------------ImGuiTableSortSpecs----------------------------
---@class ImGuiTableSortSpecs
local ImGuiTableSortSpecs= {}
ImGuiTableSortSpecs.__index = ImGuiTableSortSpecs
function ImGuiTableSortSpecs.__new(ctype)
    local ptr = lib.ImGuiTableSortSpecs_ImGuiTableSortSpecs()
    return ffi.gc(ptr,lib.ImGuiTableSortSpecs_destroy)
end
M.ImGuiTableSortSpecs = ffi.metatype("ImGuiTableSortSpecs",ImGuiTableSortSpecs)
--------------------------ImGuiTableTempData----------------------------
---@class ImGuiTableTempData
local ImGuiTableTempData= {}
ImGuiTableTempData.__index = ImGuiTableTempData
function ImGuiTableTempData.__new(ctype)
    local ptr = lib.ImGuiTableTempData_ImGuiTableTempData()
    return ffi.gc(ptr,lib.ImGuiTableTempData_destroy)
end
M.ImGuiTableTempData = ffi.metatype("ImGuiTableTempData",ImGuiTableTempData)
--------------------------ImGuiTextBuffer----------------------------
---@class ImGuiTextBuffer
local ImGuiTextBuffer= {}
ImGuiTextBuffer.__index = ImGuiTextBuffer
function ImGuiTextBuffer.__new(ctype)
    local ptr = lib.ImGuiTextBuffer_ImGuiTextBuffer()
    return ffi.gc(ptr,lib.ImGuiTextBuffer_destroy)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param str string
---@param str_end string?
---@return nil
function ImGuiTextBuffer:append(str,str_end)
    str_end = str_end or nil
    return lib.ImGuiTextBuffer_append(self,str,str_end)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param fmt string
---@return nil
function ImGuiTextBuffer:appendf(fmt,...)
    return lib.ImGuiTextBuffer_appendf(self,fmt,...)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function ImGuiTextBuffer:appendfv(fmt,args)
    return lib.ImGuiTextBuffer_appendfv(self,fmt,args)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:begin()
    return ffi.string(lib.ImGuiTextBuffer_begin(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:c_str()
    return ffi.string(lib.ImGuiTextBuffer_c_str(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return nil
function ImGuiTextBuffer:clear()
    return lib.ImGuiTextBuffer_clear(self)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return boolean
function ImGuiTextBuffer:empty()
    return lib.ImGuiTextBuffer_empty(self)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return string
function ImGuiTextBuffer:_end()
    return ffi.string(lib.ImGuiTextBuffer_end(self))
end
---@param self ffi.ct* ImGuiTextBuffer*
---@param capacity number int
---@return nil
function ImGuiTextBuffer:reserve(capacity)
    return lib.ImGuiTextBuffer_reserve(self,capacity)
end
---@param self ffi.ct* ImGuiTextBuffer*
---@return number int
function ImGuiTextBuffer:size()
    return lib.ImGuiTextBuffer_size(self)
end
M.ImGuiTextBuffer = ffi.metatype("ImGuiTextBuffer",ImGuiTextBuffer)
--------------------------ImGuiTextFilter----------------------------
---@class ImGuiTextFilter
local ImGuiTextFilter= {}
ImGuiTextFilter.__index = ImGuiTextFilter
---@param self ffi.ct* ImGuiTextFilter*
---@return nil
function ImGuiTextFilter:Build()
    return lib.ImGuiTextFilter_Build(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@return nil
function ImGuiTextFilter:Clear()
    return lib.ImGuiTextFilter_Clear(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@param label string?
---@param width number? float
---@return boolean
function ImGuiTextFilter:Draw(label,width)
    label = label or "Filter(inc,-exc)"
    width = width or 0.0
    return lib.ImGuiTextFilter_Draw(self,label,width)
end
function ImGuiTextFilter.__new(ctype,default_filter)
    if default_filter == nil then default_filter = "" end
    local ptr = lib.ImGuiTextFilter_ImGuiTextFilter(default_filter)
    return ffi.gc(ptr,lib.ImGuiTextFilter_destroy)
end
---@param self ffi.ct* ImGuiTextFilter*
---@return boolean
function ImGuiTextFilter:IsActive()
    return lib.ImGuiTextFilter_IsActive(self)
end
---@param self ffi.ct* ImGuiTextFilter*
---@param text string
---@param text_end string?
---@return boolean
function ImGuiTextFilter:PassFilter(text,text_end)
    text_end = text_end or nil
    return lib.ImGuiTextFilter_PassFilter(self,text,text_end)
end
M.ImGuiTextFilter = ffi.metatype("ImGuiTextFilter",ImGuiTextFilter)
--------------------------ImGuiTextIndex----------------------------
---@class ImGuiTextIndex
local ImGuiTextIndex= {}
ImGuiTextIndex.__index = ImGuiTextIndex
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param old_size number int
---@param new_size number int
---@return nil
function ImGuiTextIndex:append(base,old_size,new_size)
    return lib.ImGuiTextIndex_append(self,base,old_size,new_size)
end
---@param self ffi.ct* ImGuiTextIndex*
---@return nil
function ImGuiTextIndex:clear()
    return lib.ImGuiTextIndex_clear(self)
end
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param n number int
---@return string
function ImGuiTextIndex:get_line_begin(base,n)
    return ffi.string(lib.ImGuiTextIndex_get_line_begin(self,base,n))
end
---@param self ffi.ct* ImGuiTextIndex*
---@param base string
---@param n number int
---@return string
function ImGuiTextIndex:get_line_end(base,n)
    return ffi.string(lib.ImGuiTextIndex_get_line_end(self,base,n))
end
---@param self ffi.ct* ImGuiTextIndex*
---@return number int
function ImGuiTextIndex:size()
    return lib.ImGuiTextIndex_size(self)
end
M.ImGuiTextIndex = ffi.metatype("ImGuiTextIndex",ImGuiTextIndex)
--------------------------ImGuiTextRange----------------------------
---@class ImGuiTextRange
local ImGuiTextRange= {}
ImGuiTextRange.__index = ImGuiTextRange
function ImGuiTextRange.ImGuiTextRange_Nil()
    local ptr = lib.ImGuiTextRange_ImGuiTextRange_Nil()
    return ffi.gc(ptr,lib.ImGuiTextRange_destroy)
end
function ImGuiTextRange.ImGuiTextRange_Str(_b,_e)
    local ptr = lib.ImGuiTextRange_ImGuiTextRange_Str(_b,_e)
    return ffi.gc(ptr,lib.ImGuiTextRange_destroy)
end
function ImGuiTextRange.__new(ctype,a1,a2) -- generic version
    if a1==nil then return ImGuiTextRange.ImGuiTextRange_Nil() end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return ImGuiTextRange.ImGuiTextRange_Str(a1,a2) end
    print(ctype,a1,a2)
    error'ImGuiTextRange.__new could not find overloaded'
end
---@param self ffi.ct* ImGuiTextRange*
---@return boolean
function ImGuiTextRange:empty()
    return lib.ImGuiTextRange_empty(self)
end
---@param self ffi.ct* ImGuiTextRange*
---@param separator number char
---@param out ffi.ct* ImVector_ImGuiTextRange*
---@return nil
function ImGuiTextRange:split(separator,out)
    return lib.ImGuiTextRange_split(self,separator,out)
end
M.ImGuiTextRange = ffi.metatype("ImGuiTextRange",ImGuiTextRange)
--------------------------ImGuiTypingSelectState----------------------------
---@class ImGuiTypingSelectState
local ImGuiTypingSelectState= {}
ImGuiTypingSelectState.__index = ImGuiTypingSelectState
---@param self ffi.ct* ImGuiTypingSelectState*
---@return nil
function ImGuiTypingSelectState:Clear()
    return lib.ImGuiTypingSelectState_Clear(self)
end
function ImGuiTypingSelectState.__new(ctype)
    local ptr = lib.ImGuiTypingSelectState_ImGuiTypingSelectState()
    return ffi.gc(ptr,lib.ImGuiTypingSelectState_destroy)
end
M.ImGuiTypingSelectState = ffi.metatype("ImGuiTypingSelectState",ImGuiTypingSelectState)
--------------------------ImGuiViewport----------------------------
---@class ImGuiViewport
local ImGuiViewport= {}
ImGuiViewport.__index = ImGuiViewport
---@param self ffi.ct* ImGuiViewport*
---@return nil
function ImGuiViewport:GetCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewport_GetCenter(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewport*
---@return nil
function ImGuiViewport:GetWorkCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewport_GetWorkCenter(nonUDT_out,self)
    return nonUDT_out
end
function ImGuiViewport.__new(ctype)
    local ptr = lib.ImGuiViewport_ImGuiViewport()
    return ffi.gc(ptr,lib.ImGuiViewport_destroy)
end
M.ImGuiViewport = ffi.metatype("ImGuiViewport",ImGuiViewport)
--------------------------ImGuiViewportP----------------------------
---@class ImGuiViewportP
local ImGuiViewportP= {}
ImGuiViewportP.__index = ImGuiViewportP
---@param self ffi.ct* ImGuiViewportP*
---@param off_min ImVec2
---@return nil
function ImGuiViewportP:CalcWorkRectPos(off_min)
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewportP_CalcWorkRectPos(nonUDT_out,self,off_min)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@param off_min ImVec2
---@param off_max ImVec2
---@return nil
function ImGuiViewportP:CalcWorkRectSize(off_min,off_max)
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImGuiViewportP_CalcWorkRectSize(nonUDT_out,self,off_min,off_max)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:ClearRequestFlags()
    return lib.ImGuiViewportP_ClearRequestFlags(self)
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetBuildWorkRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetBuildWorkRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetMainRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetMainRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:GetWorkRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiViewportP_GetWorkRect(nonUDT_out,self)
    return nonUDT_out
end
function ImGuiViewportP.__new(ctype)
    local ptr = lib.ImGuiViewportP_ImGuiViewportP()
    return ffi.gc(ptr,lib.ImGuiViewportP_destroy)
end
---@param self ffi.ct* ImGuiViewportP*
---@return nil
function ImGuiViewportP:UpdateWorkRect()
    return lib.ImGuiViewportP_UpdateWorkRect(self)
end
M.ImGuiViewportP = ffi.metatype("ImGuiViewportP",ImGuiViewportP)
--------------------------ImGuiWindow----------------------------
---@class ImGuiWindow
local ImGuiWindow= {}
ImGuiWindow.__index = ImGuiWindow
---@param self ffi.ct* ImGuiWindow*
---@return number float
function ImGuiWindow:CalcFontSize()
    return lib.ImGuiWindow_CalcFontSize(self)
end
---@param self ffi.ct* ImGuiWindow*
---@param str string
---@param str_end string?
---@return number ImGuiID
function ImGuiWindow:GetID_Str(str,str_end)
    str_end = str_end or nil
    return lib.ImGuiWindow_GetID_Str(self,str,str_end)
end
---@param self ffi.ct* ImGuiWindow*
---@param ptr ffi.ct* const void*
---@return number ImGuiID
function ImGuiWindow:GetID_Ptr(ptr)
    return lib.ImGuiWindow_GetID_Ptr(self,ptr)
end
---@param self ffi.ct* ImGuiWindow*
---@param n number int
---@return number ImGuiID
function ImGuiWindow:GetID_Int(n)
    return lib.ImGuiWindow_GetID_Int(self,n)
end
function ImGuiWindow:GetID(a2,a3) -- generic version
    if (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return self:GetID_Str(a2,a3) end
    if ffi.istype('void *',a2) then return self:GetID_Ptr(a2) end
    if (ffi.istype('int32_t',a2) or type(a2)=='number') then return self:GetID_Int(a2) end
    print(a2,a3)
    error'ImGuiWindow:GetID could not find overloaded'
end
---@param self ffi.ct* ImGuiWindow*
---@param r_abs ImRect
---@return number ImGuiID
function ImGuiWindow:GetIDFromRectangle(r_abs)
    return lib.ImGuiWindow_GetIDFromRectangle(self,r_abs)
end
function ImGuiWindow.__new(ctype,context,name)
    local ptr = lib.ImGuiWindow_ImGuiWindow(context,name)
    return ffi.gc(ptr,lib.ImGuiWindow_destroy)
end
---@param self ffi.ct* ImGuiWindow*
---@return number float
function ImGuiWindow:MenuBarHeight()
    return lib.ImGuiWindow_MenuBarHeight(self)
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:MenuBarRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_MenuBarRect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:Rect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_Rect(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImGuiWindow*
---@return number float
function ImGuiWindow:TitleBarHeight()
    return lib.ImGuiWindow_TitleBarHeight(self)
end
---@param self ffi.ct* ImGuiWindow*
---@return nil
function ImGuiWindow:TitleBarRect()
    local nonUDT_out = ffi.new("ImRect")
    lib.ImGuiWindow_TitleBarRect(nonUDT_out,self)
    return nonUDT_out
end
M.ImGuiWindow = ffi.metatype("ImGuiWindow",ImGuiWindow)
--------------------------ImGuiWindowClass----------------------------
---@class ImGuiWindowClass
local ImGuiWindowClass= {}
ImGuiWindowClass.__index = ImGuiWindowClass
function ImGuiWindowClass.__new(ctype)
    local ptr = lib.ImGuiWindowClass_ImGuiWindowClass()
    return ffi.gc(ptr,lib.ImGuiWindowClass_destroy)
end
M.ImGuiWindowClass = ffi.metatype("ImGuiWindowClass",ImGuiWindowClass)
--------------------------ImGuiWindowSettings----------------------------
---@class ImGuiWindowSettings
local ImGuiWindowSettings= {}
ImGuiWindowSettings.__index = ImGuiWindowSettings
---@param self ffi.ct* ImGuiWindowSettings*
---@return ffi.ct* char*
function ImGuiWindowSettings:GetName()
    return lib.ImGuiWindowSettings_GetName(self)
end
function ImGuiWindowSettings.__new(ctype)
    local ptr = lib.ImGuiWindowSettings_ImGuiWindowSettings()
    return ffi.gc(ptr,lib.ImGuiWindowSettings_destroy)
end
M.ImGuiWindowSettings = ffi.metatype("ImGuiWindowSettings",ImGuiWindowSettings)
--------------------------ImRect----------------------------
---@class ImRect
local ImRect= {}
ImRect.__index = ImRect
---@param self ffi.ct* ImRect*
---@param p ImVec2
---@return nil
function ImRect:Add_Vec2(p)
    return lib.ImRect_Add_Vec2(self,p)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:Add_Rect(r)
    return lib.ImRect_Add_Rect(self,r)
end
function ImRect:Add(a2) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:Add_Vec2(a2) end
    if ffi.istype('const ImRect',a2) then return self:Add_Rect(a2) end
    print(a2)
    error'ImRect:Add could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:ClipWith(r)
    return lib.ImRect_ClipWith(self,r)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return nil
function ImRect:ClipWithFull(r)
    return lib.ImRect_ClipWithFull(self,r)
end
---@param self ffi.ct* ImRect*
---@param p ImVec2
---@return boolean
function ImRect:Contains_Vec2(p)
    return lib.ImRect_Contains_Vec2(self,p)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return boolean
function ImRect:Contains_Rect(r)
    return lib.ImRect_Contains_Rect(self,r)
end
function ImRect:Contains(a2) -- generic version
    if ffi.istype('const ImVec2',a2) then return self:Contains_Vec2(a2) end
    if ffi.istype('const ImRect',a2) then return self:Contains_Rect(a2) end
    print(a2)
    error'ImRect:Contains could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@param p ImVec2
---@param pad ImVec2
---@return boolean
function ImRect:ContainsWithPad(p,pad)
    return lib.ImRect_ContainsWithPad(self,p,pad)
end
---@param self ffi.ct* ImRect*
---@param amount number const float
---@return nil
function ImRect:Expand_Float(amount)
    return lib.ImRect_Expand_Float(self,amount)
end
---@param self ffi.ct* ImRect*
---@param amount ImVec2
---@return nil
function ImRect:Expand_Vec2(amount)
    return lib.ImRect_Expand_Vec2(self,amount)
end
function ImRect:Expand(a2) -- generic version
    if (ffi.istype('float',a2) or type(a2)=='number') then return self:Expand_Float(a2) end
    if ffi.istype('const ImVec2',a2) then return self:Expand_Vec2(a2) end
    print(a2)
    error'ImRect:Expand could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:Floor()
    return lib.ImRect_Floor(self)
end
---@param self ffi.ct* ImRect*
---@return number float
function ImRect:GetArea()
    return lib.ImRect_GetArea(self)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetBL()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetBL(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetBR()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetBR(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetCenter()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetCenter(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return number float
function ImRect:GetHeight()
    return lib.ImRect_GetHeight(self)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetSize(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetTL()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetTL(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:GetTR()
    local nonUDT_out = ffi.new("ImVec2")
    lib.ImRect_GetTR(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@return number float
function ImRect:GetWidth()
    return lib.ImRect_GetWidth(self)
end
function ImRect.ImRect_Nil()
    local ptr = lib.ImRect_ImRect_Nil()
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Vec2(min,max)
    local ptr = lib.ImRect_ImRect_Vec2(min,max)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Vec4(v)
    local ptr = lib.ImRect_ImRect_Vec4(v)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.ImRect_Float(x1,y1,x2,y2)
    local ptr = lib.ImRect_ImRect_Float(x1,y1,x2,y2)
    return ffi.gc(ptr,lib.ImRect_destroy)
end
function ImRect.__new(ctype,a1,a2,a3,a4) -- generic version
    if a1==nil then return ImRect.ImRect_Nil() end
    if ffi.istype('const ImVec2',a1) then return ImRect.ImRect_Vec2(a1,a2) end
    if ffi.istype('const ImVec4',a1) then return ImRect.ImRect_Vec4(a1) end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImRect.ImRect_Float(a1,a2,a3,a4) end
    print(ctype,a1,a2,a3,a4)
    error'ImRect.__new could not find overloaded'
end
---@param self ffi.ct* ImRect*
---@return boolean
function ImRect:IsInverted()
    return lib.ImRect_IsInverted(self)
end
---@param self ffi.ct* ImRect*
---@param r ImRect
---@return boolean
function ImRect:Overlaps(r)
    return lib.ImRect_Overlaps(self,r)
end
---@param self ffi.ct* ImRect*
---@return nil
function ImRect:ToVec4()
    local nonUDT_out = ffi.new("ImVec4")
    lib.ImRect_ToVec4(nonUDT_out,self)
    return nonUDT_out
end
---@param self ffi.ct* ImRect*
---@param d ImVec2
---@return nil
function ImRect:Translate(d)
    return lib.ImRect_Translate(self,d)
end
---@param self ffi.ct* ImRect*
---@param dx number float
---@return nil
function ImRect:TranslateX(dx)
    return lib.ImRect_TranslateX(self,dx)
end
---@param self ffi.ct* ImRect*
---@param dy number float
---@return nil
function ImRect:TranslateY(dy)
    return lib.ImRect_TranslateY(self,dy)
end
M.ImRect = ffi.metatype("ImRect",ImRect)
--------------------------ImVec1----------------------------
---@class ImVec1
local ImVec1= {}
ImVec1.__index = ImVec1
function ImVec1.ImVec1_Nil()
    local ptr = lib.ImVec1_ImVec1_Nil()
    return ffi.gc(ptr,lib.ImVec1_destroy)
end
function ImVec1.ImVec1_Float(_x)
    local ptr = lib.ImVec1_ImVec1_Float(_x)
    return ffi.gc(ptr,lib.ImVec1_destroy)
end
function ImVec1.__new(ctype,a1) -- generic version
    if a1==nil then return ImVec1.ImVec1_Nil() end
    if (ffi.istype('float',a1) or type(a1)=='number') then return ImVec1.ImVec1_Float(a1) end
    print(ctype,a1)
    error'ImVec1.__new could not find overloaded'
end
M.ImVec1 = ffi.metatype("ImVec1",ImVec1)
--------------------------ImVec2ih----------------------------
---@class ImVec2ih
local ImVec2ih= {}
ImVec2ih.__index = ImVec2ih
function ImVec2ih.ImVec2ih_Nil()
    local ptr = lib.ImVec2ih_ImVec2ih_Nil()
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.ImVec2ih_short(_x,_y)
    local ptr = lib.ImVec2ih_ImVec2ih_short(_x,_y)
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.ImVec2ih_Vec2(rhs)
    local ptr = lib.ImVec2ih_ImVec2ih_Vec2(rhs)
    return ffi.gc(ptr,lib.ImVec2ih_destroy)
end
function ImVec2ih.__new(ctype,a1,a2) -- generic version
    if a1==nil then return ImVec2ih.ImVec2ih_Nil() end
    if (ffi.istype('int16_t',a1) or type(a1)=='number') then return ImVec2ih.ImVec2ih_short(a1,a2) end
    if ffi.istype('const ImVec2',a1) then return ImVec2ih.ImVec2ih_Vec2(a1) end
    print(ctype,a1,a2)
    error'ImVec2ih.__new could not find overloaded'
end
M.ImVec2ih = ffi.metatype("ImVec2ih",ImVec2ih)
------------------------------------------------------
---@param type string
---@param flags DragDropFlags?
---@return ffi.ct* const ImGuiPayload*
function M.AcceptDragDropPayload(type,flags)
    flags = flags or 0
    return lib.igAcceptDragDropPayload(type,flags)
end
---@param id number ImGuiID
---@return nil
function M.ActivateItemByID(id)
    return lib.igActivateItemByID(id)
end
---@param context ffi.ct* ImGuiContext*
---@param hook ffi.ct* const ImGuiContextHook*
---@return number ImGuiID
function M.AddContextHook(context,hook)
    return lib.igAddContextHook(context,hook)
end
---@param draw_data ffi.ct* ImDrawData*
---@param out_list ffi.ct* ImVector_ImDrawListPtr*
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function M.AddDrawListToDrawDataEx(draw_data,out_list,draw_list)
    return lib.igAddDrawListToDrawDataEx(draw_data,out_list,draw_list)
end
---@param handler ffi.ct* const ImGuiSettingsHandler*
---@return nil
function M.AddSettingsHandler(handler)
    return lib.igAddSettingsHandler(handler)
end
---@return nil
function M.AlignTextToFramePadding()
    return lib.igAlignTextToFramePadding()
end
---@param str_id string
---@param dir Dir
---@return boolean
function M.ArrowButton(str_id,dir)
    return lib.igArrowButton(str_id,dir)
end
---@param str_id string
---@param dir Dir
---@param size_arg ImVec2
---@param flags ButtonFlags?
---@return boolean
function M.ArrowButtonEx(str_id,dir,size_arg,flags)
    flags = flags or 0
    return lib.igArrowButtonEx(str_id,dir,size_arg,flags)
end
---@param name string
---@param p_open ffi.ct*? bool*
---@param flags WindowFlags?
---@return boolean
function M.Begin(name,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBegin(name,p_open,flags)
end
---@param str_id string
---@param size ImVec2?
---@param child_flags ChildFlags?
---@param window_flags WindowFlags?
---@return boolean
function M.BeginChild_Str(str_id,size,child_flags,window_flags)
    child_flags = child_flags or 0
    size = size or ImVec2(0,0)
    window_flags = window_flags or 0
    return lib.igBeginChild_Str(str_id,size,child_flags,window_flags)
end
---@param id number ImGuiID
---@param size ImVec2?
---@param child_flags ChildFlags?
---@param window_flags WindowFlags?
---@return boolean
function M.BeginChild_ID(id,size,child_flags,window_flags)
    child_flags = child_flags or 0
    size = size or ImVec2(0,0)
    window_flags = window_flags or 0
    return lib.igBeginChild_ID(id,size,child_flags,window_flags)
end
function M.BeginChild(a1,a2,a3,a4) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.BeginChild_Str(a1,a2,a3,a4) end
    if (ffi.istype('uint32_t',a1) or type(a1)=='number') then return M.BeginChild_ID(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.BeginChild could not find overloaded'
end
---@param name string
---@param id number ImGuiID
---@param size_arg ImVec2
---@param child_flags ChildFlags
---@param window_flags WindowFlags
---@return boolean
function M.BeginChildEx(name,id,size_arg,child_flags,window_flags)
    return lib.igBeginChildEx(name,id,size_arg,child_flags,window_flags)
end
---@param str_id string
---@param count number int
---@param flags OldColumnFlags?
---@return nil
function M.BeginColumns(str_id,count,flags)
    flags = flags or 0
    return lib.igBeginColumns(str_id,count,flags)
end
---@param label string
---@param preview_value string
---@param flags ComboFlags?
---@return boolean
function M.BeginCombo(label,preview_value,flags)
    flags = flags or 0
    return lib.igBeginCombo(label,preview_value,flags)
end
---@param popup_id number ImGuiID
---@param bb ImRect
---@param flags ComboFlags
---@return boolean
function M.BeginComboPopup(popup_id,bb,flags)
    return lib.igBeginComboPopup(popup_id,bb,flags)
end
---@return boolean
function M.BeginComboPreview()
    return lib.igBeginComboPreview()
end
---@param disabled boolean?
---@return nil
function M.BeginDisabled(disabled)
    if disabled == nil then disabled = true end
    return lib.igBeginDisabled(disabled)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BeginDockableDragDropSource(window)
    return lib.igBeginDockableDragDropSource(window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BeginDockableDragDropTarget(window)
    return lib.igBeginDockableDragDropTarget(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param p_open ffi.ct* bool*
---@return nil
function M.BeginDocked(window,p_open)
    return lib.igBeginDocked(window,p_open)
end
---@param flags DragDropFlags?
---@return boolean
function M.BeginDragDropSource(flags)
    flags = flags or 0
    return lib.igBeginDragDropSource(flags)
end
---@return boolean
function M.BeginDragDropTarget()
    return lib.igBeginDragDropTarget()
end
---@param bb ImRect
---@param id number ImGuiID
---@return boolean
function M.BeginDragDropTargetCustom(bb,id)
    return lib.igBeginDragDropTargetCustom(bb,id)
end
---@return nil
function M.BeginGroup()
    return lib.igBeginGroup()
end
---@return boolean
function M.BeginItemTooltip()
    return lib.igBeginItemTooltip()
end
---@param label string
---@param size ImVec2?
---@return boolean
function M.BeginListBox(label,size)
    size = size or ImVec2(0,0)
    return lib.igBeginListBox(label,size)
end
---@return boolean
function M.BeginMainMenuBar()
    return lib.igBeginMainMenuBar()
end
---@param label string
---@param enabled boolean?
---@return boolean
function M.BeginMenu(label,enabled)
    if enabled == nil then enabled = true end
    return lib.igBeginMenu(label,enabled)
end
---@return boolean
function M.BeginMenuBar()
    return lib.igBeginMenuBar()
end
---@param label string
---@param icon string
---@param enabled boolean?
---@return boolean
function M.BeginMenuEx(label,icon,enabled)
    if enabled == nil then enabled = true end
    return lib.igBeginMenuEx(label,icon,enabled)
end
---@param str_id string
---@param flags WindowFlags?
---@return boolean
function M.BeginPopup(str_id,flags)
    flags = flags or 0
    return lib.igBeginPopup(str_id,flags)
end
---@param str_id string?
---@param popup_flags PopupFlags?
---@return boolean
function M.BeginPopupContextItem(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextItem(str_id,popup_flags)
end
---@param str_id string?
---@param popup_flags PopupFlags?
---@return boolean
function M.BeginPopupContextVoid(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextVoid(str_id,popup_flags)
end
---@param str_id string?
---@param popup_flags PopupFlags?
---@return boolean
function M.BeginPopupContextWindow(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igBeginPopupContextWindow(str_id,popup_flags)
end
---@param id number ImGuiID
---@param extra_flags WindowFlags
---@return boolean
function M.BeginPopupEx(id,extra_flags)
    return lib.igBeginPopupEx(id,extra_flags)
end
---@param name string
---@param p_open ffi.ct*? bool*
---@param flags WindowFlags?
---@return boolean
function M.BeginPopupModal(name,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBeginPopupModal(name,p_open,flags)
end
---@param str_id string
---@param flags TabBarFlags?
---@return boolean
function M.BeginTabBar(str_id,flags)
    flags = flags or 0
    return lib.igBeginTabBar(str_id,flags)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param bb ImRect
---@param flags TabBarFlags
---@return boolean
function M.BeginTabBarEx(tab_bar,bb,flags)
    return lib.igBeginTabBarEx(tab_bar,bb,flags)
end
---@param label string
---@param p_open ffi.ct*? bool*
---@param flags TabItemFlags?
---@return boolean
function M.BeginTabItem(label,p_open,flags)
    flags = flags or 0
    p_open = p_open or nil
    return lib.igBeginTabItem(label,p_open,flags)
end
---@param str_id string
---@param column number int
---@param flags TableFlags?
---@param outer_size ImVec2?
---@param inner_width number? float
---@return boolean
function M.BeginTable(str_id,column,flags,outer_size,inner_width)
    flags = flags or 0
    inner_width = inner_width or 0.0
    outer_size = outer_size or ImVec2(0.0,0.0)
    return lib.igBeginTable(str_id,column,flags,outer_size,inner_width)
end
---@param name string
---@param id number ImGuiID
---@param columns_count number int
---@param flags TableFlags?
---@param outer_size ImVec2?
---@param inner_width number? float
---@return boolean
function M.BeginTableEx(name,id,columns_count,flags,outer_size,inner_width)
    flags = flags or 0
    inner_width = inner_width or 0.0
    outer_size = outer_size or ImVec2(0,0)
    return lib.igBeginTableEx(name,id,columns_count,flags,outer_size,inner_width)
end
---@return boolean
function M.BeginTooltip()
    return lib.igBeginTooltip()
end
---@param tooltip_flags TooltipFlags
---@param extra_window_flags WindowFlags
---@return boolean
function M.BeginTooltipEx(tooltip_flags,extra_window_flags)
    return lib.igBeginTooltipEx(tooltip_flags,extra_window_flags)
end
---@return boolean
function M.BeginTooltipHidden()
    return lib.igBeginTooltipHidden()
end
---@param name string
---@param viewport ffi.ct* ImGuiViewport*
---@param dir Dir
---@param size number float
---@param window_flags WindowFlags
---@return boolean
function M.BeginViewportSideBar(name,viewport,dir,size,window_flags)
    return lib.igBeginViewportSideBar(name,viewport,dir,size,window_flags)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayBack(window)
    return lib.igBringWindowToDisplayBack(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param above_window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayBehind(window,above_window)
    return lib.igBringWindowToDisplayBehind(window,above_window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToDisplayFront(window)
    return lib.igBringWindowToDisplayFront(window)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.BringWindowToFocusFront(window)
    return lib.igBringWindowToFocusFront(window)
end
---@return nil
function M.Bullet()
    return lib.igBullet()
end
---@param fmt string
---@return nil
function M.BulletText(fmt,...)
    return lib.igBulletText(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.BulletTextV(fmt,args)
    return lib.igBulletTextV(fmt,args)
end
---@param label string
---@param size ImVec2?
---@return boolean
function M.Button(label,size)
    size = size or ImVec2(0,0)
    return lib.igButton(label,size)
end
---@param bb ImRect
---@param id number ImGuiID
---@param out_hovered ffi.ct* bool*
---@param out_held ffi.ct* bool*
---@param flags ButtonFlags?
---@return boolean
function M.ButtonBehavior(bb,id,out_hovered,out_held,flags)
    flags = flags or 0
    return lib.igButtonBehavior(bb,id,out_hovered,out_held,flags)
end
---@param label string
---@param size_arg ImVec2?
---@param flags ButtonFlags?
---@return boolean
function M.ButtonEx(label,size_arg,flags)
    flags = flags or 0
    size_arg = size_arg or ImVec2(0,0)
    return lib.igButtonEx(label,size_arg,flags)
end
---@param size ImVec2
---@param default_w number float
---@param default_h number float
---@return nil
function M.CalcItemSize(size,default_w,default_h)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcItemSize(nonUDT_out,size,default_w,default_h)
    return nonUDT_out
end
---@return number float
function M.CalcItemWidth()
    return lib.igCalcItemWidth()
end
---@param r_in ImRect
---@param r_outer ImRect
---@param threshold number float
---@return ImDrawFlags
function M.CalcRoundingFlagsForRectInRect(r_in,r_outer,threshold)
    return lib.igCalcRoundingFlagsForRectInRect(r_in,r_outer,threshold)
end
---@param text string
---@param text_end string?
---@param hide_text_after_double_hash boolean?
---@param wrap_width number? float
---@return nil
function M.CalcTextSize(text,text_end,hide_text_after_double_hash,wrap_width)
    hide_text_after_double_hash = hide_text_after_double_hash or false
    text_end = text_end or nil
    wrap_width = wrap_width or -1.0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcTextSize(nonUDT_out,text,text_end,hide_text_after_double_hash,wrap_width)
    return nonUDT_out
end
---@param t0 number float
---@param t1 number float
---@param repeat_delay number float
---@param repeat_rate number float
---@return number int
function M.CalcTypematicRepeatAmount(t0,t1,repeat_delay,repeat_rate)
    return lib.igCalcTypematicRepeatAmount(t0,t1,repeat_delay,repeat_rate)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.CalcWindowNextAutoFitSize(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igCalcWindowNextAutoFitSize(nonUDT_out,window)
    return nonUDT_out
end
---@param pos ImVec2
---@param wrap_pos_x number float
---@return number float
function M.CalcWrapWidthForPos(pos,wrap_pos_x)
    return lib.igCalcWrapWidthForPos(pos,wrap_pos_x)
end
---@param context ffi.ct* ImGuiContext*
---@param type ContextHookType
---@return nil
function M.CallContextHooks(context,type)
    return lib.igCallContextHooks(context,type)
end
---@param label string
---@param v ffi.ct* bool*
---@return boolean
function M.Checkbox(label,v)
    return lib.igCheckbox(label,v)
end
---@param label string
---@param flags ffi.ct* int*
---@param flags_value number int
---@return boolean
function M.CheckboxFlags_IntPtr(label,flags,flags_value)
    return lib.igCheckboxFlags_IntPtr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* unsigned int*
---@param flags_value number unsigned int
---@return boolean
function M.CheckboxFlags_UintPtr(label,flags,flags_value)
    return lib.igCheckboxFlags_UintPtr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* ImS64*
---@param flags_value number ImS64
---@return boolean
function M.CheckboxFlags_S64Ptr(label,flags,flags_value)
    return lib.igCheckboxFlags_S64Ptr(label,flags,flags_value)
end
---@param label string
---@param flags ffi.ct* ImU64*
---@param flags_value number ImU64
---@return boolean
function M.CheckboxFlags_U64Ptr(label,flags,flags_value)
    return lib.igCheckboxFlags_U64Ptr(label,flags,flags_value)
end
function M.CheckboxFlags(a1,a2,a3) -- generic version
    if ffi.typeof('int32_t*') == ffi.typeof(a2) or ffi.typeof('const int32_t*') == ffi.typeof(a2) or ffi.typeof('int32_t[?]') == ffi.typeof(a2) or ffi.typeof('const int32_t[?]') == ffi.typeof(a2) then return M.CheckboxFlags_IntPtr(a1,a2,a3) end
    if ffi.typeof('uint32_t*') == ffi.typeof(a2) or ffi.typeof('const uint32_t*') == ffi.typeof(a2) or ffi.typeof('uint32_t[?]') == ffi.typeof(a2) or ffi.typeof('const uint32_t[?]') == ffi.typeof(a2) then return M.CheckboxFlags_UintPtr(a1,a2,a3) end
    if ffi.typeof('int64_t*') == ffi.typeof(a2) or ffi.typeof('const int64_t*') == ffi.typeof(a2) or ffi.typeof('int64_t[?]') == ffi.typeof(a2) or ffi.typeof('const int64_t[?]') == ffi.typeof(a2) then return M.CheckboxFlags_S64Ptr(a1,a2,a3) end
    if ffi.typeof('uint64_t*') == ffi.typeof(a2) or ffi.typeof('const uint64_t*') == ffi.typeof(a2) or ffi.typeof('uint64_t[?]') == ffi.typeof(a2) or ffi.typeof('const uint64_t[?]') == ffi.typeof(a2) then return M.CheckboxFlags_U64Ptr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.CheckboxFlags could not find overloaded'
end
---@return nil
function M.ClearActiveID()
    return lib.igClearActiveID()
end
---@return nil
function M.ClearDragDrop()
    return lib.igClearDragDrop()
end
---@return nil
function M.ClearIniSettings()
    return lib.igClearIniSettings()
end
---@param name string
---@return nil
function M.ClearWindowSettings(name)
    return lib.igClearWindowSettings(name)
end
---@param id number ImGuiID
---@param pos ImVec2
---@return boolean
function M.CloseButton(id,pos)
    return lib.igCloseButton(id,pos)
end
---@return nil
function M.CloseCurrentPopup()
    return lib.igCloseCurrentPopup()
end
---@param remaining number int
---@param restore_focus_to_window_under_popup boolean
---@return nil
function M.ClosePopupToLevel(remaining,restore_focus_to_window_under_popup)
    return lib.igClosePopupToLevel(remaining,restore_focus_to_window_under_popup)
end
---@return nil
function M.ClosePopupsExceptModals()
    return lib.igClosePopupsExceptModals()
end
---@param ref_window ffi.ct* ImGuiWindow*
---@param restore_focus_to_window_under_popup boolean
---@return nil
function M.ClosePopupsOverWindow(ref_window,restore_focus_to_window_under_popup)
    return lib.igClosePopupsOverWindow(ref_window,restore_focus_to_window_under_popup)
end
---@param id number ImGuiID
---@param pos ImVec2
---@param dock_node ffi.ct* ImGuiDockNode*
---@return boolean
function M.CollapseButton(id,pos,dock_node)
    return lib.igCollapseButton(id,pos,dock_node)
end
---@param label string
---@param flags TreeNodeFlags?
---@return boolean
function M.CollapsingHeader_TreeNodeFlags(label,flags)
    flags = flags or 0
    return lib.igCollapsingHeader_TreeNodeFlags(label,flags)
end
---@param label string
---@param p_visible ffi.ct* bool*
---@param flags TreeNodeFlags?
---@return boolean
function M.CollapsingHeader_BoolPtr(label,p_visible,flags)
    flags = flags or 0
    return lib.igCollapsingHeader_BoolPtr(label,p_visible,flags)
end
function M.CollapsingHeader(a1,a2,a3) -- generic version
    if ((ffi.istype('int32_t',a2) or type(a2)=='number') or type(a2)=='nil') then return M.CollapsingHeader_TreeNodeFlags(a1,a2) end
    if (ffi.istype('bool*',a2) or ffi.istype('bool[]',a2)) then return M.CollapsingHeader_BoolPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.CollapsingHeader could not find overloaded'
end
---@param desc_id string
---@param col ffi.ct* const ImVec4
---@param flags ColorEditFlags?
---@param size ImVec2?
---@return boolean
function M.ColorButton(desc_id,col,flags,size)
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igColorButton(desc_id,col,flags,size)
end
---@param _in ffi.ct* const ImVec4
---@return number ImU32
function M.ColorConvertFloat4ToU32(_in)
    return lib.igColorConvertFloat4ToU32(_in)
end
---@param h number float
---@param s number float
---@param v number float
---@param out_r ffi.ct* float*
---@param out_g ffi.ct* float*
---@param out_b ffi.ct* float*
---@return nil
function M.ColorConvertHSVtoRGB(h,s,v,out_r,out_g,out_b)
    return lib.igColorConvertHSVtoRGB(h,s,v,out_r,out_g,out_b)
end
---@param r number float
---@param g number float
---@param b number float
---@param out_h ffi.ct* float*
---@param out_s ffi.ct* float*
---@param out_v ffi.ct* float*
---@return nil
function M.ColorConvertRGBtoHSV(r,g,b,out_h,out_s,out_v)
    return lib.igColorConvertRGBtoHSV(r,g,b,out_h,out_s,out_v)
end
---@param _in number ImU32
---@return nil
function M.ColorConvertU32ToFloat4(_in)
    local nonUDT_out = ffi.new("ImVec4")
    lib.igColorConvertU32ToFloat4(nonUDT_out,_in)
    return nonUDT_out
end
---@param label string
---@param col ffi.ct* float[3]
---@param flags ColorEditFlags?
---@return boolean
function M.ColorEdit3(label,col,flags)
    flags = flags or 0
    return lib.igColorEdit3(label,col,flags)
end
---@param label string
---@param col ffi.ct* float[4]
---@param flags ColorEditFlags?
---@return boolean
function M.ColorEdit4(label,col,flags)
    flags = flags or 0
    return lib.igColorEdit4(label,col,flags)
end
---@param col ffi.ct* const float*
---@param flags ColorEditFlags
---@return nil
function M.ColorEditOptionsPopup(col,flags)
    return lib.igColorEditOptionsPopup(col,flags)
end
---@param label string
---@param col ffi.ct* float[3]
---@param flags ColorEditFlags?
---@return boolean
function M.ColorPicker3(label,col,flags)
    flags = flags or 0
    return lib.igColorPicker3(label,col,flags)
end
---@param label string
---@param col ffi.ct* float[4]
---@param flags ColorEditFlags?
---@param ref_col ffi.ct*? const float*
---@return boolean
function M.ColorPicker4(label,col,flags,ref_col)
    flags = flags or 0
    ref_col = ref_col or nil
    return lib.igColorPicker4(label,col,flags,ref_col)
end
---@param ref_col ffi.ct* const float*
---@param flags ColorEditFlags
---@return nil
function M.ColorPickerOptionsPopup(ref_col,flags)
    return lib.igColorPickerOptionsPopup(ref_col,flags)
end
---@param text string
---@param col ffi.ct* const float*
---@param flags ColorEditFlags
---@return nil
function M.ColorTooltip(text,col,flags)
    return lib.igColorTooltip(text,col,flags)
end
---@param count number? int
---@param id string?
---@param border boolean?
---@return nil
function M.Columns(count,id,border)
    if border == nil then border = true end
    count = count or 1
    id = id or nil
    return lib.igColumns(count,id,border)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items ffi.ct* const char* const[]
---@param items_count number int
---@param popup_max_height_in_items number? int
---@return boolean
function M.Combo_Str_arr(label,current_item,items,items_count,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_Str_arr(label,current_item,items,items_count,popup_max_height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items_separated_by_zeros string
---@param popup_max_height_in_items number? int
---@return boolean
function M.Combo_Str(label,current_item,items_separated_by_zeros,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_Str(label,current_item,items_separated_by_zeros,popup_max_height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param getter ffi.ct* const char*(*)(void* user_data,int idx)
---@param user_data ffi.ct* void*
---@param items_count number int
---@param popup_max_height_in_items number? int
---@return boolean
function M.Combo_FnStrPtr(label,current_item,getter,user_data,items_count,popup_max_height_in_items)
    popup_max_height_in_items = popup_max_height_in_items or -1
    return lib.igCombo_FnStrPtr(label,current_item,getter,user_data,items_count,popup_max_height_in_items)
end
function M.Combo(a1,a2,a3,a4,a5,a6) -- generic version
    if (ffi.istype('const char* const[]',a3) or ffi.istype('const char const[]',a3) or ffi.istype('const char const[][]',a3)) then return M.Combo_Str_arr(a1,a2,a3,a4,a5) end
    if (ffi.istype('const char*',a3) or ffi.istype('char[]',a3) or type(a3)=='string') then return M.Combo_Str(a1,a2,a3,a4) end
    if ffi.istype('const char*(*)(void* user_data,int idx)',a3) then return M.Combo_FnStrPtr(a1,a2,a3,a4,a5,a6) end
    print(a1,a2,a3,a4,a5,a6)
    error'M.Combo could not find overloaded'
end
---@param ctx ffi.ct* ImGuiContext*
---@param key Key
---@return Key
function M.ConvertSingleModFlagToKey(ctx,key)
    return lib.igConvertSingleModFlagToKey(ctx,key)
end
---@param shared_font_atlas ffi.ct*? ImFontAtlas*
---@return ffi.ct* ImGuiContext*
function M.CreateContext(shared_font_atlas)
    shared_font_atlas = shared_font_atlas or nil
    return lib.igCreateContext(shared_font_atlas)
end
---@param name string
---@return ffi.ct* ImGuiWindowSettings*
function M.CreateNewWindowSettings(name)
    return lib.igCreateNewWindowSettings(name)
end
---@param buf string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param format string
---@return boolean
function M.DataTypeApplyFromText(buf,data_type,p_data,format)
    return lib.igDataTypeApplyFromText(buf,data_type,p_data,format)
end
---@param data_type DataType
---@param op number int
---@param output ffi.ct* void*
---@param arg_1 ffi.ct* const void*
---@param arg_2 ffi.ct* const void*
---@return nil
function M.DataTypeApplyOp(data_type,op,output,arg_1,arg_2)
    return lib.igDataTypeApplyOp(data_type,op,output,arg_1,arg_2)
end
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@return boolean
function M.DataTypeClamp(data_type,p_data,p_min,p_max)
    return lib.igDataTypeClamp(data_type,p_data,p_min,p_max)
end
---@param data_type DataType
---@param arg_1 ffi.ct* const void*
---@param arg_2 ffi.ct* const void*
---@return number int
function M.DataTypeCompare(data_type,arg_1,arg_2)
    return lib.igDataTypeCompare(data_type,arg_1,arg_2)
end
---@param buf ffi.ct* char*
---@param buf_size number int
---@param data_type DataType
---@param p_data ffi.ct* const void*
---@param format string
---@return number int
function M.DataTypeFormatString(buf,buf_size,data_type,p_data,format)
    return lib.igDataTypeFormatString(buf,buf_size,data_type,p_data,format)
end
---@param data_type DataType
---@return ffi.ct* const ImGuiDataTypeInfo*
function M.DataTypeGetInfo(data_type)
    return lib.igDataTypeGetInfo(data_type)
end
---@param info ffi.ct* ImGuiDebugAllocInfo*
---@param frame_count number int
---@param ptr ffi.ct* void*
---@param size number size_t
---@return nil
function M.DebugAllocHook(info,frame_count,ptr,size)
    return lib.igDebugAllocHook(info,frame_count,ptr,size)
end
---@param label string
---@param description_of_location string
---@return boolean
function M.DebugBreakButton(label,description_of_location)
    return lib.igDebugBreakButton(label,description_of_location)
end
---@param keyboard_only boolean
---@param description_of_location string
---@return nil
function M.DebugBreakButtonTooltip(keyboard_only,description_of_location)
    return lib.igDebugBreakButtonTooltip(keyboard_only,description_of_location)
end
---@return nil
function M.DebugBreakClearData()
    return lib.igDebugBreakClearData()
end
---@param version_str string
---@param sz_io number size_t
---@param sz_style number size_t
---@param sz_vec2 number size_t
---@param sz_vec4 number size_t
---@param sz_drawvert number size_t
---@param sz_drawidx number size_t
---@return boolean
function M.DebugCheckVersionAndDataLayout(version_str,sz_io,sz_style,sz_vec2,sz_vec4,sz_drawvert,sz_drawidx)
    return lib.igDebugCheckVersionAndDataLayout(version_str,sz_io,sz_style,sz_vec2,sz_vec4,sz_drawvert,sz_drawidx)
end
---@param col number? ImU32
---@return nil
function M.DebugDrawCursorPos(col)
    col = col or 4278190335
    return lib.igDebugDrawCursorPos(col)
end
---@param col number? ImU32
---@return nil
function M.DebugDrawItemRect(col)
    col = col or 4278190335
    return lib.igDebugDrawItemRect(col)
end
---@param col number? ImU32
---@return nil
function M.DebugDrawLineExtents(col)
    col = col or 4278190335
    return lib.igDebugDrawLineExtents(col)
end
---@param idx Col
---@return nil
function M.DebugFlashStyleColor(idx)
    return lib.igDebugFlashStyleColor(idx)
end
---@param id number ImGuiID
---@param data_type DataType
---@param data_id ffi.ct* const void*
---@param data_id_end ffi.ct* const void*
---@return nil
function M.DebugHookIdInfo(id,data_type,data_id,data_id_end)
    return lib.igDebugHookIdInfo(id,data_type,data_id,data_id_end)
end
---@param target_id number ImGuiID
---@return nil
function M.DebugLocateItem(target_id)
    return lib.igDebugLocateItem(target_id)
end
---@param target_id number ImGuiID
---@return nil
function M.DebugLocateItemOnHover(target_id)
    return lib.igDebugLocateItemOnHover(target_id)
end
---@return nil
function M.DebugLocateItemResolveWithLastItem()
    return lib.igDebugLocateItemResolveWithLastItem()
end
---@param fmt string
---@return nil
function M.DebugLog(fmt,...)
    return lib.igDebugLog(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.DebugLogV(fmt,args)
    return lib.igDebugLogV(fmt,args)
end
---@param columns ffi.ct* ImGuiOldColumns*
---@return nil
function M.DebugNodeColumns(columns)
    return lib.igDebugNodeColumns(columns)
end
---@param node ffi.ct* ImGuiDockNode*
---@param label string
---@return nil
function M.DebugNodeDockNode(node,label)
    return lib.igDebugNodeDockNode(node,label)
end
---@param out_draw_list ffi.ct* ImDrawList*
---@param draw_list ffi.ct* const ImDrawList*
---@param draw_cmd ffi.ct* const ImDrawCmd*
---@param show_mesh boolean
---@param show_aabb boolean
---@return nil
function M.DebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list,draw_list,draw_cmd,show_mesh,show_aabb)
    return lib.igDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list,draw_list,draw_cmd,show_mesh,show_aabb)
end
---@param window ffi.ct* ImGuiWindow*
---@param viewport ffi.ct* ImGuiViewportP*
---@param draw_list ffi.ct* const ImDrawList*
---@param label string
---@return nil
function M.DebugNodeDrawList(window,viewport,draw_list,label)
    return lib.igDebugNodeDrawList(window,viewport,draw_list,label)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.DebugNodeFont(font)
    return lib.igDebugNodeFont(font)
end
---@param font ffi.ct* ImFont*
---@param glyph ffi.ct* const ImFontGlyph*
---@return nil
function M.DebugNodeFontGlyph(font,glyph)
    return lib.igDebugNodeFontGlyph(font,glyph)
end
---@param state ffi.ct* ImGuiInputTextState*
---@return nil
function M.DebugNodeInputTextState(state)
    return lib.igDebugNodeInputTextState(state)
end
---@param storage ffi.ct* ImGuiStorage*
---@param label string
---@return nil
function M.DebugNodeStorage(storage,label)
    return lib.igDebugNodeStorage(storage,label)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param label string
---@return nil
function M.DebugNodeTabBar(tab_bar,label)
    return lib.igDebugNodeTabBar(tab_bar,label)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.DebugNodeTable(table)
    return lib.igDebugNodeTable(table)
end
---@param settings ffi.ct* ImGuiTableSettings*
---@return nil
function M.DebugNodeTableSettings(settings)
    return lib.igDebugNodeTableSettings(settings)
end
---@param state ffi.ct* ImGuiTypingSelectState*
---@return nil
function M.DebugNodeTypingSelectState(state)
    return lib.igDebugNodeTypingSelectState(state)
end
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.DebugNodeViewport(viewport)
    return lib.igDebugNodeViewport(viewport)
end
---@param window ffi.ct* ImGuiWindow*
---@param label string
---@return nil
function M.DebugNodeWindow(window,label)
    return lib.igDebugNodeWindow(window,label)
end
---@param settings ffi.ct* ImGuiWindowSettings*
---@return nil
function M.DebugNodeWindowSettings(settings)
    return lib.igDebugNodeWindowSettings(settings)
end
---@param windows ffi.ct* ImVector_ImGuiWindowPtr*
---@param label string
---@return nil
function M.DebugNodeWindowsList(windows,label)
    return lib.igDebugNodeWindowsList(windows,label)
end
---@param windows ffi.ct* ImGuiWindow**
---@param windows_size number int
---@param parent_in_begin_stack ffi.ct* ImGuiWindow*
---@return nil
function M.DebugNodeWindowsListByBeginStackParent(windows,windows_size,parent_in_begin_stack)
    return lib.igDebugNodeWindowsListByBeginStackParent(windows,windows_size,parent_in_begin_stack)
end
---@param draw_list ffi.ct* ImDrawList*
---@return nil
function M.DebugRenderKeyboardPreview(draw_list)
    return lib.igDebugRenderKeyboardPreview(draw_list)
end
---@param draw_list ffi.ct* ImDrawList*
---@param viewport ffi.ct* ImGuiViewportP*
---@param bb ImRect
---@return nil
function M.DebugRenderViewportThumbnail(draw_list,viewport,bb)
    return lib.igDebugRenderViewportThumbnail(draw_list,viewport,bb)
end
---@return nil
function M.DebugStartItemPicker()
    return lib.igDebugStartItemPicker()
end
---@param text string
---@return nil
function M.DebugTextEncoding(text)
    return lib.igDebugTextEncoding(text)
end
---@param ctx ffi.ct*? ImGuiContext*
---@return nil
function M.DestroyContext(ctx)
    ctx = ctx or nil
    return lib.igDestroyContext(ctx)
end
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.DestroyPlatformWindow(viewport)
    return lib.igDestroyPlatformWindow(viewport)
end
---@return nil
function M.DestroyPlatformWindows()
    return lib.igDestroyPlatformWindows()
end
---@param node_id number? ImGuiID
---@param flags DockNodeFlags?
---@return number ImGuiID
function M.DockBuilderAddNode(node_id,flags)
    flags = flags or 0
    node_id = node_id or 0
    return lib.igDockBuilderAddNode(node_id,flags)
end
---@param src_dockspace_id number ImGuiID
---@param dst_dockspace_id number ImGuiID
---@param in_window_remap_pairs ffi.ct* ImVector_const_charPtr*
---@return nil
function M.DockBuilderCopyDockSpace(src_dockspace_id,dst_dockspace_id,in_window_remap_pairs)
    return lib.igDockBuilderCopyDockSpace(src_dockspace_id,dst_dockspace_id,in_window_remap_pairs)
end
---@param src_node_id number ImGuiID
---@param dst_node_id number ImGuiID
---@param out_node_remap_pairs ffi.ct* ImVector_ImGuiID*
---@return nil
function M.DockBuilderCopyNode(src_node_id,dst_node_id,out_node_remap_pairs)
    return lib.igDockBuilderCopyNode(src_node_id,dst_node_id,out_node_remap_pairs)
end
---@param src_name string
---@param dst_name string
---@return nil
function M.DockBuilderCopyWindowSettings(src_name,dst_name)
    return lib.igDockBuilderCopyWindowSettings(src_name,dst_name)
end
---@param window_name string
---@param node_id number ImGuiID
---@return nil
function M.DockBuilderDockWindow(window_name,node_id)
    return lib.igDockBuilderDockWindow(window_name,node_id)
end
---@param node_id number ImGuiID
---@return nil
function M.DockBuilderFinish(node_id)
    return lib.igDockBuilderFinish(node_id)
end
---@param node_id number ImGuiID
---@return ffi.ct* ImGuiDockNode*
function M.DockBuilderGetCentralNode(node_id)
    return lib.igDockBuilderGetCentralNode(node_id)
end
---@param node_id number ImGuiID
---@return ffi.ct* ImGuiDockNode*
function M.DockBuilderGetNode(node_id)
    return lib.igDockBuilderGetNode(node_id)
end
---@param node_id number ImGuiID
---@return nil
function M.DockBuilderRemoveNode(node_id)
    return lib.igDockBuilderRemoveNode(node_id)
end
---@param node_id number ImGuiID
---@return nil
function M.DockBuilderRemoveNodeChildNodes(node_id)
    return lib.igDockBuilderRemoveNodeChildNodes(node_id)
end
---@param node_id number ImGuiID
---@param clear_settings_refs boolean?
---@return nil
function M.DockBuilderRemoveNodeDockedWindows(node_id,clear_settings_refs)
    if clear_settings_refs == nil then clear_settings_refs = true end
    return lib.igDockBuilderRemoveNodeDockedWindows(node_id,clear_settings_refs)
end
---@param node_id number ImGuiID
---@param pos ImVec2
---@return nil
function M.DockBuilderSetNodePos(node_id,pos)
    return lib.igDockBuilderSetNodePos(node_id,pos)
end
---@param node_id number ImGuiID
---@param size ImVec2
---@return nil
function M.DockBuilderSetNodeSize(node_id,size)
    return lib.igDockBuilderSetNodeSize(node_id,size)
end
---@param node_id number ImGuiID
---@param split_dir Dir
---@param size_ratio_for_node_at_dir number float
---@param out_id_at_dir ffi.ct* ImGuiID*
---@param out_id_at_opposite_dir ffi.ct* ImGuiID*
---@return number ImGuiID
function M.DockBuilderSplitNode(node_id,split_dir,size_ratio_for_node_at_dir,out_id_at_dir,out_id_at_opposite_dir)
    return lib.igDockBuilderSplitNode(node_id,split_dir,size_ratio_for_node_at_dir,out_id_at_dir,out_id_at_opposite_dir)
end
---@param target ffi.ct* ImGuiWindow*
---@param target_node ffi.ct* ImGuiDockNode*
---@param payload_window ffi.ct* ImGuiWindow*
---@param payload_node ffi.ct* ImGuiDockNode*
---@param split_dir Dir
---@param split_outer boolean
---@param out_pos ffi.ct* ImVec2*
---@return boolean
function M.DockContextCalcDropPosForDocking(target,target_node,payload_window,payload_node,split_dir,split_outer,out_pos)
    return lib.igDockContextCalcDropPosForDocking(target,target_node,payload_window,payload_node,split_dir,split_outer,out_pos)
end
---@param ctx ffi.ct* ImGuiContext*
---@param root_id number ImGuiID
---@param clear_settings_refs boolean
---@return nil
function M.DockContextClearNodes(ctx,root_id,clear_settings_refs)
    return lib.igDockContextClearNodes(ctx,root_id,clear_settings_refs)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextEndFrame(ctx)
    return lib.igDockContextEndFrame(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@param id number ImGuiID
---@return ffi.ct* ImGuiDockNode*
function M.DockContextFindNodeByID(ctx,id)
    return lib.igDockContextFindNodeByID(ctx,id)
end
---@param ctx ffi.ct* ImGuiContext*
---@return number ImGuiID
function M.DockContextGenNodeID(ctx)
    return lib.igDockContextGenNodeID(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextInitialize(ctx)
    return lib.igDockContextInitialize(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextNewFrameUpdateDocking(ctx)
    return lib.igDockContextNewFrameUpdateDocking(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextNewFrameUpdateUndocking(ctx)
    return lib.igDockContextNewFrameUpdateUndocking(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@param node ffi.ct* ImGuiDockNode*
---@return nil
function M.DockContextProcessUndockNode(ctx,node)
    return lib.igDockContextProcessUndockNode(ctx,node)
end
---@param ctx ffi.ct* ImGuiContext*
---@param window ffi.ct* ImGuiWindow*
---@param clear_persistent_docking_ref boolean?
---@return nil
function M.DockContextProcessUndockWindow(ctx,window,clear_persistent_docking_ref)
    if clear_persistent_docking_ref == nil then clear_persistent_docking_ref = true end
    return lib.igDockContextProcessUndockWindow(ctx,window,clear_persistent_docking_ref)
end
---@param ctx ffi.ct* ImGuiContext*
---@param target ffi.ct* ImGuiWindow*
---@param target_node ffi.ct* ImGuiDockNode*
---@param payload ffi.ct* ImGuiWindow*
---@param split_dir Dir
---@param split_ratio number float
---@param split_outer boolean
---@return nil
function M.DockContextQueueDock(ctx,target,target_node,payload,split_dir,split_ratio,split_outer)
    return lib.igDockContextQueueDock(ctx,target,target_node,payload,split_dir,split_ratio,split_outer)
end
---@param ctx ffi.ct* ImGuiContext*
---@param node ffi.ct* ImGuiDockNode*
---@return nil
function M.DockContextQueueUndockNode(ctx,node)
    return lib.igDockContextQueueUndockNode(ctx,node)
end
---@param ctx ffi.ct* ImGuiContext*
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.DockContextQueueUndockWindow(ctx,window)
    return lib.igDockContextQueueUndockWindow(ctx,window)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextRebuildNodes(ctx)
    return lib.igDockContextRebuildNodes(ctx)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.DockContextShutdown(ctx)
    return lib.igDockContextShutdown(ctx)
end
---@param node ffi.ct* ImGuiDockNode*
---@return boolean
function M.DockNodeBeginAmendTabBar(node)
    return lib.igDockNodeBeginAmendTabBar(node)
end
---@return nil
function M.DockNodeEndAmendTabBar()
    return lib.igDockNodeEndAmendTabBar()
end
---@param node ffi.ct* const ImGuiDockNode*
---@return number int
function M.DockNodeGetDepth(node)
    return lib.igDockNodeGetDepth(node)
end
---@param node ffi.ct* ImGuiDockNode*
---@return ffi.ct* ImGuiDockNode*
function M.DockNodeGetRootNode(node)
    return lib.igDockNodeGetRootNode(node)
end
---@param node ffi.ct* const ImGuiDockNode*
---@return number ImGuiID
function M.DockNodeGetWindowMenuButtonId(node)
    return lib.igDockNodeGetWindowMenuButtonId(node)
end
---@param node ffi.ct* ImGuiDockNode*
---@param parent ffi.ct* ImGuiDockNode*
---@return boolean
function M.DockNodeIsInHierarchyOf(node,parent)
    return lib.igDockNodeIsInHierarchyOf(node,parent)
end
---@param ctx ffi.ct* ImGuiContext*
---@param node ffi.ct* ImGuiDockNode*
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return nil
function M.DockNodeWindowMenuHandler_Default(ctx,node,tab_bar)
    return lib.igDockNodeWindowMenuHandler_Default(ctx,node,tab_bar)
end
---@param id number ImGuiID
---@param size ImVec2?
---@param flags DockNodeFlags?
---@param window_class ffi.ct*? const ImGuiWindowClass*
---@return number ImGuiID
function M.DockSpace(id,size,flags,window_class)
    flags = flags or 0
    size = size or ImVec2(0,0)
    window_class = window_class or nil
    return lib.igDockSpace(id,size,flags,window_class)
end
---@param viewport ffi.ct*? const ImGuiViewport*
---@param flags DockNodeFlags?
---@param window_class ffi.ct*? const ImGuiWindowClass*
---@return number ImGuiID
function M.DockSpaceOverViewport(viewport,flags,window_class)
    flags = flags or 0
    viewport = viewport or nil
    window_class = window_class or nil
    return lib.igDockSpaceOverViewport(viewport,flags,window_class)
end
---@param id number ImGuiID
---@param data_type DataType
---@param p_v ffi.ct* void*
---@param v_speed number float
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string
---@param flags SliderFlags
---@return boolean
function M.DragBehavior(id,data_type,p_v,v_speed,p_min,p_max,format,flags)
    return lib.igDragBehavior(id,data_type,p_v,v_speed,p_min,p_max,format,flags)
end
---@param label string
---@param v ffi.ct* float*
---@param v_speed number? float
---@param v_min number? float
---@param v_max number? float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragFloat(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param v_speed number? float
---@param v_min number? float
---@param v_max number? float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragFloat2(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat2(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param v_speed number? float
---@param v_min number? float
---@param v_max number? float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragFloat3(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat3(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param v_speed number? float
---@param v_min number? float
---@param v_max number? float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragFloat4(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloat4(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v_current_min ffi.ct* float*
---@param v_current_max ffi.ct* float*
---@param v_speed number? float
---@param v_min number? float
---@param v_max number? float
---@param format string?
---@param format_max string?
---@param flags SliderFlags?
---@return boolean
function M.DragFloatRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
    flags = flags or 0
    format = format or "%.3f"
    format_max = format_max or nil
    v_max = v_max or 0.0
    v_min = v_min or 0.0
    v_speed = v_speed or 1.0
    return lib.igDragFloatRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param v_speed number? float
---@param v_min number? int
---@param v_max number? int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragInt(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param v_speed number? float
---@param v_min number? int
---@param v_max number? int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragInt2(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt2(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param v_speed number? float
---@param v_min number? int
---@param v_max number? int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragInt3(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt3(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param v_speed number? float
---@param v_min number? int
---@param v_max number? int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragInt4(label,v,v_speed,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragInt4(label,v,v_speed,v_min,v_max,format,flags)
end
---@param label string
---@param v_current_min ffi.ct* int*
---@param v_current_max ffi.ct* int*
---@param v_speed number? float
---@param v_min number? int
---@param v_max number? int
---@param format string?
---@param format_max string?
---@param flags SliderFlags?
---@return boolean
function M.DragIntRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
    flags = flags or 0
    format = format or "%d"
    format_max = format_max or nil
    v_max = v_max or 0
    v_min = v_min or 0
    v_speed = v_speed or 1.0
    return lib.igDragIntRange2(label,v_current_min,v_current_max,v_speed,v_min,v_max,format,format_max,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param v_speed number? float
---@param p_min ffi.ct*? const void*
---@param p_max ffi.ct*? const void*
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragScalar(label,data_type,p_data,v_speed,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    p_max = p_max or nil
    p_min = p_min or nil
    v_speed = v_speed or 1.0
    return lib.igDragScalar(label,data_type,p_data,v_speed,p_min,p_max,format,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param components number int
---@param v_speed number? float
---@param p_min ffi.ct*? const void*
---@param p_max ffi.ct*? const void*
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.DragScalarN(label,data_type,p_data,components,v_speed,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    p_max = p_max or nil
    p_min = p_min or nil
    v_speed = v_speed or 1.0
    return lib.igDragScalarN(label,data_type,p_data,components,v_speed,p_min,p_max,format,flags)
end
---@param size ImVec2
---@return nil
function M.Dummy(size)
    return lib.igDummy(size)
end
---@return nil
function M.End()
    return lib.igEnd()
end
---@return nil
function M.EndChild()
    return lib.igEndChild()
end
---@return nil
function M.EndColumns()
    return lib.igEndColumns()
end
---@return nil
function M.EndCombo()
    return lib.igEndCombo()
end
---@return nil
function M.EndComboPreview()
    return lib.igEndComboPreview()
end
---@return nil
function M.EndDisabled()
    return lib.igEndDisabled()
end
---@return nil
function M.EndDragDropSource()
    return lib.igEndDragDropSource()
end
---@return nil
function M.EndDragDropTarget()
    return lib.igEndDragDropTarget()
end
---@return nil
function M.EndFrame()
    return lib.igEndFrame()
end
---@return nil
function M.EndGroup()
    return lib.igEndGroup()
end
---@return nil
function M.EndListBox()
    return lib.igEndListBox()
end
---@return nil
function M.EndMainMenuBar()
    return lib.igEndMainMenuBar()
end
---@return nil
function M.EndMenu()
    return lib.igEndMenu()
end
---@return nil
function M.EndMenuBar()
    return lib.igEndMenuBar()
end
---@return nil
function M.EndPopup()
    return lib.igEndPopup()
end
---@return nil
function M.EndTabBar()
    return lib.igEndTabBar()
end
---@return nil
function M.EndTabItem()
    return lib.igEndTabItem()
end
---@return nil
function M.EndTable()
    return lib.igEndTable()
end
---@return nil
function M.EndTooltip()
    return lib.igEndTooltip()
end
---@param log_callback ffi.ct* ImGuiErrorLogCallback
---@param user_data ffi.ct*? void*
---@return nil
function M.ErrorCheckEndFrameRecover(log_callback,user_data)
    user_data = user_data or nil
    return lib.igErrorCheckEndFrameRecover(log_callback,user_data)
end
---@param log_callback ffi.ct* ImGuiErrorLogCallback
---@param user_data ffi.ct*? void*
---@return nil
function M.ErrorCheckEndWindowRecover(log_callback,user_data)
    user_data = user_data or nil
    return lib.igErrorCheckEndWindowRecover(log_callback,user_data)
end
---@return nil
function M.ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
    return lib.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.FindBestWindowPosForPopup(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igFindBestWindowPosForPopup(nonUDT_out,window)
    return nonUDT_out
end
---@param ref_pos ImVec2
---@param size ImVec2
---@param last_dir ffi.ct* ImGuiDir*
---@param r_outer ImRect
---@param r_avoid ImRect
---@param policy PopupPositionPolicy
---@return nil
function M.FindBestWindowPosForPopupEx(ref_pos,size,last_dir,r_outer,r_avoid,policy)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igFindBestWindowPosForPopupEx(nonUDT_out,ref_pos,size,last_dir,r_outer,r_avoid,policy)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImGuiWindow*
function M.FindBlockingModal(window)
    return lib.igFindBlockingModal(window)
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImGuiWindow*
function M.FindBottomMostVisibleWindowWithinBeginStack(window)
    return lib.igFindBottomMostVisibleWindowWithinBeginStack(window)
end
---@param mouse_platform_pos ImVec2
---@return ffi.ct* ImGuiViewportP*
function M.FindHoveredViewportFromPlatformWindowStack(mouse_platform_pos)
    return lib.igFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos)
end
---@param window ffi.ct* ImGuiWindow*
---@param id number ImGuiID
---@return ffi.ct* ImGuiOldColumns*
function M.FindOrCreateColumns(window,id)
    return lib.igFindOrCreateColumns(window,id)
end
---@param text string
---@param text_end string?
---@return string
function M.FindRenderedTextEnd(text,text_end)
    text_end = text_end or nil
    return ffi.string(lib.igFindRenderedTextEnd(text,text_end))
end
---@param type_name string
---@return ffi.ct* ImGuiSettingsHandler*
function M.FindSettingsHandler(type_name)
    return lib.igFindSettingsHandler(type_name)
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiViewport*
function M.FindViewportByID(id)
    return lib.igFindViewportByID(id)
end
---@param platform_handle ffi.ct* void*
---@return ffi.ct* ImGuiViewport*
function M.FindViewportByPlatformHandle(platform_handle)
    return lib.igFindViewportByPlatformHandle(platform_handle)
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiWindow*
function M.FindWindowByID(id)
    return lib.igFindWindowByID(id)
end
---@param name string
---@return ffi.ct* ImGuiWindow*
function M.FindWindowByName(name)
    return lib.igFindWindowByName(name)
end
---@param window ffi.ct* ImGuiWindow*
---@return number int
function M.FindWindowDisplayIndex(window)
    return lib.igFindWindowDisplayIndex(window)
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiWindowSettings*
function M.FindWindowSettingsByID(id)
    return lib.igFindWindowSettingsByID(id)
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImGuiWindowSettings*
function M.FindWindowSettingsByWindow(window)
    return lib.igFindWindowSettingsByWindow(window)
end
---@param ctx ffi.ct* ImGuiContext*
---@param key_chord number ImGuiKeyChord
---@return number ImGuiKeyChord
function M.FixupKeyChord(ctx,key_chord)
    return lib.igFixupKeyChord(ctx,key_chord)
end
---@return nil
function M.FocusItem()
    return lib.igFocusItem()
end
---@param under_this_window ffi.ct* ImGuiWindow*
---@param ignore_window ffi.ct* ImGuiWindow*
---@param filter_viewport ffi.ct* ImGuiViewport*
---@param flags FocusRequestFlags
---@return nil
function M.FocusTopMostWindowUnderOne(under_this_window,ignore_window,filter_viewport,flags)
    return lib.igFocusTopMostWindowUnderOne(under_this_window,ignore_window,filter_viewport,flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param flags FocusRequestFlags?
---@return nil
function M.FocusWindow(window,flags)
    flags = flags or 0
    return lib.igFocusWindow(window,flags)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GcAwakeTransientWindowBuffers(window)
    return lib.igGcAwakeTransientWindowBuffers(window)
end
---@return nil
function M.GcCompactTransientMiscBuffers()
    return lib.igGcCompactTransientMiscBuffers()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GcCompactTransientWindowBuffers(window)
    return lib.igGcCompactTransientWindowBuffers(window)
end
---@return number ImGuiID
function M.GetActiveID()
    return lib.igGetActiveID()
end
---@param p_alloc_func ffi.ct* ImGuiMemAllocFunc*
---@param p_free_func ffi.ct* ImGuiMemFreeFunc*
---@param p_user_data ffi.ct* void**
---@return nil
function M.GetAllocatorFunctions(p_alloc_func,p_free_func,p_user_data)
    return lib.igGetAllocatorFunctions(p_alloc_func,p_free_func,p_user_data)
end
---@return ffi.ct* ImDrawList*
function M.GetBackgroundDrawList_Nil()
    return lib.igGetBackgroundDrawList_Nil()
end
---@param viewport ffi.ct* ImGuiViewport*
---@return ffi.ct* ImDrawList*
function M.GetBackgroundDrawList_ViewportPtr(viewport)
    return lib.igGetBackgroundDrawList_ViewportPtr(viewport)
end
function M.GetBackgroundDrawList(a1) -- generic version
    if a1==nil then return M.GetBackgroundDrawList_Nil() end
    if (ffi.istype('ImGuiViewport*',a1) or ffi.istype('ImGuiViewport',a1) or ffi.istype('ImGuiViewport[]',a1)) then return M.GetBackgroundDrawList_ViewportPtr(a1) end
    print(a1)
    error'M.GetBackgroundDrawList could not find overloaded'
end
---@return string
function M.GetClipboardText()
    return ffi.string(lib.igGetClipboardText())
end
---@param idx Col
---@param alpha_mul number? float
---@return number ImU32
function M.GetColorU32_Col(idx,alpha_mul)
    alpha_mul = alpha_mul or 1.0
    return lib.igGetColorU32_Col(idx,alpha_mul)
end
---@param col ffi.ct* const ImVec4
---@return number ImU32
function M.GetColorU32_Vec4(col)
    return lib.igGetColorU32_Vec4(col)
end
---@param col number ImU32
---@param alpha_mul number? float
---@return number ImU32
function M.GetColorU32_U32(col,alpha_mul)
    alpha_mul = alpha_mul or 1.0
    return lib.igGetColorU32_U32(col,alpha_mul)
end
function M.GetColorU32(a1,a2) -- generic version
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return M.GetColorU32_Col(a1,a2) end
    if ffi.istype('const ImVec4',a1) then return M.GetColorU32_Vec4(a1) end
    if (ffi.istype('uint32_t',a1) or type(a1)=='number') then return M.GetColorU32_U32(a1,a2) end
    print(a1,a2)
    error'M.GetColorU32 could not find overloaded'
end
---@return number int
function M.GetColumnIndex()
    return lib.igGetColumnIndex()
end
---@param columns ffi.ct* const ImGuiOldColumns*
---@param offset number float
---@return number float
function M.GetColumnNormFromOffset(columns,offset)
    return lib.igGetColumnNormFromOffset(columns,offset)
end
---@param column_index number? int
---@return number float
function M.GetColumnOffset(column_index)
    column_index = column_index or -1
    return lib.igGetColumnOffset(column_index)
end
---@param columns ffi.ct* const ImGuiOldColumns*
---@param offset_norm number float
---@return number float
function M.GetColumnOffsetFromNorm(columns,offset_norm)
    return lib.igGetColumnOffsetFromNorm(columns,offset_norm)
end
---@param column_index number? int
---@return number float
function M.GetColumnWidth(column_index)
    column_index = column_index or -1
    return lib.igGetColumnWidth(column_index)
end
---@return number int
function M.GetColumnsCount()
    return lib.igGetColumnsCount()
end
---@param str_id string
---@param count number int
---@return number ImGuiID
function M.GetColumnsID(str_id,count)
    return lib.igGetColumnsID(str_id,count)
end
---@return nil
function M.GetContentRegionAvail()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionAvail(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetContentRegionMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetContentRegionMaxAbs()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetContentRegionMaxAbs(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImGuiContext*
function M.GetCurrentContext()
    return lib.igGetCurrentContext()
end
---@return number ImGuiID
function M.GetCurrentFocusScope()
    return lib.igGetCurrentFocusScope()
end
---@return ffi.ct* ImGuiTabBar*
function M.GetCurrentTabBar()
    return lib.igGetCurrentTabBar()
end
---@return ffi.ct* ImGuiTable*
function M.GetCurrentTable()
    return lib.igGetCurrentTable()
end
---@return ffi.ct* ImGuiWindow*
function M.GetCurrentWindow()
    return lib.igGetCurrentWindow()
end
---@return ffi.ct* ImGuiWindow*
function M.GetCurrentWindowRead()
    return lib.igGetCurrentWindowRead()
end
---@return nil
function M.GetCursorPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorPos(nonUDT_out)
    return nonUDT_out
end
---@return number float
function M.GetCursorPosX()
    return lib.igGetCursorPosX()
end
---@return number float
function M.GetCursorPosY()
    return lib.igGetCursorPosY()
end
---@return nil
function M.GetCursorScreenPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorScreenPos(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetCursorStartPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetCursorStartPos(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImFont*
function M.GetDefaultFont()
    return lib.igGetDefaultFont()
end
---@return ffi.ct* const ImGuiPayload*
function M.GetDragDropPayload()
    return lib.igGetDragDropPayload()
end
---@return ffi.ct* ImDrawData*
function M.GetDrawData()
    return lib.igGetDrawData()
end
---@return ffi.ct* ImDrawListSharedData*
function M.GetDrawListSharedData()
    return lib.igGetDrawListSharedData()
end
---@return number ImGuiID
function M.GetFocusID()
    return lib.igGetFocusID()
end
---@return ffi.ct* ImFont*
function M.GetFont()
    return lib.igGetFont()
end
---@return number float
function M.GetFontSize()
    return lib.igGetFontSize()
end
---@return nil
function M.GetFontTexUvWhitePixel()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetFontTexUvWhitePixel(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_Nil()
    return lib.igGetForegroundDrawList_Nil()
end
---@param viewport ffi.ct* ImGuiViewport*
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_ViewportPtr(viewport)
    return lib.igGetForegroundDrawList_ViewportPtr(viewport)
end
---@param window ffi.ct* ImGuiWindow*
---@return ffi.ct* ImDrawList*
function M.GetForegroundDrawList_WindowPtr(window)
    return lib.igGetForegroundDrawList_WindowPtr(window)
end
function M.GetForegroundDrawList(a1) -- generic version
    if a1==nil then return M.GetForegroundDrawList_Nil() end
    if (ffi.istype('ImGuiViewport*',a1) or ffi.istype('ImGuiViewport',a1) or ffi.istype('ImGuiViewport[]',a1)) then return M.GetForegroundDrawList_ViewportPtr(a1) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.GetForegroundDrawList_WindowPtr(a1) end
    print(a1)
    error'M.GetForegroundDrawList could not find overloaded'
end
---@return number int
function M.GetFrameCount()
    return lib.igGetFrameCount()
end
---@return number float
function M.GetFrameHeight()
    return lib.igGetFrameHeight()
end
---@return number float
function M.GetFrameHeightWithSpacing()
    return lib.igGetFrameHeightWithSpacing()
end
---@return number ImGuiID
function M.GetHoveredID()
    return lib.igGetHoveredID()
end
---@param str_id string
---@return number ImGuiID
function M.GetID_Str(str_id)
    return lib.igGetID_Str(str_id)
end
---@param str_id_begin string
---@param str_id_end string
---@return number ImGuiID
function M.GetID_StrStr(str_id_begin,str_id_end)
    return lib.igGetID_StrStr(str_id_begin,str_id_end)
end
---@param ptr_id ffi.ct* const void*
---@return number ImGuiID
function M.GetID_Ptr(ptr_id)
    return lib.igGetID_Ptr(ptr_id)
end
function M.GetID(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.GetID_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.GetID_StrStr(a1,a2) end
    if ffi.istype('void *',a1) then return M.GetID_Ptr(a1) end
    print(a1,a2)
    error'M.GetID could not find overloaded'
end
---@param str_id_begin string
---@param str_id_end string
---@param seed number ImGuiID
---@return number ImGuiID
function M.GetIDWithSeed_Str(str_id_begin,str_id_end,seed)
    return lib.igGetIDWithSeed_Str(str_id_begin,str_id_end,seed)
end
---@param n number int
---@param seed number ImGuiID
---@return number ImGuiID
function M.GetIDWithSeed_Int(n,seed)
    return lib.igGetIDWithSeed_Int(n,seed)
end
function M.GetIDWithSeed(a1,a2,a3) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.GetIDWithSeed_Str(a1,a2,a3) end
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return M.GetIDWithSeed_Int(a1,a2) end
    print(a1,a2,a3)
    error'M.GetIDWithSeed could not find overloaded'
end
---@return ffi.ct* ImGuiIO*
function M.GetIO()
    return lib.igGetIO()
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiInputTextState*
function M.GetInputTextState(id)
    return lib.igGetInputTextState(id)
end
---@return ItemFlags
function M.GetItemFlags()
    return lib.igGetItemFlags()
end
---@return number ImGuiID
function M.GetItemID()
    return lib.igGetItemID()
end
---@return nil
function M.GetItemRectMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetItemRectMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectMin(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetItemRectSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetItemRectSize(nonUDT_out)
    return nonUDT_out
end
---@return ItemStatusFlags
function M.GetItemStatusFlags()
    return lib.igGetItemStatusFlags()
end
---@param key_chord number ImGuiKeyChord
---@return string
function M.GetKeyChordName(key_chord)
    return ffi.string(lib.igGetKeyChordName(key_chord))
end
---@param ctx ffi.ct* ImGuiContext*
---@param key Key
---@return ffi.ct* ImGuiKeyData*
function M.GetKeyData_ContextPtr(ctx,key)
    return lib.igGetKeyData_ContextPtr(ctx,key)
end
---@param key Key
---@return ffi.ct* ImGuiKeyData*
function M.GetKeyData_Key(key)
    return lib.igGetKeyData_Key(key)
end
function M.GetKeyData(a1,a2) -- generic version
    if (ffi.istype('ImGuiContext*',a1) or ffi.istype('ImGuiContext',a1) or ffi.istype('ImGuiContext[]',a1)) then return M.GetKeyData_ContextPtr(a1,a2) end
    if ffi.istype('ImGuiKey',a1) then return M.GetKeyData_Key(a1) end
    print(a1,a2)
    error'M.GetKeyData could not find overloaded'
end
---@param key Key
---@return Key
function M.GetKeyIndex(key)
    return lib.igGetKeyIndex(key)
end
---@param key_left Key
---@param key_right Key
---@param key_up Key
---@param key_down Key
---@return nil
function M.GetKeyMagnitude2d(key_left,key_right,key_up,key_down)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetKeyMagnitude2d(nonUDT_out,key_left,key_right,key_up,key_down)
    return nonUDT_out
end
---@param key Key
---@return string
function M.GetKeyName(key)
    return ffi.string(lib.igGetKeyName(key))
end
---@param key Key
---@return number ImGuiID
function M.GetKeyOwner(key)
    return lib.igGetKeyOwner(key)
end
---@param ctx ffi.ct* ImGuiContext*
---@param key Key
---@return ffi.ct* ImGuiKeyOwnerData*
function M.GetKeyOwnerData(ctx,key)
    return lib.igGetKeyOwnerData(ctx,key)
end
---@param key Key
---@param repeat_delay number float
---@param rate number float
---@return number int
function M.GetKeyPressedAmount(key,repeat_delay,rate)
    return lib.igGetKeyPressedAmount(key,repeat_delay,rate)
end
---@return ffi.ct* ImGuiViewport*
function M.GetMainViewport()
    return lib.igGetMainViewport()
end
---@param button MouseButton
---@return number int
function M.GetMouseClickedCount(button)
    return lib.igGetMouseClickedCount(button)
end
---@return MouseCursor
function M.GetMouseCursor()
    return lib.igGetMouseCursor()
end
---@param button MouseButton?
---@param lock_threshold number? float
---@return nil
function M.GetMouseDragDelta(button,lock_threshold)
    button = button or 0
    lock_threshold = lock_threshold or -1.0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMouseDragDelta(nonUDT_out,button,lock_threshold)
    return nonUDT_out
end
---@return nil
function M.GetMousePos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMousePos(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetMousePosOnOpeningCurrentPopup()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetMousePosOnOpeningCurrentPopup(nonUDT_out)
    return nonUDT_out
end
---@param axis Axis
---@return number float
function M.GetNavTweakPressedAmount(axis)
    return lib.igGetNavTweakPressedAmount(axis)
end
---@return ffi.ct* ImGuiPlatformIO*
function M.GetPlatformIO()
    return lib.igGetPlatformIO()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.GetPopupAllowedExtentRect(window)
    local nonUDT_out = ffi.new("ImRect")
    lib.igGetPopupAllowedExtentRect(nonUDT_out,window)
    return nonUDT_out
end
---@return number float
function M.GetScrollMaxX()
    return lib.igGetScrollMaxX()
end
---@return number float
function M.GetScrollMaxY()
    return lib.igGetScrollMaxY()
end
---@return number float
function M.GetScrollX()
    return lib.igGetScrollX()
end
---@return number float
function M.GetScrollY()
    return lib.igGetScrollY()
end
---@param key_chord number ImGuiKeyChord
---@return ffi.ct* ImGuiKeyRoutingData*
function M.GetShortcutRoutingData(key_chord)
    return lib.igGetShortcutRoutingData(key_chord)
end
---@return ffi.ct* ImGuiStorage*
function M.GetStateStorage()
    return lib.igGetStateStorage()
end
---@return ffi.ct* ImGuiStyle*
function M.GetStyle()
    return lib.igGetStyle()
end
---@param idx Col
---@return string
function M.GetStyleColorName(idx)
    return ffi.string(lib.igGetStyleColorName(idx))
end
---@param idx Col
---@return ffi.ct* const ImVec4*
function M.GetStyleColorVec4(idx)
    return lib.igGetStyleColorVec4(idx)
end
---@param idx StyleVar
---@return ffi.ct* const ImGuiDataVarInfo*
function M.GetStyleVarInfo(idx)
    return lib.igGetStyleVarInfo(idx)
end
---@return number float
function M.GetTextLineHeight()
    return lib.igGetTextLineHeight()
end
---@return number float
function M.GetTextLineHeightWithSpacing()
    return lib.igGetTextLineHeightWithSpacing()
end
---@return number double
function M.GetTime()
    return lib.igGetTime()
end
---@return ffi.ct* ImGuiWindow*
function M.GetTopMostAndVisiblePopupModal()
    return lib.igGetTopMostAndVisiblePopupModal()
end
---@return ffi.ct* ImGuiWindow*
function M.GetTopMostPopupModal()
    return lib.igGetTopMostPopupModal()
end
---@return number float
function M.GetTreeNodeToLabelSpacing()
    return lib.igGetTreeNodeToLabelSpacing()
end
---@param flags InputFlags
---@param repeat_delay ffi.ct* float*
---@param repeat_rate ffi.ct* float*
---@return nil
function M.GetTypematicRepeatRate(flags,repeat_delay,repeat_rate)
    return lib.igGetTypematicRepeatRate(flags,repeat_delay,repeat_rate)
end
---@param flags TypingSelectFlags?
---@return ffi.ct* ImGuiTypingSelectRequest*
function M.GetTypingSelectRequest(flags)
    flags = flags or 0
    return lib.igGetTypingSelectRequest(flags)
end
---@return string
function M.GetVersion()
    return ffi.string(lib.igGetVersion())
end
---@param viewport ffi.ct* ImGuiViewport*
---@return ffi.ct* const ImGuiPlatformMonitor*
function M.GetViewportPlatformMonitor(viewport)
    return lib.igGetViewportPlatformMonitor(viewport)
end
---@param window ffi.ct* ImGuiWindow*
---@return boolean
function M.GetWindowAlwaysWantOwnTabBar(window)
    return lib.igGetWindowAlwaysWantOwnTabBar(window)
end
---@return nil
function M.GetWindowContentRegionMax()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowContentRegionMax(nonUDT_out)
    return nonUDT_out
end
---@return nil
function M.GetWindowContentRegionMin()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowContentRegionMin(nonUDT_out)
    return nonUDT_out
end
---@return number ImGuiID
function M.GetWindowDockID()
    return lib.igGetWindowDockID()
end
---@return ffi.ct* ImGuiDockNode*
function M.GetWindowDockNode()
    return lib.igGetWindowDockNode()
end
---@return number float
function M.GetWindowDpiScale()
    return lib.igGetWindowDpiScale()
end
---@return ffi.ct* ImDrawList*
function M.GetWindowDrawList()
    return lib.igGetWindowDrawList()
end
---@return number float
function M.GetWindowHeight()
    return lib.igGetWindowHeight()
end
---@return nil
function M.GetWindowPos()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowPos(nonUDT_out)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@param dir Dir
---@return number ImGuiID
function M.GetWindowResizeBorderID(window,dir)
    return lib.igGetWindowResizeBorderID(window,dir)
end
---@param window ffi.ct* ImGuiWindow*
---@param n number int
---@return number ImGuiID
function M.GetWindowResizeCornerID(window,n)
    return lib.igGetWindowResizeCornerID(window,n)
end
---@param window ffi.ct* ImGuiWindow*
---@param axis Axis
---@return number ImGuiID
function M.GetWindowScrollbarID(window,axis)
    return lib.igGetWindowScrollbarID(window,axis)
end
---@param window ffi.ct* ImGuiWindow*
---@param axis Axis
---@return nil
function M.GetWindowScrollbarRect(window,axis)
    local nonUDT_out = ffi.new("ImRect")
    lib.igGetWindowScrollbarRect(nonUDT_out,window,axis)
    return nonUDT_out
end
---@return nil
function M.GetWindowSize()
    local nonUDT_out = ffi.new("ImVec2")
    lib.igGetWindowSize(nonUDT_out)
    return nonUDT_out
end
---@return ffi.ct* ImGuiViewport*
function M.GetWindowViewport()
    return lib.igGetWindowViewport()
end
---@return number float
function M.GetWindowWidth()
    return lib.igGetWindowWidth()
end
---@param x number int
---@return number int
function M.ImAbs_Int(x)
    return lib.igImAbs_Int(x)
end
---@param x number float
---@return number float
function M.ImAbs_Float(x)
    return lib.igImAbs_Float(x)
end
---@param x number double
---@return number double
function M.ImAbs_double(x)
    return lib.igImAbs_double(x)
end
function M.ImAbs(a1) -- generic version
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return M.ImAbs_Int(a1) end
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImAbs_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImAbs_double(a1) end
    print(a1)
    error'M.ImAbs could not find overloaded'
end
---@param col_a number ImU32
---@param col_b number ImU32
---@return number ImU32
function M.ImAlphaBlendColors(col_a,col_b)
    return lib.igImAlphaBlendColors(col_a,col_b)
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param t number float
---@return nil
function M.ImBezierCubicCalc(p1,p2,p3,p4,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicCalc(nonUDT_out,p1,p2,p3,p4,t)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param p ImVec2
---@param num_segments number int
---@return nil
function M.ImBezierCubicClosestPoint(p1,p2,p3,p4,p,num_segments)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicClosestPoint(nonUDT_out,p1,p2,p3,p4,p,num_segments)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param p ImVec2
---@param tess_tol number float
---@return nil
function M.ImBezierCubicClosestPointCasteljau(p1,p2,p3,p4,p,tess_tol)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierCubicClosestPointCasteljau(nonUDT_out,p1,p2,p3,p4,p,tess_tol)
    return nonUDT_out
end
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param t number float
---@return nil
function M.ImBezierQuadraticCalc(p1,p2,p3,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImBezierQuadraticCalc(nonUDT_out,p1,p2,p3,t)
    return nonUDT_out
end
---@param arr ffi.ct* ImU32*
---@param bitcount number int
---@return nil
function M.ImBitArrayClearAllBits(arr,bitcount)
    return lib.igImBitArrayClearAllBits(arr,bitcount)
end
---@param arr ffi.ct* ImU32*
---@param n number int
---@return nil
function M.ImBitArrayClearBit(arr,n)
    return lib.igImBitArrayClearBit(arr,n)
end
---@param bitcount number int
---@return number size_t
function M.ImBitArrayGetStorageSizeInBytes(bitcount)
    return lib.igImBitArrayGetStorageSizeInBytes(bitcount)
end
---@param arr ffi.ct* ImU32*
---@param n number int
---@return nil
function M.ImBitArraySetBit(arr,n)
    return lib.igImBitArraySetBit(arr,n)
end
---@param arr ffi.ct* ImU32*
---@param n number int
---@param n2 number int
---@return nil
function M.ImBitArraySetBitRange(arr,n,n2)
    return lib.igImBitArraySetBitRange(arr,n,n2)
end
---@param arr ffi.ct* const ImU32*
---@param n number int
---@return boolean
function M.ImBitArrayTestBit(arr,n)
    return lib.igImBitArrayTestBit(arr,n)
end
---@param c number char
---@return boolean
function M.ImCharIsBlankA(c)
    return lib.igImCharIsBlankA(c)
end
---@param c number unsigned int
---@return boolean
function M.ImCharIsBlankW(c)
    return lib.igImCharIsBlankW(c)
end
---@param v ImVec2
---@param mn ImVec2
---@param mx ImVec2
---@return nil
function M.ImClamp(v,mn,mx)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImClamp(nonUDT_out,v,mn,mx)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@return number float
function M.ImDot(a,b)
    return lib.igImDot(a,b)
end
---@param avg number float
---@param sample number float
---@param n number int
---@return number float
function M.ImExponentialMovingAverage(avg,sample,n)
    return lib.igImExponentialMovingAverage(avg,sample,n)
end
---@param file ffi.ct* ImFileHandle
---@return boolean
function M.ImFileClose(file)
    return lib.igImFileClose(file)
end
---@param file ffi.ct* ImFileHandle
---@return number ImU64
function M.ImFileGetSize(file)
    return lib.igImFileGetSize(file)
end
---@param filename string
---@param mode string
---@param out_file_size ffi.ct*? size_t*
---@param padding_bytes number? int
---@return ffi.ct* void*
function M.ImFileLoadToMemory(filename,mode,out_file_size,padding_bytes)
    out_file_size = out_file_size or nil
    padding_bytes = padding_bytes or 0
    return lib.igImFileLoadToMemory(filename,mode,out_file_size,padding_bytes)
end
---@param filename string
---@param mode string
---@return ffi.ct* ImFileHandle
function M.ImFileOpen(filename,mode)
    return lib.igImFileOpen(filename,mode)
end
---@param data ffi.ct* void*
---@param size number ImU64
---@param count number ImU64
---@param file ffi.ct* ImFileHandle
---@return number ImU64
function M.ImFileRead(data,size,count,file)
    return lib.igImFileRead(data,size,count,file)
end
---@param data ffi.ct* const void*
---@param size number ImU64
---@param count number ImU64
---@param file ffi.ct* ImFileHandle
---@return number ImU64
function M.ImFileWrite(data,size,count,file)
    return lib.igImFileWrite(data,size,count,file)
end
---@param f number float
---@return number float
function M.ImFloor_Float(f)
    return lib.igImFloor_Float(f)
end
---@param v ImVec2
---@return nil
function M.ImFloor_Vec2(v)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImFloor_Vec2(nonUDT_out,v)
    return nonUDT_out
end
function M.ImFloor(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImFloor_Float(a1) end
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) then return M.ImFloor_Vec2(a2) end
    print(a1,a2)
    error'M.ImFloor could not find overloaded'
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ImFontAtlasBuildFinish(atlas)
    return lib.igImFontAtlasBuildFinish(atlas)
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ImFontAtlasBuildInit(atlas)
    return lib.igImFontAtlasBuildInit(atlas)
end
---@param out_table ffi.ct* unsigned char[256]
---@param in_multiply_factor number float
---@return nil
function M.ImFontAtlasBuildMultiplyCalcLookupTable(out_table,in_multiply_factor)
    return lib.igImFontAtlasBuildMultiplyCalcLookupTable(out_table,in_multiply_factor)
end
---@param table ffi.ct* const unsigned char[256]
---@param pixels ffi.ct* unsigned char*
---@param x number int
---@param y number int
---@param w number int
---@param h number int
---@param stride number int
---@return nil
function M.ImFontAtlasBuildMultiplyRectAlpha8(table,pixels,x,y,w,h,stride)
    return lib.igImFontAtlasBuildMultiplyRectAlpha8(table,pixels,x,y,w,h,stride)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param stbrp_context_opaque ffi.ct* void*
---@return nil
function M.ImFontAtlasBuildPackCustomRects(atlas,stbrp_context_opaque)
    return lib.igImFontAtlasBuildPackCustomRects(atlas,stbrp_context_opaque)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param x number int
---@param y number int
---@param w number int
---@param h number int
---@param in_str string
---@param in_marker_char number char
---@param in_marker_pixel_value number unsigned int
---@return nil
function M.ImFontAtlasBuildRender32bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
    return lib.igImFontAtlasBuildRender32bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param x number int
---@param y number int
---@param w number int
---@param h number int
---@param in_str string
---@param in_marker_char number char
---@param in_marker_pixel_value number unsigned char
---@return nil
function M.ImFontAtlasBuildRender8bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
    return lib.igImFontAtlasBuildRender8bppRectFromString(atlas,x,y,w,h,in_str,in_marker_char,in_marker_pixel_value)
end
---@param atlas ffi.ct* ImFontAtlas*
---@param font ffi.ct* ImFont*
---@param font_config ffi.ct* ImFontConfig*
---@param ascent number float
---@param descent number float
---@return nil
function M.ImFontAtlasBuildSetupFont(atlas,font,font_config,ascent,descent)
    return lib.igImFontAtlasBuildSetupFont(atlas,font,font_config,ascent,descent)
end
---@return ffi.ct* const ImFontBuilderIO*
function M.ImFontAtlasGetBuilderForStbTruetype()
    return lib.igImFontAtlasGetBuilderForStbTruetype()
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ImFontAtlasUpdateConfigDataPointers(atlas)
    return lib.igImFontAtlasUpdateConfigDataPointers(atlas)
end
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@param fmt string
---@return number int
function M.ImFormatString(buf,buf_size,fmt,...)
    return lib.igImFormatString(buf,buf_size,fmt,...)
end
---@param out_buf ffi.ct* const char**
---@param out_buf_end ffi.ct* const char**
---@param fmt string
---@return nil
function M.ImFormatStringToTempBuffer(out_buf,out_buf_end,fmt,...)
    return lib.igImFormatStringToTempBuffer(out_buf,out_buf_end,fmt,...)
end
---@param out_buf ffi.ct* const char**
---@param out_buf_end ffi.ct* const char**
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.ImFormatStringToTempBufferV(out_buf,out_buf_end,fmt,args)
    return lib.igImFormatStringToTempBufferV(out_buf,out_buf_end,fmt,args)
end
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@param fmt string
---@param args ffi.ct* va_list
---@return number int
function M.ImFormatStringV(buf,buf_size,fmt,args)
    return lib.igImFormatStringV(buf,buf_size,fmt,args)
end
---@param data ffi.ct* const void*
---@param data_size number size_t
---@param seed number? ImGuiID
---@return number ImGuiID
function M.ImHashData(data,data_size,seed)
    seed = seed or 0
    return lib.igImHashData(data,data_size,seed)
end
---@param data string
---@param data_size number? size_t
---@param seed number? ImGuiID
---@return number ImGuiID
function M.ImHashStr(data,data_size,seed)
    data_size = data_size or 0
    seed = seed or 0
    return lib.igImHashStr(data,data_size,seed)
end
---@param lhs ImVec2
---@param fail_value number float
---@return number float
function M.ImInvLength(lhs,fail_value)
    return lib.igImInvLength(lhs,fail_value)
end
---@param f number float
---@return boolean
function M.ImIsFloatAboveGuaranteedIntegerPrecision(f)
    return lib.igImIsFloatAboveGuaranteedIntegerPrecision(f)
end
---@param v number int
---@return boolean
function M.ImIsPowerOfTwo_Int(v)
    return lib.igImIsPowerOfTwo_Int(v)
end
---@param v number ImU64
---@return boolean
function M.ImIsPowerOfTwo_U64(v)
    return lib.igImIsPowerOfTwo_U64(v)
end
function M.ImIsPowerOfTwo(a1) -- generic version
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return M.ImIsPowerOfTwo_Int(a1) end
    if (ffi.istype('uint64_t',a1) or type(a1)=='number') then return M.ImIsPowerOfTwo_U64(a1) end
    print(a1)
    error'M.ImIsPowerOfTwo could not find overloaded'
end
---@param lhs ImVec2
---@return number float
function M.ImLengthSqr_Vec2(lhs)
    return lib.igImLengthSqr_Vec2(lhs)
end
---@param lhs ffi.ct* const ImVec4
---@return number float
function M.ImLengthSqr_Vec4(lhs)
    return lib.igImLengthSqr_Vec4(lhs)
end
function M.ImLengthSqr(a1) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.ImLengthSqr_Vec2(a1) end
    if ffi.istype('const ImVec4',a1) then return M.ImLengthSqr_Vec4(a1) end
    print(a1)
    error'M.ImLengthSqr could not find overloaded'
end
---@param a ImVec2
---@param b ImVec2
---@param t number float
---@return nil
function M.ImLerp_Vec2Float(a,b,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLerp_Vec2Float(nonUDT_out,a,b,t)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@param t ImVec2
---@return nil
function M.ImLerp_Vec2Vec2(a,b,t)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLerp_Vec2Vec2(nonUDT_out,a,b,t)
    return nonUDT_out
end
---@param a ffi.ct* const ImVec4
---@param b ffi.ct* const ImVec4
---@param t number float
---@return nil
function M.ImLerp_Vec4(a,b,t)
    local nonUDT_out = ffi.new("ImVec4")
    lib.igImLerp_Vec4(nonUDT_out,a,b,t)
    return nonUDT_out
end
function M.ImLerp(a2,a3,a4) -- generic version
    if ffi.istype('const ImVec2',a2) and (ffi.istype('float',a4) or type(a4)=='number') then return M.ImLerp_Vec2Float(a2,a3,a4) end
    if ffi.istype('const ImVec2',a2) and ffi.istype('const ImVec2',a4) then return M.ImLerp_Vec2Vec2(a2,a3,a4) end
    if ffi.istype('const ImVec4',a2) then return M.ImLerp_Vec4(a2,a3,a4) end
    print(a2,a3,a4)
    error'M.ImLerp could not find overloaded'
end
---@param a ImVec2
---@param b ImVec2
---@param p ImVec2
---@return nil
function M.ImLineClosestPoint(a,b,p)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImLineClosestPoint(nonUDT_out,a,b,p)
    return nonUDT_out
end
---@param current number float
---@param target number float
---@param speed number float
---@return number float
function M.ImLinearSweep(current,target,speed)
    return lib.igImLinearSweep(current,target,speed)
end
---@param x number float
---@return number float
function M.ImLog_Float(x)
    return lib.igImLog_Float(x)
end
---@param x number double
---@return number double
function M.ImLog_double(x)
    return lib.igImLog_double(x)
end
function M.ImLog(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImLog_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImLog_double(a1) end
    print(a1)
    error'M.ImLog could not find overloaded'
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMax(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMax(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMin(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMin(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param a number int
---@param b number int
---@return number int
function M.ImModPositive(a,b)
    return lib.igImModPositive(a,b)
end
---@param lhs ImVec2
---@param rhs ImVec2
---@return nil
function M.ImMul(lhs,rhs)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImMul(nonUDT_out,lhs,rhs)
    return nonUDT_out
end
---@param format string
---@return string
function M.ImParseFormatFindEnd(format)
    return ffi.string(lib.igImParseFormatFindEnd(format))
end
---@param format string
---@return string
function M.ImParseFormatFindStart(format)
    return ffi.string(lib.igImParseFormatFindStart(format))
end
---@param format string
---@param default_value number int
---@return number int
function M.ImParseFormatPrecision(format,default_value)
    return lib.igImParseFormatPrecision(format,default_value)
end
---@param fmt_in string
---@param fmt_out ffi.ct* char*
---@param fmt_out_size number size_t
---@return nil
function M.ImParseFormatSanitizeForPrinting(fmt_in,fmt_out,fmt_out_size)
    return lib.igImParseFormatSanitizeForPrinting(fmt_in,fmt_out,fmt_out_size)
end
---@param fmt_in string
---@param fmt_out ffi.ct* char*
---@param fmt_out_size number size_t
---@return string
function M.ImParseFormatSanitizeForScanning(fmt_in,fmt_out,fmt_out_size)
    return ffi.string(lib.igImParseFormatSanitizeForScanning(fmt_in,fmt_out,fmt_out_size))
end
---@param format string
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@return string
function M.ImParseFormatTrimDecorations(format,buf,buf_size)
    return ffi.string(lib.igImParseFormatTrimDecorations(format,buf,buf_size))
end
---@param x number float
---@param y number float
---@return number float
function M.ImPow_Float(x,y)
    return lib.igImPow_Float(x,y)
end
---@param x number double
---@param y number double
---@return number double
function M.ImPow_double(x,y)
    return lib.igImPow_double(x,y)
end
function M.ImPow(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImPow_Float(a1,a2) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImPow_double(a1,a2) end
    print(a1,a2)
    error'M.ImPow could not find overloaded'
end
---@param base ffi.ct* void*
---@param count number size_t
---@param size_of_element number size_t
---@param compare_func ffi.ct* int(*)(void const*,void const*)
---@return nil
function M.ImQsort(base,count,size_of_element,compare_func)
    return lib.igImQsort(base,count,size_of_element,compare_func)
end
---@param v ImVec2
---@param cos_a number float
---@param sin_a number float
---@return nil
function M.ImRotate(v,cos_a,sin_a)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImRotate(nonUDT_out,v,cos_a,sin_a)
    return nonUDT_out
end
---@param x number float
---@return number float
function M.ImRsqrt_Float(x)
    return lib.igImRsqrt_Float(x)
end
---@param x number double
---@return number double
function M.ImRsqrt_double(x)
    return lib.igImRsqrt_double(x)
end
function M.ImRsqrt(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImRsqrt_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImRsqrt_double(a1) end
    print(a1)
    error'M.ImRsqrt could not find overloaded'
end
---@param f number float
---@return number float
function M.ImSaturate(f)
    return lib.igImSaturate(f)
end
---@param x number float
---@return number float
function M.ImSign_Float(x)
    return lib.igImSign_Float(x)
end
---@param x number double
---@return number double
function M.ImSign_double(x)
    return lib.igImSign_double(x)
end
function M.ImSign(a1) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImSign_Float(a1) end
    if (ffi.istype('double',a1) or type(a1)=='number') then return M.ImSign_double(a1) end
    print(a1)
    error'M.ImSign could not find overloaded'
end
---@param str string
---@return string
function M.ImStrSkipBlank(str)
    return ffi.string(lib.igImStrSkipBlank(str))
end
---@param str ffi.ct* char*
---@return nil
function M.ImStrTrimBlanks(str)
    return lib.igImStrTrimBlanks(str)
end
---@param buf_mid_line ffi.ct* const ImWchar*
---@param buf_begin ffi.ct* const ImWchar*
---@return ffi.ct* const ImWchar*
function M.ImStrbolW(buf_mid_line,buf_begin)
    return lib.igImStrbolW(buf_mid_line,buf_begin)
end
---@param str_begin string
---@param str_end string
---@param c number char
---@return string
function M.ImStrchrRange(str_begin,str_end,c)
    return ffi.string(lib.igImStrchrRange(str_begin,str_end,c))
end
---@param str string
---@return ffi.ct* char*
function M.ImStrdup(str)
    return lib.igImStrdup(str)
end
---@param dst ffi.ct* char*
---@param p_dst_size ffi.ct* size_t*
---@param str string
---@return ffi.ct* char*
function M.ImStrdupcpy(dst,p_dst_size,str)
    return lib.igImStrdupcpy(dst,p_dst_size,str)
end
---@param str string
---@param str_end string
---@return string
function M.ImStreolRange(str,str_end)
    return ffi.string(lib.igImStreolRange(str,str_end))
end
---@param str1 string
---@param str2 string
---@return number int
function M.ImStricmp(str1,str2)
    return lib.igImStricmp(str1,str2)
end
---@param haystack string
---@param haystack_end string
---@param needle string
---@param needle_end string
---@return string
function M.ImStristr(haystack,haystack_end,needle,needle_end)
    return ffi.string(lib.igImStristr(haystack,haystack_end,needle,needle_end))
end
---@param str ffi.ct* const ImWchar*
---@return number int
function M.ImStrlenW(str)
    return lib.igImStrlenW(str)
end
---@param dst ffi.ct* char*
---@param src string
---@param count number size_t
---@return nil
function M.ImStrncpy(dst,src,count)
    return lib.igImStrncpy(dst,src,count)
end
---@param str1 string
---@param str2 string
---@param count number size_t
---@return number int
function M.ImStrnicmp(str1,str2,count)
    return lib.igImStrnicmp(str1,str2,count)
end
---@param out_char ffi.ct* unsigned int*
---@param in_text string
---@param in_text_end string
---@return number int
function M.ImTextCharFromUtf8(out_char,in_text,in_text_end)
    return lib.igImTextCharFromUtf8(out_char,in_text,in_text_end)
end
---@param out_buf ffi.ct* char[5]
---@param c number unsigned int
---@return string
function M.ImTextCharToUtf8(out_buf,c)
    return ffi.string(lib.igImTextCharToUtf8(out_buf,c))
end
---@param in_text string
---@param in_text_end string
---@return number int
function M.ImTextCountCharsFromUtf8(in_text,in_text_end)
    return lib.igImTextCountCharsFromUtf8(in_text,in_text_end)
end
---@param in_text string
---@param in_text_end string
---@return number int
function M.ImTextCountUtf8BytesFromChar(in_text,in_text_end)
    return lib.igImTextCountUtf8BytesFromChar(in_text,in_text_end)
end
---@param in_text ffi.ct* const ImWchar*
---@param in_text_end ffi.ct* const ImWchar*
---@return number int
function M.ImTextCountUtf8BytesFromStr(in_text,in_text_end)
    return lib.igImTextCountUtf8BytesFromStr(in_text,in_text_end)
end
---@param in_text_start string
---@param in_text_curr string
---@return string
function M.ImTextFindPreviousUtf8Codepoint(in_text_start,in_text_curr)
    return ffi.string(lib.igImTextFindPreviousUtf8Codepoint(in_text_start,in_text_curr))
end
---@param out_buf ffi.ct* ImWchar*
---@param out_buf_size number int
---@param in_text string
---@param in_text_end string
---@param in_remaining ffi.ct*? const char**
---@return number int
function M.ImTextStrFromUtf8(out_buf,out_buf_size,in_text,in_text_end,in_remaining)
    in_remaining = in_remaining or nil
    return lib.igImTextStrFromUtf8(out_buf,out_buf_size,in_text,in_text_end,in_remaining)
end
---@param out_buf ffi.ct* char*
---@param out_buf_size number int
---@param in_text ffi.ct* const ImWchar*
---@param in_text_end ffi.ct* const ImWchar*
---@return number int
function M.ImTextStrToUtf8(out_buf,out_buf_size,in_text,in_text_end)
    return lib.igImTextStrToUtf8(out_buf,out_buf_size,in_text,in_text_end)
end
---@param c number char
---@return number char
function M.ImToUpper(c)
    return lib.igImToUpper(c)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@return number float
function M.ImTriangleArea(a,b,c)
    return lib.igImTriangleArea(a,b,c)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@param out_u ffi.ct* float*
---@param out_v ffi.ct* float*
---@param out_w ffi.ct* float*
---@return nil
function M.ImTriangleBarycentricCoords(a,b,c,p,out_u,out_v,out_w)
    return lib.igImTriangleBarycentricCoords(a,b,c,p,out_u,out_v,out_w)
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@return nil
function M.ImTriangleClosestPoint(a,b,c,p)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImTriangleClosestPoint(nonUDT_out,a,b,c,p)
    return nonUDT_out
end
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param p ImVec2
---@return boolean
function M.ImTriangleContainsPoint(a,b,c,p)
    return lib.igImTriangleContainsPoint(a,b,c,p)
end
---@param f number float
---@return number float
function M.ImTrunc_Float(f)
    return lib.igImTrunc_Float(f)
end
---@param v ImVec2
---@return nil
function M.ImTrunc_Vec2(v)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igImTrunc_Vec2(nonUDT_out,v)
    return nonUDT_out
end
function M.ImTrunc(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.ImTrunc_Float(a1) end
    if (ffi.istype('ImVec2*',a1) or ffi.istype('ImVec2',a1) or ffi.istype('ImVec2[]',a1)) then return M.ImTrunc_Vec2(a2) end
    print(a1,a2)
    error'M.ImTrunc could not find overloaded'
end
---@param v number int
---@return number int
function M.ImUpperPowerOfTwo(v)
    return lib.igImUpperPowerOfTwo(v)
end
---@param user_texture_id number ImTextureID
---@param image_size ImVec2
---@param uv0 ImVec2?
---@param uv1 ImVec2?
---@param tint_col ffi.ct*? const ImVec4
---@param border_col ffi.ct*? const ImVec4
---@return nil
function M.Image(user_texture_id,image_size,uv0,uv1,tint_col,border_col)
    border_col = border_col or ImVec4(0,0,0,0)
    tint_col = tint_col or ImVec4(1,1,1,1)
    uv0 = uv0 or ImVec2(0,0)
    uv1 = uv1 or ImVec2(1,1)
    return lib.igImage(user_texture_id,image_size,uv0,uv1,tint_col,border_col)
end
---@param str_id string
---@param user_texture_id number ImTextureID
---@param image_size ImVec2
---@param uv0 ImVec2?
---@param uv1 ImVec2?
---@param bg_col ffi.ct*? const ImVec4
---@param tint_col ffi.ct*? const ImVec4
---@return boolean
function M.ImageButton(str_id,user_texture_id,image_size,uv0,uv1,bg_col,tint_col)
    bg_col = bg_col or ImVec4(0,0,0,0)
    tint_col = tint_col or ImVec4(1,1,1,1)
    uv0 = uv0 or ImVec2(0,0)
    uv1 = uv1 or ImVec2(1,1)
    return lib.igImageButton(str_id,user_texture_id,image_size,uv0,uv1,bg_col,tint_col)
end
---@param id number ImGuiID
---@param texture_id number ImTextureID
---@param image_size ImVec2
---@param uv0 ImVec2
---@param uv1 ImVec2
---@param bg_col ffi.ct* const ImVec4
---@param tint_col ffi.ct* const ImVec4
---@param flags ButtonFlags?
---@return boolean
function M.ImageButtonEx(id,texture_id,image_size,uv0,uv1,bg_col,tint_col,flags)
    flags = flags or 0
    return lib.igImageButtonEx(id,texture_id,image_size,uv0,uv1,bg_col,tint_col,flags)
end
---@param indent_w number? float
---@return nil
function M.Indent(indent_w)
    indent_w = indent_w or 0.0
    return lib.igIndent(indent_w)
end
---@return nil
function M.Initialize()
    return lib.igInitialize()
end
---@param label string
---@param v ffi.ct* double*
---@param step number? double
---@param step_fast number? double
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputDouble(label,v,step,step_fast,format,flags)
    flags = flags or 0
    format = format or "%.6f"
    step = step or 0
    step_fast = step_fast or 0
    return lib.igInputDouble(label,v,step,step_fast,format,flags)
end
---@param label string
---@param v ffi.ct* float*
---@param step number? float
---@param step_fast number? float
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputFloat(label,v,step,step_fast,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    step = step or 0.0
    step_fast = step_fast or 0.0
    return lib.igInputFloat(label,v,step,step_fast,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputFloat2(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat2(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputFloat3(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat3(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputFloat4(label,v,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igInputFloat4(label,v,format,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param step number? int
---@param step_fast number? int
---@param flags InputTextFlags?
---@return boolean
function M.InputInt(label,v,step,step_fast,flags)
    flags = flags or 0
    step = step or 1
    step_fast = step_fast or 100
    return lib.igInputInt(label,v,step,step_fast,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param flags InputTextFlags?
---@return boolean
function M.InputInt2(label,v,flags)
    flags = flags or 0
    return lib.igInputInt2(label,v,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param flags InputTextFlags?
---@return boolean
function M.InputInt3(label,v,flags)
    flags = flags or 0
    return lib.igInputInt3(label,v,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param flags InputTextFlags?
---@return boolean
function M.InputInt4(label,v,flags)
    flags = flags or 0
    return lib.igInputInt4(label,v,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param p_step ffi.ct*? const void*
---@param p_step_fast ffi.ct*? const void*
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputScalar(label,data_type,p_data,p_step,p_step_fast,format,flags)
    flags = flags or 0
    format = format or nil
    p_step = p_step or nil
    p_step_fast = p_step_fast or nil
    return lib.igInputScalar(label,data_type,p_data,p_step,p_step_fast,format,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param components number int
---@param p_step ffi.ct*? const void*
---@param p_step_fast ffi.ct*? const void*
---@param format string?
---@param flags InputTextFlags?
---@return boolean
function M.InputScalarN(label,data_type,p_data,components,p_step,p_step_fast,format,flags)
    flags = flags or 0
    format = format or nil
    p_step = p_step or nil
    p_step_fast = p_step_fast or nil
    return lib.igInputScalarN(label,data_type,p_data,components,p_step,p_step_fast,format,flags)
end
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@param flags InputTextFlags?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputText(label,buf,buf_size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    user_data = user_data or nil
    return lib.igInputText(label,buf,buf_size,flags,callback,user_data)
end
---@param id number ImGuiID
---@return nil
function M.InputTextDeactivateHook(id)
    return lib.igInputTextDeactivateHook(id)
end
---@param label string
---@param hint string
---@param buf ffi.ct* char*
---@param buf_size number int
---@param size_arg ImVec2
---@param flags InputTextFlags
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextEx(label,hint,buf,buf_size,size_arg,flags,callback,user_data)
    callback = callback or nil
    user_data = user_data or nil
    return lib.igInputTextEx(label,hint,buf,buf_size,size_arg,flags,callback,user_data)
end
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@param size ImVec2?
---@param flags InputTextFlags?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextMultiline(label,buf,buf_size,size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    size = size or ImVec2(0,0)
    user_data = user_data or nil
    return lib.igInputTextMultiline(label,buf,buf_size,size,flags,callback,user_data)
end
---@param label string
---@param hint string
---@param buf ffi.ct* char*
---@param buf_size number size_t
---@param flags InputTextFlags?
---@param callback ffi.ct*? ImGuiInputTextCallback
---@param user_data ffi.ct*? void*
---@return boolean
function M.InputTextWithHint(label,hint,buf,buf_size,flags,callback,user_data)
    callback = callback or nil
    flags = flags or 0
    user_data = user_data or nil
    return lib.igInputTextWithHint(label,hint,buf,buf_size,flags,callback,user_data)
end
---@param str_id string
---@param size ImVec2
---@param flags ButtonFlags?
---@return boolean
function M.InvisibleButton(str_id,size,flags)
    flags = flags or 0
    return lib.igInvisibleButton(str_id,size,flags)
end
---@param dir Dir
---@return boolean
function M.IsActiveIdUsingNavDir(dir)
    return lib.igIsActiveIdUsingNavDir(dir)
end
---@param key Key
---@return boolean
function M.IsAliasKey(key)
    return lib.igIsAliasKey(key)
end
---@return boolean
function M.IsAnyItemActive()
    return lib.igIsAnyItemActive()
end
---@return boolean
function M.IsAnyItemFocused()
    return lib.igIsAnyItemFocused()
end
---@return boolean
function M.IsAnyItemHovered()
    return lib.igIsAnyItemHovered()
end
---@return boolean
function M.IsAnyMouseDown()
    return lib.igIsAnyMouseDown()
end
---@param bb ImRect
---@param id number ImGuiID
---@return boolean
function M.IsClippedEx(bb,id)
    return lib.igIsClippedEx(bb,id)
end
---@return boolean
function M.IsDragDropActive()
    return lib.igIsDragDropActive()
end
---@return boolean
function M.IsDragDropPayloadBeingAccepted()
    return lib.igIsDragDropPayloadBeingAccepted()
end
---@param key Key
---@return boolean
function M.IsGamepadKey(key)
    return lib.igIsGamepadKey(key)
end
---@return boolean
function M.IsItemActivated()
    return lib.igIsItemActivated()
end
---@return boolean
function M.IsItemActive()
    return lib.igIsItemActive()
end
---@param mouse_button MouseButton?
---@return boolean
function M.IsItemClicked(mouse_button)
    mouse_button = mouse_button or 0
    return lib.igIsItemClicked(mouse_button)
end
---@return boolean
function M.IsItemDeactivated()
    return lib.igIsItemDeactivated()
end
---@return boolean
function M.IsItemDeactivatedAfterEdit()
    return lib.igIsItemDeactivatedAfterEdit()
end
---@return boolean
function M.IsItemEdited()
    return lib.igIsItemEdited()
end
---@return boolean
function M.IsItemFocused()
    return lib.igIsItemFocused()
end
---@param flags HoveredFlags?
---@return boolean
function M.IsItemHovered(flags)
    flags = flags or 0
    return lib.igIsItemHovered(flags)
end
---@return boolean
function M.IsItemToggledOpen()
    return lib.igIsItemToggledOpen()
end
---@return boolean
function M.IsItemToggledSelection()
    return lib.igIsItemToggledSelection()
end
---@return boolean
function M.IsItemVisible()
    return lib.igIsItemVisible()
end
---@param key_chord number ImGuiKeyChord
---@return boolean
function M.IsKeyChordPressed_Nil(key_chord)
    return lib.igIsKeyChordPressed_Nil(key_chord)
end
---@param key_chord number ImGuiKeyChord
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return boolean
function M.IsKeyChordPressed_ID(key_chord,owner_id,flags)
    flags = flags or 0
    return lib.igIsKeyChordPressed_ID(key_chord,owner_id,flags)
end
function M.IsKeyChordPressed(a1,a2,a3) -- generic version
    if a2==nil then return M.IsKeyChordPressed_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsKeyChordPressed_ID(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.IsKeyChordPressed could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsKeyDown_Nil(key)
    return lib.igIsKeyDown_Nil(key)
end
---@param key Key
---@param owner_id number ImGuiID
---@return boolean
function M.IsKeyDown_ID(key,owner_id)
    return lib.igIsKeyDown_ID(key,owner_id)
end
function M.IsKeyDown(a1,a2) -- generic version
    if a2==nil then return M.IsKeyDown_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsKeyDown_ID(a1,a2) end
    print(a1,a2)
    error'M.IsKeyDown could not find overloaded'
end
---@param key Key
---@param _repeat boolean
---@return boolean
function M.IsKeyPressed_Bool(key,_repeat)
    if _repeat == nil then _repeat = true end
    return lib.igIsKeyPressed_Bool(key,_repeat)
end
---@param key Key
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return boolean
function M.IsKeyPressed_ID(key,owner_id,flags)
    flags = flags or 0
    return lib.igIsKeyPressed_ID(key,owner_id,flags)
end
function M.IsKeyPressed(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.IsKeyPressed_Bool(a1,a2) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsKeyPressed_ID(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.IsKeyPressed could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsKeyReleased_Nil(key)
    return lib.igIsKeyReleased_Nil(key)
end
---@param key Key
---@param owner_id number ImGuiID
---@return boolean
function M.IsKeyReleased_ID(key,owner_id)
    return lib.igIsKeyReleased_ID(key,owner_id)
end
function M.IsKeyReleased(a1,a2) -- generic version
    if a2==nil then return M.IsKeyReleased_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsKeyReleased_ID(a1,a2) end
    print(a1,a2)
    error'M.IsKeyReleased could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsKeyboardKey(key)
    return lib.igIsKeyboardKey(key)
end
---@param key Key
---@return boolean
function M.IsLegacyKey(key)
    return lib.igIsLegacyKey(key)
end
---@param key Key
---@return boolean
function M.IsModKey(key)
    return lib.igIsModKey(key)
end
---@param button MouseButton
---@param _repeat boolean
---@return boolean
function M.IsMouseClicked_Bool(button,_repeat)
    _repeat = _repeat or false
    return lib.igIsMouseClicked_Bool(button,_repeat)
end
---@param button MouseButton
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return boolean
function M.IsMouseClicked_ID(button,owner_id,flags)
    flags = flags or 0
    return lib.igIsMouseClicked_ID(button,owner_id,flags)
end
function M.IsMouseClicked(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.IsMouseClicked_Bool(a1,a2) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsMouseClicked_ID(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.IsMouseClicked could not find overloaded'
end
---@param button MouseButton
---@return boolean
function M.IsMouseDoubleClicked_Nil(button)
    return lib.igIsMouseDoubleClicked_Nil(button)
end
---@param button MouseButton
---@param owner_id number ImGuiID
---@return boolean
function M.IsMouseDoubleClicked_ID(button,owner_id)
    return lib.igIsMouseDoubleClicked_ID(button,owner_id)
end
function M.IsMouseDoubleClicked(a1,a2) -- generic version
    if a2==nil then return M.IsMouseDoubleClicked_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsMouseDoubleClicked_ID(a1,a2) end
    print(a1,a2)
    error'M.IsMouseDoubleClicked could not find overloaded'
end
---@param button MouseButton
---@return boolean
function M.IsMouseDown_Nil(button)
    return lib.igIsMouseDown_Nil(button)
end
---@param button MouseButton
---@param owner_id number ImGuiID
---@return boolean
function M.IsMouseDown_ID(button,owner_id)
    return lib.igIsMouseDown_ID(button,owner_id)
end
function M.IsMouseDown(a1,a2) -- generic version
    if a2==nil then return M.IsMouseDown_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsMouseDown_ID(a1,a2) end
    print(a1,a2)
    error'M.IsMouseDown could not find overloaded'
end
---@param button MouseButton
---@param lock_threshold number? float
---@return boolean
function M.IsMouseDragPastThreshold(button,lock_threshold)
    lock_threshold = lock_threshold or -1.0
    return lib.igIsMouseDragPastThreshold(button,lock_threshold)
end
---@param button MouseButton
---@param lock_threshold number? float
---@return boolean
function M.IsMouseDragging(button,lock_threshold)
    lock_threshold = lock_threshold or -1.0
    return lib.igIsMouseDragging(button,lock_threshold)
end
---@param r_min ImVec2
---@param r_max ImVec2
---@param clip boolean?
---@return boolean
function M.IsMouseHoveringRect(r_min,r_max,clip)
    if clip == nil then clip = true end
    return lib.igIsMouseHoveringRect(r_min,r_max,clip)
end
---@param key Key
---@return boolean
function M.IsMouseKey(key)
    return lib.igIsMouseKey(key)
end
---@param mouse_pos ffi.ct*? const ImVec2*
---@return boolean
function M.IsMousePosValid(mouse_pos)
    mouse_pos = mouse_pos or nil
    return lib.igIsMousePosValid(mouse_pos)
end
---@param button MouseButton
---@return boolean
function M.IsMouseReleased_Nil(button)
    return lib.igIsMouseReleased_Nil(button)
end
---@param button MouseButton
---@param owner_id number ImGuiID
---@return boolean
function M.IsMouseReleased_ID(button,owner_id)
    return lib.igIsMouseReleased_ID(button,owner_id)
end
function M.IsMouseReleased(a1,a2) -- generic version
    if a2==nil then return M.IsMouseReleased_Nil(a1) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.IsMouseReleased_ID(a1,a2) end
    print(a1,a2)
    error'M.IsMouseReleased could not find overloaded'
end
---@param key Key
---@return boolean
function M.IsNamedKey(key)
    return lib.igIsNamedKey(key)
end
---@param key Key
---@return boolean
function M.IsNamedKeyOrModKey(key)
    return lib.igIsNamedKeyOrModKey(key)
end
---@param str_id string
---@param flags PopupFlags?
---@return boolean
function M.IsPopupOpen_Str(str_id,flags)
    flags = flags or 0
    return lib.igIsPopupOpen_Str(str_id,flags)
end
---@param id number ImGuiID
---@param popup_flags PopupFlags
---@return boolean
function M.IsPopupOpen_ID(id,popup_flags)
    return lib.igIsPopupOpen_ID(id,popup_flags)
end
function M.IsPopupOpen(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.IsPopupOpen_Str(a1,a2) end
    if (ffi.istype('uint32_t',a1) or type(a1)=='number') then return M.IsPopupOpen_ID(a1,a2) end
    print(a1,a2)
    error'M.IsPopupOpen could not find overloaded'
end
---@param size ImVec2
---@return boolean
function M.IsRectVisible_Nil(size)
    return lib.igIsRectVisible_Nil(size)
end
---@param rect_min ImVec2
---@param rect_max ImVec2
---@return boolean
function M.IsRectVisible_Vec2(rect_min,rect_max)
    return lib.igIsRectVisible_Vec2(rect_min,rect_max)
end
function M.IsRectVisible(a1,a2) -- generic version
    if a2==nil then return M.IsRectVisible_Nil(a1) end
    if ffi.istype('const ImVec2',a2) then return M.IsRectVisible_Vec2(a1,a2) end
    print(a1,a2)
    error'M.IsRectVisible could not find overloaded'
end
---@param potential_above ffi.ct* ImGuiWindow*
---@param potential_below ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowAbove(potential_above,potential_below)
    return lib.igIsWindowAbove(potential_above,potential_below)
end
---@return boolean
function M.IsWindowAppearing()
    return lib.igIsWindowAppearing()
end
---@param window ffi.ct* ImGuiWindow*
---@param potential_parent ffi.ct* ImGuiWindow*
---@param popup_hierarchy boolean
---@param dock_hierarchy boolean
---@return boolean
function M.IsWindowChildOf(window,potential_parent,popup_hierarchy,dock_hierarchy)
    return lib.igIsWindowChildOf(window,potential_parent,popup_hierarchy,dock_hierarchy)
end
---@return boolean
function M.IsWindowCollapsed()
    return lib.igIsWindowCollapsed()
end
---@param window ffi.ct* ImGuiWindow*
---@param flags HoveredFlags?
---@return boolean
function M.IsWindowContentHoverable(window,flags)
    flags = flags or 0
    return lib.igIsWindowContentHoverable(window,flags)
end
---@return boolean
function M.IsWindowDocked()
    return lib.igIsWindowDocked()
end
---@param flags FocusedFlags?
---@return boolean
function M.IsWindowFocused(flags)
    flags = flags or 0
    return lib.igIsWindowFocused(flags)
end
---@param flags HoveredFlags?
---@return boolean
function M.IsWindowHovered(flags)
    flags = flags or 0
    return lib.igIsWindowHovered(flags)
end
---@param window ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowNavFocusable(window)
    return lib.igIsWindowNavFocusable(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param potential_parent ffi.ct* ImGuiWindow*
---@return boolean
function M.IsWindowWithinBeginStackOf(window,potential_parent)
    return lib.igIsWindowWithinBeginStackOf(window,potential_parent)
end
---@param bb ImRect
---@param id number ImGuiID
---@param nav_bb ffi.ct*? const ImRect*
---@param extra_flags ItemFlags?
---@return boolean
function M.ItemAdd(bb,id,nav_bb,extra_flags)
    extra_flags = extra_flags or 0
    nav_bb = nav_bb or nil
    return lib.igItemAdd(bb,id,nav_bb,extra_flags)
end
---@param bb ImRect
---@param id number ImGuiID
---@param item_flags ItemFlags
---@return boolean
function M.ItemHoverable(bb,id,item_flags)
    return lib.igItemHoverable(bb,id,item_flags)
end
---@param size ImVec2
---@param text_baseline_y number? float
---@return nil
function M.ItemSize_Vec2(size,text_baseline_y)
    text_baseline_y = text_baseline_y or -1.0
    return lib.igItemSize_Vec2(size,text_baseline_y)
end
---@param bb ImRect
---@param text_baseline_y number? float
---@return nil
function M.ItemSize_Rect(bb,text_baseline_y)
    text_baseline_y = text_baseline_y or -1.0
    return lib.igItemSize_Rect(bb,text_baseline_y)
end
function M.ItemSize(a1,a2) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.ItemSize_Vec2(a1,a2) end
    if ffi.istype('const ImRect',a1) then return M.ItemSize_Rect(a1,a2) end
    print(a1,a2)
    error'M.ItemSize could not find overloaded'
end
---@param id number ImGuiID
---@return nil
function M.KeepAliveID(id)
    return lib.igKeepAliveID(id)
end
---@param label string
---@param fmt string
---@return nil
function M.LabelText(label,fmt,...)
    return lib.igLabelText(label,fmt,...)
end
---@param label string
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.LabelTextV(label,fmt,args)
    return lib.igLabelTextV(label,fmt,args)
end
---@param label string
---@param current_item ffi.ct* int*
---@param items ffi.ct* const char* const[]
---@param items_count number int
---@param height_in_items number? int
---@return boolean
function M.ListBox_Str_arr(label,current_item,items,items_count,height_in_items)
    height_in_items = height_in_items or -1
    return lib.igListBox_Str_arr(label,current_item,items,items_count,height_in_items)
end
---@param label string
---@param current_item ffi.ct* int*
---@param getter ffi.ct* const char*(*)(void* user_data,int idx)
---@param user_data ffi.ct* void*
---@param items_count number int
---@param height_in_items number? int
---@return boolean
function M.ListBox_FnStrPtr(label,current_item,getter,user_data,items_count,height_in_items)
    height_in_items = height_in_items or -1
    return lib.igListBox_FnStrPtr(label,current_item,getter,user_data,items_count,height_in_items)
end
function M.ListBox(a1,a2,a3,a4,a5,a6) -- generic version
    if (ffi.istype('const char* const[]',a3) or ffi.istype('const char const[]',a3) or ffi.istype('const char const[][]',a3)) then return M.ListBox_Str_arr(a1,a2,a3,a4,a5) end
    if ffi.istype('const char*(*)(void* user_data,int idx)',a3) then return M.ListBox_FnStrPtr(a1,a2,a3,a4,a5,a6) end
    print(a1,a2,a3,a4,a5,a6)
    error'M.ListBox could not find overloaded'
end
---@param ini_filename string
---@return nil
function M.LoadIniSettingsFromDisk(ini_filename)
    return lib.igLoadIniSettingsFromDisk(ini_filename)
end
---@param ini_data string
---@param ini_size number? size_t
---@return nil
function M.LoadIniSettingsFromMemory(ini_data,ini_size)
    ini_size = ini_size or 0
    return lib.igLoadIniSettingsFromMemory(ini_data,ini_size)
end
---@param key LocKey
---@return string
function M.LocalizeGetMsg(key)
    return ffi.string(lib.igLocalizeGetMsg(key))
end
---@param entries ffi.ct* const ImGuiLocEntry*
---@param count number int
---@return nil
function M.LocalizeRegisterEntries(entries,count)
    return lib.igLocalizeRegisterEntries(entries,count)
end
---@param type LogType
---@param auto_open_depth number int
---@return nil
function M.LogBegin(type,auto_open_depth)
    return lib.igLogBegin(type,auto_open_depth)
end
---@return nil
function M.LogButtons()
    return lib.igLogButtons()
end
---@return nil
function M.LogFinish()
    return lib.igLogFinish()
end
---@param ref_pos ffi.ct* const ImVec2*
---@param text string
---@param text_end string?
---@return nil
function M.LogRenderedText(ref_pos,text,text_end)
    text_end = text_end or nil
    return lib.igLogRenderedText(ref_pos,text,text_end)
end
---@param prefix string
---@param suffix string
---@return nil
function M.LogSetNextTextDecoration(prefix,suffix)
    return lib.igLogSetNextTextDecoration(prefix,suffix)
end
---@param fmt string
---@return nil
function M.LogText(fmt,...)
    return lib.igLogText(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.LogTextV(fmt,args)
    return lib.igLogTextV(fmt,args)
end
---@param auto_open_depth number? int
---@return nil
function M.LogToBuffer(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToBuffer(auto_open_depth)
end
---@param auto_open_depth number? int
---@return nil
function M.LogToClipboard(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToClipboard(auto_open_depth)
end
---@param auto_open_depth number? int
---@param filename string?
---@return nil
function M.LogToFile(auto_open_depth,filename)
    auto_open_depth = auto_open_depth or -1
    filename = filename or nil
    return lib.igLogToFile(auto_open_depth,filename)
end
---@param auto_open_depth number? int
---@return nil
function M.LogToTTY(auto_open_depth)
    auto_open_depth = auto_open_depth or -1
    return lib.igLogToTTY(auto_open_depth)
end
---@return nil
function M.MarkIniSettingsDirty_Nil()
    return lib.igMarkIniSettingsDirty_Nil()
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.MarkIniSettingsDirty_WindowPtr(window)
    return lib.igMarkIniSettingsDirty_WindowPtr(window)
end
function M.MarkIniSettingsDirty(a1) -- generic version
    if a1==nil then return M.MarkIniSettingsDirty_Nil() end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.MarkIniSettingsDirty_WindowPtr(a1) end
    print(a1)
    error'M.MarkIniSettingsDirty could not find overloaded'
end
---@param id number ImGuiID
---@return nil
function M.MarkItemEdited(id)
    return lib.igMarkItemEdited(id)
end
---@param size number size_t
---@return ffi.ct* void*
function M.MemAlloc(size)
    return lib.igMemAlloc(size)
end
---@param ptr ffi.ct* void*
---@return nil
function M.MemFree(ptr)
    return lib.igMemFree(ptr)
end
---@param label string
---@param shortcut string?
---@param selected boolean?
---@param enabled boolean?
---@return boolean
function M.MenuItem_Bool(label,shortcut,selected,enabled)
    if enabled == nil then enabled = true end
    selected = selected or false
    shortcut = shortcut or nil
    return lib.igMenuItem_Bool(label,shortcut,selected,enabled)
end
---@param label string
---@param shortcut string
---@param p_selected ffi.ct* bool*
---@param enabled boolean?
---@return boolean
function M.MenuItem_BoolPtr(label,shortcut,p_selected,enabled)
    if enabled == nil then enabled = true end
    return lib.igMenuItem_BoolPtr(label,shortcut,p_selected,enabled)
end
function M.MenuItem(a1,a2,a3,a4) -- generic version
    if ((ffi.istype('bool',a3) or type(a3)=='boolean') or type(a3)=='nil') then return M.MenuItem_Bool(a1,a2,a3,a4) end
    if (ffi.istype('bool*',a3) or ffi.istype('bool[]',a3)) then return M.MenuItem_BoolPtr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.MenuItem could not find overloaded'
end
---@param label string
---@param icon string
---@param shortcut string?
---@param selected boolean?
---@param enabled boolean?
---@return boolean
function M.MenuItemEx(label,icon,shortcut,selected,enabled)
    if enabled == nil then enabled = true end
    selected = selected or false
    shortcut = shortcut or nil
    return lib.igMenuItemEx(label,icon,shortcut,selected,enabled)
end
---@param button MouseButton
---@return Key
function M.MouseButtonToKey(button)
    return lib.igMouseButtonToKey(button)
end
---@param axis Axis
---@return nil
function M.NavClearPreferredPosForAxis(axis)
    return lib.igNavClearPreferredPosForAxis(axis)
end
---@param id number ImGuiID
---@return nil
function M.NavHighlightActivated(id)
    return lib.igNavHighlightActivated(id)
end
---@return nil
function M.NavInitRequestApplyResult()
    return lib.igNavInitRequestApplyResult()
end
---@param window ffi.ct* ImGuiWindow*
---@param force_reinit boolean
---@return nil
function M.NavInitWindow(window,force_reinit)
    return lib.igNavInitWindow(window,force_reinit)
end
---@return nil
function M.NavMoveRequestApplyResult()
    return lib.igNavMoveRequestApplyResult()
end
---@return boolean
function M.NavMoveRequestButNoResultYet()
    return lib.igNavMoveRequestButNoResultYet()
end
---@return nil
function M.NavMoveRequestCancel()
    return lib.igNavMoveRequestCancel()
end
---@param move_dir Dir
---@param clip_dir Dir
---@param move_flags NavMoveFlags
---@param scroll_flags ScrollFlags
---@return nil
function M.NavMoveRequestForward(move_dir,clip_dir,move_flags,scroll_flags)
    return lib.igNavMoveRequestForward(move_dir,clip_dir,move_flags,scroll_flags)
end
---@param result ffi.ct* ImGuiNavItemData*
---@return nil
function M.NavMoveRequestResolveWithLastItem(result)
    return lib.igNavMoveRequestResolveWithLastItem(result)
end
---@param result ffi.ct* ImGuiNavItemData*
---@param tree_node_data ffi.ct* ImGuiNavTreeNodeData*
---@return nil
function M.NavMoveRequestResolveWithPastTreeNode(result,tree_node_data)
    return lib.igNavMoveRequestResolveWithPastTreeNode(result,tree_node_data)
end
---@param move_dir Dir
---@param clip_dir Dir
---@param move_flags NavMoveFlags
---@param scroll_flags ScrollFlags
---@return nil
function M.NavMoveRequestSubmit(move_dir,clip_dir,move_flags,scroll_flags)
    return lib.igNavMoveRequestSubmit(move_dir,clip_dir,move_flags,scroll_flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param move_flags NavMoveFlags
---@return nil
function M.NavMoveRequestTryWrapping(window,move_flags)
    return lib.igNavMoveRequestTryWrapping(window,move_flags)
end
---@return nil
function M.NavRestoreHighlightAfterMove()
    return lib.igNavRestoreHighlightAfterMove()
end
---@return nil
function M.NavUpdateCurrentWindowIsScrollPushableX()
    return lib.igNavUpdateCurrentWindowIsScrollPushableX()
end
---@return nil
function M.NewFrame()
    return lib.igNewFrame()
end
---@return nil
function M.NewLine()
    return lib.igNewLine()
end
---@return nil
function M.NextColumn()
    return lib.igNextColumn()
end
---@param str_id string
---@param popup_flags PopupFlags?
---@return nil
function M.OpenPopup_Str(str_id,popup_flags)
    popup_flags = popup_flags or 0
    return lib.igOpenPopup_Str(str_id,popup_flags)
end
---@param id number ImGuiID
---@param popup_flags PopupFlags?
---@return nil
function M.OpenPopup_ID(id,popup_flags)
    popup_flags = popup_flags or 0
    return lib.igOpenPopup_ID(id,popup_flags)
end
function M.OpenPopup(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.OpenPopup_Str(a1,a2) end
    if (ffi.istype('uint32_t',a1) or type(a1)=='number') then return M.OpenPopup_ID(a1,a2) end
    print(a1,a2)
    error'M.OpenPopup could not find overloaded'
end
---@param id number ImGuiID
---@param popup_flags PopupFlags?
---@return nil
function M.OpenPopupEx(id,popup_flags)
    popup_flags = popup_flags or 0
    return lib.igOpenPopupEx(id,popup_flags)
end
---@param str_id string?
---@param popup_flags PopupFlags?
---@return nil
function M.OpenPopupOnItemClick(str_id,popup_flags)
    popup_flags = popup_flags or 1
    str_id = str_id or nil
    return lib.igOpenPopupOnItemClick(str_id,popup_flags)
end
---@param plot_type PlotType
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number int
---@param values_offset number int
---@param overlay_text string
---@param scale_min number float
---@param scale_max number float
---@param size_arg ImVec2
---@return number int
function M.PlotEx(plot_type,label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,size_arg)
    return lib.igPlotEx(plot_type,label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,size_arg)
end
---@param label string
---@param values ffi.ct* const float*
---@param values_count number int
---@param values_offset number? int
---@param overlay_text string?
---@param scale_min number? float
---@param scale_max number? float
---@param graph_size ImVec2?
---@param stride number? int
---@return nil
function M.PlotHistogram_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    stride = stride or ffi.sizeof("float")
    values_offset = values_offset or 0
    return lib.igPlotHistogram_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
end
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number int
---@param values_offset number? int
---@param overlay_text string?
---@param scale_min number? float
---@param scale_max number? float
---@param graph_size ImVec2?
---@return nil
function M.PlotHistogram_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    values_offset = values_offset or 0
    return lib.igPlotHistogram_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
end
function M.PlotHistogram(a1,a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if (ffi.istype('float*',a2) or ffi.istype('float[]',a2)) then return M.PlotHistogram_FloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    if ffi.istype('float(*)(void* data,int idx)',a2) then return M.PlotHistogram_FnFloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a1,a2,a3,a4,a5,a6,a7,a8,a9)
    error'M.PlotHistogram could not find overloaded'
end
---@param label string
---@param values ffi.ct* const float*
---@param values_count number int
---@param values_offset number? int
---@param overlay_text string?
---@param scale_min number? float
---@param scale_max number? float
---@param graph_size ImVec2?
---@param stride number? int
---@return nil
function M.PlotLines_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    stride = stride or ffi.sizeof("float")
    values_offset = values_offset or 0
    return lib.igPlotLines_FloatPtr(label,values,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size,stride)
end
---@param label string
---@param values_getter ffi.ct* float(*)(void* data,int idx)
---@param data ffi.ct* void*
---@param values_count number int
---@param values_offset number? int
---@param overlay_text string?
---@param scale_min number? float
---@param scale_max number? float
---@param graph_size ImVec2?
---@return nil
function M.PlotLines_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
    graph_size = graph_size or ImVec2(0,0)
    overlay_text = overlay_text or nil
    scale_max = scale_max or M.FLT_MAX
    scale_min = scale_min or M.FLT_MAX
    values_offset = values_offset or 0
    return lib.igPlotLines_FnFloatPtr(label,values_getter,data,values_count,values_offset,overlay_text,scale_min,scale_max,graph_size)
end
function M.PlotLines(a1,a2,a3,a4,a5,a6,a7,a8,a9) -- generic version
    if (ffi.istype('float*',a2) or ffi.istype('float[]',a2)) then return M.PlotLines_FloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    if ffi.istype('float(*)(void* data,int idx)',a2) then return M.PlotLines_FnFloatPtr(a1,a2,a3,a4,a5,a6,a7,a8,a9) end
    print(a1,a2,a3,a4,a5,a6,a7,a8,a9)
    error'M.PlotLines could not find overloaded'
end
---@return nil
function M.PopButtonRepeat()
    return lib.igPopButtonRepeat()
end
---@return nil
function M.PopClipRect()
    return lib.igPopClipRect()
end
---@return nil
function M.PopColumnsBackground()
    return lib.igPopColumnsBackground()
end
---@return nil
function M.PopFocusScope()
    return lib.igPopFocusScope()
end
---@return nil
function M.PopFont()
    return lib.igPopFont()
end
---@return nil
function M.PopID()
    return lib.igPopID()
end
---@return nil
function M.PopItemFlag()
    return lib.igPopItemFlag()
end
---@return nil
function M.PopItemWidth()
    return lib.igPopItemWidth()
end
---@param count number? int
---@return nil
function M.PopStyleColor(count)
    count = count or 1
    return lib.igPopStyleColor(count)
end
---@param count number? int
---@return nil
function M.PopStyleVar(count)
    count = count or 1
    return lib.igPopStyleVar(count)
end
---@return nil
function M.PopTabStop()
    return lib.igPopTabStop()
end
---@return nil
function M.PopTextWrapPos()
    return lib.igPopTextWrapPos()
end
---@param fraction number float
---@param size_arg ImVec2?
---@param overlay string?
---@return nil
function M.ProgressBar(fraction,size_arg,overlay)
    overlay = overlay or nil
    size_arg = size_arg or ImVec2(-M.FLT_MIN,0)
    return lib.igProgressBar(fraction,size_arg,overlay)
end
---@param _repeat boolean
---@return nil
function M.PushButtonRepeat(_repeat)
    return lib.igPushButtonRepeat(_repeat)
end
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect boolean
---@return nil
function M.PushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
    return lib.igPushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect)
end
---@param column_index number int
---@return nil
function M.PushColumnClipRect(column_index)
    return lib.igPushColumnClipRect(column_index)
end
---@return nil
function M.PushColumnsBackground()
    return lib.igPushColumnsBackground()
end
---@param id number ImGuiID
---@return nil
function M.PushFocusScope(id)
    return lib.igPushFocusScope(id)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.PushFont(font)
    return lib.igPushFont(font)
end
---@param str_id string
---@return nil
function M.PushID_Str(str_id)
    return lib.igPushID_Str(str_id)
end
---@param str_id_begin string
---@param str_id_end string
---@return nil
function M.PushID_StrStr(str_id_begin,str_id_end)
    return lib.igPushID_StrStr(str_id_begin,str_id_end)
end
---@param ptr_id ffi.ct* const void*
---@return nil
function M.PushID_Ptr(ptr_id)
    return lib.igPushID_Ptr(ptr_id)
end
---@param int_id number int
---@return nil
function M.PushID_Int(int_id)
    return lib.igPushID_Int(int_id)
end
function M.PushID(a1,a2) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.PushID_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.PushID_StrStr(a1,a2) end
    if ffi.istype('void *',a1) then return M.PushID_Ptr(a1) end
    if (ffi.istype('int32_t',a1) or type(a1)=='number') then return M.PushID_Int(a1) end
    print(a1,a2)
    error'M.PushID could not find overloaded'
end
---@param option ItemFlags
---@param enabled boolean
---@return nil
function M.PushItemFlag(option,enabled)
    return lib.igPushItemFlag(option,enabled)
end
---@param item_width number float
---@return nil
function M.PushItemWidth(item_width)
    return lib.igPushItemWidth(item_width)
end
---@param components number int
---@param width_full number float
---@return nil
function M.PushMultiItemsWidths(components,width_full)
    return lib.igPushMultiItemsWidths(components,width_full)
end
---@param id number ImGuiID
---@return nil
function M.PushOverrideID(id)
    return lib.igPushOverrideID(id)
end
---@param idx Col
---@param col number ImU32
---@return nil
function M.PushStyleColor_U32(idx,col)
    return lib.igPushStyleColor_U32(idx,col)
end
---@param idx Col
---@param col ffi.ct* const ImVec4
---@return nil
function M.PushStyleColor_Vec4(idx,col)
    return lib.igPushStyleColor_Vec4(idx,col)
end
function M.PushStyleColor(a1,a2) -- generic version
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.PushStyleColor_U32(a1,a2) end
    if ffi.istype('const ImVec4',a2) then return M.PushStyleColor_Vec4(a1,a2) end
    print(a1,a2)
    error'M.PushStyleColor could not find overloaded'
end
---@param idx StyleVar
---@param val number float
---@return nil
function M.PushStyleVar_Float(idx,val)
    return lib.igPushStyleVar_Float(idx,val)
end
---@param idx StyleVar
---@param val ImVec2
---@return nil
function M.PushStyleVar_Vec2(idx,val)
    return lib.igPushStyleVar_Vec2(idx,val)
end
function M.PushStyleVar(a1,a2) -- generic version
    if (ffi.istype('float',a2) or type(a2)=='number') then return M.PushStyleVar_Float(a1,a2) end
    if ffi.istype('const ImVec2',a2) then return M.PushStyleVar_Vec2(a1,a2) end
    print(a1,a2)
    error'M.PushStyleVar could not find overloaded'
end
---@param tab_stop boolean
---@return nil
function M.PushTabStop(tab_stop)
    return lib.igPushTabStop(tab_stop)
end
---@param wrap_local_pos_x number? float
---@return nil
function M.PushTextWrapPos(wrap_local_pos_x)
    wrap_local_pos_x = wrap_local_pos_x or 0.0
    return lib.igPushTextWrapPos(wrap_local_pos_x)
end
---@param label string
---@param active boolean
---@return boolean
function M.RadioButton_Bool(label,active)
    return lib.igRadioButton_Bool(label,active)
end
---@param label string
---@param v ffi.ct* int*
---@param v_button number int
---@return boolean
function M.RadioButton_IntPtr(label,v,v_button)
    return lib.igRadioButton_IntPtr(label,v,v_button)
end
function M.RadioButton(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.RadioButton_Bool(a1,a2) end
    if ffi.typeof('int32_t*') == ffi.typeof(a2) or ffi.typeof('const int32_t*') == ffi.typeof(a2) or ffi.typeof('int32_t[?]') == ffi.typeof(a2) or ffi.typeof('const int32_t[?]') == ffi.typeof(a2) then return M.RadioButton_IntPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.RadioButton could not find overloaded'
end
---@param context ffi.ct* ImGuiContext*
---@param hook_to_remove number ImGuiID
---@return nil
function M.RemoveContextHook(context,hook_to_remove)
    return lib.igRemoveContextHook(context,hook_to_remove)
end
---@param type_name string
---@return nil
function M.RemoveSettingsHandler(type_name)
    return lib.igRemoveSettingsHandler(type_name)
end
---@return nil
function M.Render()
    return lib.igRender()
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number ImU32
---@param dir Dir
---@param scale number? float
---@return nil
function M.RenderArrow(draw_list,pos,col,dir,scale)
    scale = scale or 1.0
    return lib.igRenderArrow(draw_list,pos,col,dir,scale)
end
---@param draw_list ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param sz number float
---@param col number ImU32
---@return nil
function M.RenderArrowDockMenu(draw_list,p_min,sz,col)
    return lib.igRenderArrowDockMenu(draw_list,p_min,sz,col)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param half_sz ImVec2
---@param direction Dir
---@param col number ImU32
---@return nil
function M.RenderArrowPointingAt(draw_list,pos,half_sz,direction,col)
    return lib.igRenderArrowPointingAt(draw_list,pos,half_sz,direction,col)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number ImU32
---@return nil
function M.RenderBullet(draw_list,pos,col)
    return lib.igRenderBullet(draw_list,pos,col)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos ImVec2
---@param col number ImU32
---@param sz number float
---@return nil
function M.RenderCheckMark(draw_list,pos,col,sz)
    return lib.igRenderCheckMark(draw_list,pos,col,sz)
end
---@param draw_list ffi.ct* ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param fill_col number ImU32
---@param grid_step number float
---@param grid_off ImVec2
---@param rounding number? float
---@param flags ImDrawFlags?
---@return nil
function M.RenderColorRectWithAlphaCheckerboard(draw_list,p_min,p_max,fill_col,grid_step,grid_off,rounding,flags)
    flags = flags or 0
    rounding = rounding or 0.0
    return lib.igRenderColorRectWithAlphaCheckerboard(draw_list,p_min,p_max,fill_col,grid_step,grid_off,rounding,flags)
end
---@param bb ImRect
---@param item_clip_rect ImRect
---@return nil
function M.RenderDragDropTargetRect(bb,item_clip_rect)
    return lib.igRenderDragDropTargetRect(bb,item_clip_rect)
end
---@param p_min ImVec2
---@param p_max ImVec2
---@param fill_col number ImU32
---@param border boolean?
---@param rounding number? float
---@return nil
function M.RenderFrame(p_min,p_max,fill_col,border,rounding)
    if border == nil then border = true end
    rounding = rounding or 0.0
    return lib.igRenderFrame(p_min,p_max,fill_col,border,rounding)
end
---@param p_min ImVec2
---@param p_max ImVec2
---@param rounding number? float
---@return nil
function M.RenderFrameBorder(p_min,p_max,rounding)
    rounding = rounding or 0.0
    return lib.igRenderFrameBorder(p_min,p_max,rounding)
end
---@param pos ImVec2
---@param scale number float
---@param mouse_cursor MouseCursor
---@param col_fill number ImU32
---@param col_border number ImU32
---@param col_shadow number ImU32
---@return nil
function M.RenderMouseCursor(pos,scale,mouse_cursor,col_fill,col_border,col_shadow)
    return lib.igRenderMouseCursor(pos,scale,mouse_cursor,col_fill,col_border,col_shadow)
end
---@param bb ImRect
---@param id number ImGuiID
---@param flags NavHighlightFlags?
---@return nil
function M.RenderNavHighlight(bb,id,flags)
    flags = flags or 0
    return lib.igRenderNavHighlight(bb,id,flags)
end
---@param platform_render_arg ffi.ct*? void*
---@param renderer_render_arg ffi.ct*? void*
---@return nil
function M.RenderPlatformWindowsDefault(platform_render_arg,renderer_render_arg)
    platform_render_arg = platform_render_arg or nil
    renderer_render_arg = renderer_render_arg or nil
    return lib.igRenderPlatformWindowsDefault(platform_render_arg,renderer_render_arg)
end
---@param draw_list ffi.ct* ImDrawList*
---@param rect ImRect
---@param col number ImU32
---@param x_start_norm number float
---@param x_end_norm number float
---@param rounding number float
---@return nil
function M.RenderRectFilledRangeH(draw_list,rect,col,x_start_norm,x_end_norm,rounding)
    return lib.igRenderRectFilledRangeH(draw_list,rect,col,x_start_norm,x_end_norm,rounding)
end
---@param draw_list ffi.ct* ImDrawList*
---@param outer ImRect
---@param inner ImRect
---@param col number ImU32
---@param rounding number float
---@return nil
function M.RenderRectFilledWithHole(draw_list,outer,inner,col,rounding)
    return lib.igRenderRectFilledWithHole(draw_list,outer,inner,col,rounding)
end
---@param pos ImVec2
---@param text string
---@param text_end string?
---@param hide_text_after_hash boolean?
---@return nil
function M.RenderText(pos,text,text_end,hide_text_after_hash)
    if hide_text_after_hash == nil then hide_text_after_hash = true end
    text_end = text_end or nil
    return lib.igRenderText(pos,text,text_end,hide_text_after_hash)
end
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@param align ImVec2?
---@param clip_rect ffi.ct*? const ImRect*
---@return nil
function M.RenderTextClipped(pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
    align = align or ImVec2(0,0)
    clip_rect = clip_rect or nil
    return lib.igRenderTextClipped(pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@param align ImVec2?
---@param clip_rect ffi.ct*? const ImRect*
---@return nil
function M.RenderTextClippedEx(draw_list,pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
    align = align or ImVec2(0,0)
    clip_rect = clip_rect or nil
    return lib.igRenderTextClippedEx(draw_list,pos_min,pos_max,text,text_end,text_size_if_known,align,clip_rect)
end
---@param draw_list ffi.ct* ImDrawList*
---@param pos_min ImVec2
---@param pos_max ImVec2
---@param clip_max_x number float
---@param ellipsis_max_x number float
---@param text string
---@param text_end string
---@param text_size_if_known ffi.ct* const ImVec2*
---@return nil
function M.RenderTextEllipsis(draw_list,pos_min,pos_max,clip_max_x,ellipsis_max_x,text,text_end,text_size_if_known)
    return lib.igRenderTextEllipsis(draw_list,pos_min,pos_max,clip_max_x,ellipsis_max_x,text,text_end,text_size_if_known)
end
---@param pos ImVec2
---@param text string
---@param text_end string
---@param wrap_width number float
---@return nil
function M.RenderTextWrapped(pos,text,text_end,wrap_width)
    return lib.igRenderTextWrapped(pos,text,text_end,wrap_width)
end
---@param button MouseButton?
---@return nil
function M.ResetMouseDragDelta(button)
    button = button or 0
    return lib.igResetMouseDragDelta(button)
end
---@param offset_from_start_x number? float
---@param spacing number? float
---@return nil
function M.SameLine(offset_from_start_x,spacing)
    offset_from_start_x = offset_from_start_x or 0.0
    spacing = spacing or -1.0
    return lib.igSameLine(offset_from_start_x,spacing)
end
---@param ini_filename string
---@return nil
function M.SaveIniSettingsToDisk(ini_filename)
    return lib.igSaveIniSettingsToDisk(ini_filename)
end
---@param out_ini_size ffi.ct*? size_t*
---@return string
function M.SaveIniSettingsToMemory(out_ini_size)
    out_ini_size = out_ini_size or nil
    return ffi.string(lib.igSaveIniSettingsToMemory(out_ini_size))
end
---@param viewport ffi.ct* ImGuiViewportP*
---@param scale number float
---@return nil
function M.ScaleWindowsInViewport(viewport,scale)
    return lib.igScaleWindowsInViewport(viewport,scale)
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@return nil
function M.ScrollToBringRectIntoView(window,rect)
    return lib.igScrollToBringRectIntoView(window,rect)
end
---@param flags ScrollFlags?
---@return nil
function M.ScrollToItem(flags)
    flags = flags or 0
    return lib.igScrollToItem(flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@param flags ScrollFlags?
---@return nil
function M.ScrollToRect(window,rect,flags)
    flags = flags or 0
    return lib.igScrollToRect(window,rect,flags)
end
---@param window ffi.ct* ImGuiWindow*
---@param rect ImRect
---@param flags ScrollFlags?
---@return nil
function M.ScrollToRectEx(window,rect,flags)
    flags = flags or 0
    local nonUDT_out = ffi.new("ImVec2")
    lib.igScrollToRectEx(nonUDT_out,window,rect,flags)
    return nonUDT_out
end
---@param axis Axis
---@return nil
function M.Scrollbar(axis)
    return lib.igScrollbar(axis)
end
---@param bb ImRect
---@param id number ImGuiID
---@param axis Axis
---@param p_scroll_v ffi.ct* ImS64*
---@param avail_v number ImS64
---@param contents_v number ImS64
---@param flags ImDrawFlags
---@return boolean
function M.ScrollbarEx(bb,id,axis,p_scroll_v,avail_v,contents_v,flags)
    return lib.igScrollbarEx(bb,id,axis,p_scroll_v,avail_v,contents_v,flags)
end
---@param label string
---@param selected boolean?
---@param flags SelectableFlags?
---@param size ImVec2?
---@return boolean
function M.Selectable_Bool(label,selected,flags,size)
    flags = flags or 0
    selected = selected or false
    size = size or ImVec2(0,0)
    return lib.igSelectable_Bool(label,selected,flags,size)
end
---@param label string
---@param p_selected ffi.ct* bool*
---@param flags SelectableFlags?
---@param size ImVec2?
---@return boolean
function M.Selectable_BoolPtr(label,p_selected,flags,size)
    flags = flags or 0
    size = size or ImVec2(0,0)
    return lib.igSelectable_BoolPtr(label,p_selected,flags,size)
end
function M.Selectable(a1,a2,a3,a4) -- generic version
    if ((ffi.istype('bool',a2) or type(a2)=='boolean') or type(a2)=='nil') then return M.Selectable_Bool(a1,a2,a3,a4) end
    if (ffi.istype('bool*',a2) or ffi.istype('bool[]',a2)) then return M.Selectable_BoolPtr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.Selectable could not find overloaded'
end
---@return nil
function M.Separator()
    return lib.igSeparator()
end
---@param flags SeparatorFlags
---@param thickness number? float
---@return nil
function M.SeparatorEx(flags,thickness)
    thickness = thickness or 1.0
    return lib.igSeparatorEx(flags,thickness)
end
---@param label string
---@return nil
function M.SeparatorText(label)
    return lib.igSeparatorText(label)
end
---@param id number ImGuiID
---@param label string
---@param label_end string
---@param extra_width number float
---@return nil
function M.SeparatorTextEx(id,label,label_end,extra_width)
    return lib.igSeparatorTextEx(id,label,label_end,extra_width)
end
---@param id number ImGuiID
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetActiveID(id,window)
    return lib.igSetActiveID(id,window)
end
---@return nil
function M.SetActiveIdUsingAllKeyboardKeys()
    return lib.igSetActiveIdUsingAllKeyboardKeys()
end
---@param alloc_func ffi.ct* ImGuiMemAllocFunc
---@param free_func ffi.ct* ImGuiMemFreeFunc
---@param user_data ffi.ct*? void*
---@return nil
function M.SetAllocatorFunctions(alloc_func,free_func,user_data)
    user_data = user_data or nil
    return lib.igSetAllocatorFunctions(alloc_func,free_func,user_data)
end
---@param text string
---@return nil
function M.SetClipboardText(text)
    return lib.igSetClipboardText(text)
end
---@param flags ColorEditFlags
---@return nil
function M.SetColorEditOptions(flags)
    return lib.igSetColorEditOptions(flags)
end
---@param column_index number int
---@param offset_x number float
---@return nil
function M.SetColumnOffset(column_index,offset_x)
    return lib.igSetColumnOffset(column_index,offset_x)
end
---@param column_index number int
---@param width number float
---@return nil
function M.SetColumnWidth(column_index,width)
    return lib.igSetColumnWidth(column_index,width)
end
---@param ctx ffi.ct* ImGuiContext*
---@return nil
function M.SetCurrentContext(ctx)
    return lib.igSetCurrentContext(ctx)
end
---@param font ffi.ct* ImFont*
---@return nil
function M.SetCurrentFont(font)
    return lib.igSetCurrentFont(font)
end
---@param window ffi.ct* ImGuiWindow*
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.SetCurrentViewport(window,viewport)
    return lib.igSetCurrentViewport(window,viewport)
end
---@param local_pos ImVec2
---@return nil
function M.SetCursorPos(local_pos)
    return lib.igSetCursorPos(local_pos)
end
---@param local_x number float
---@return nil
function M.SetCursorPosX(local_x)
    return lib.igSetCursorPosX(local_x)
end
---@param local_y number float
---@return nil
function M.SetCursorPosY(local_y)
    return lib.igSetCursorPosY(local_y)
end
---@param pos ImVec2
---@return nil
function M.SetCursorScreenPos(pos)
    return lib.igSetCursorScreenPos(pos)
end
---@param type string
---@param data ffi.ct* const void*
---@param sz number size_t
---@param cond Cond?
---@return boolean
function M.SetDragDropPayload(type,data,sz,cond)
    cond = cond or 0
    return lib.igSetDragDropPayload(type,data,sz,cond)
end
---@param id number ImGuiID
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetFocusID(id,window)
    return lib.igSetFocusID(id,window)
end
---@param id number ImGuiID
---@return nil
function M.SetHoveredID(id)
    return lib.igSetHoveredID(id)
end
---@return nil
function M.SetItemDefaultFocus()
    return lib.igSetItemDefaultFocus()
end
---@param key Key
---@param flags InputFlags?
---@return nil
function M.SetItemKeyOwner(key,flags)
    flags = flags or 0
    return lib.igSetItemKeyOwner(key,flags)
end
---@param fmt string
---@return nil
function M.SetItemTooltip(fmt,...)
    return lib.igSetItemTooltip(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.SetItemTooltipV(fmt,args)
    return lib.igSetItemTooltipV(fmt,args)
end
---@param key Key
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return nil
function M.SetKeyOwner(key,owner_id,flags)
    flags = flags or 0
    return lib.igSetKeyOwner(key,owner_id,flags)
end
---@param key number ImGuiKeyChord
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return nil
function M.SetKeyOwnersForKeyChord(key,owner_id,flags)
    flags = flags or 0
    return lib.igSetKeyOwnersForKeyChord(key,owner_id,flags)
end
---@param offset number? int
---@return nil
function M.SetKeyboardFocusHere(offset)
    offset = offset or 0
    return lib.igSetKeyboardFocusHere(offset)
end
---@param item_id number ImGuiID
---@param in_flags ItemFlags
---@param status_flags ItemStatusFlags
---@param item_rect ImRect
---@return nil
function M.SetLastItemData(item_id,in_flags,status_flags,item_rect)
    return lib.igSetLastItemData(item_id,in_flags,status_flags,item_rect)
end
---@param cursor_type MouseCursor
---@return nil
function M.SetMouseCursor(cursor_type)
    return lib.igSetMouseCursor(cursor_type)
end
---@param focus_scope_id number ImGuiID
---@return nil
function M.SetNavFocusScope(focus_scope_id)
    return lib.igSetNavFocusScope(focus_scope_id)
end
---@param id number ImGuiID
---@param nav_layer NavLayer
---@param focus_scope_id number ImGuiID
---@param rect_rel ImRect
---@return nil
function M.SetNavID(id,nav_layer,focus_scope_id,rect_rel)
    return lib.igSetNavID(id,nav_layer,focus_scope_id,rect_rel)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetNavWindow(window)
    return lib.igSetNavWindow(window)
end
---@param want_capture_keyboard boolean
---@return nil
function M.SetNextFrameWantCaptureKeyboard(want_capture_keyboard)
    return lib.igSetNextFrameWantCaptureKeyboard(want_capture_keyboard)
end
---@param want_capture_mouse boolean
---@return nil
function M.SetNextFrameWantCaptureMouse(want_capture_mouse)
    return lib.igSetNextFrameWantCaptureMouse(want_capture_mouse)
end
---@return nil
function M.SetNextItemAllowOverlap()
    return lib.igSetNextItemAllowOverlap()
end
---@param is_open boolean
---@param cond Cond?
---@return nil
function M.SetNextItemOpen(is_open,cond)
    cond = cond or 0
    return lib.igSetNextItemOpen(is_open,cond)
end
---@param selection_user_data number ImGuiSelectionUserData
---@return nil
function M.SetNextItemSelectionUserData(selection_user_data)
    return lib.igSetNextItemSelectionUserData(selection_user_data)
end
---@param key_chord number ImGuiKeyChord
---@return nil
function M.SetNextItemShortcut(key_chord)
    return lib.igSetNextItemShortcut(key_chord)
end
---@param item_width number float
---@return nil
function M.SetNextItemWidth(item_width)
    return lib.igSetNextItemWidth(item_width)
end
---@param alpha number float
---@return nil
function M.SetNextWindowBgAlpha(alpha)
    return lib.igSetNextWindowBgAlpha(alpha)
end
---@param window_class ffi.ct* const ImGuiWindowClass*
---@return nil
function M.SetNextWindowClass(window_class)
    return lib.igSetNextWindowClass(window_class)
end
---@param collapsed boolean
---@param cond Cond?
---@return nil
function M.SetNextWindowCollapsed(collapsed,cond)
    cond = cond or 0
    return lib.igSetNextWindowCollapsed(collapsed,cond)
end
---@param size ImVec2
---@return nil
function M.SetNextWindowContentSize(size)
    return lib.igSetNextWindowContentSize(size)
end
---@param dock_id number ImGuiID
---@param cond Cond?
---@return nil
function M.SetNextWindowDockID(dock_id,cond)
    cond = cond or 0
    return lib.igSetNextWindowDockID(dock_id,cond)
end
---@return nil
function M.SetNextWindowFocus()
    return lib.igSetNextWindowFocus()
end
---@param pos ImVec2
---@param cond Cond?
---@param pivot ImVec2?
---@return nil
function M.SetNextWindowPos(pos,cond,pivot)
    cond = cond or 0
    pivot = pivot or ImVec2(0,0)
    return lib.igSetNextWindowPos(pos,cond,pivot)
end
---@param scroll ImVec2
---@return nil
function M.SetNextWindowScroll(scroll)
    return lib.igSetNextWindowScroll(scroll)
end
---@param size ImVec2
---@param cond Cond?
---@return nil
function M.SetNextWindowSize(size,cond)
    cond = cond or 0
    return lib.igSetNextWindowSize(size,cond)
end
---@param size_min ImVec2
---@param size_max ImVec2
---@param custom_callback ffi.ct*? ImGuiSizeCallback
---@param custom_callback_data ffi.ct*? void*
---@return nil
function M.SetNextWindowSizeConstraints(size_min,size_max,custom_callback,custom_callback_data)
    custom_callback = custom_callback or nil
    custom_callback_data = custom_callback_data or nil
    return lib.igSetNextWindowSizeConstraints(size_min,size_max,custom_callback,custom_callback_data)
end
---@param viewport_id number ImGuiID
---@return nil
function M.SetNextWindowViewport(viewport_id)
    return lib.igSetNextWindowViewport(viewport_id)
end
---@param local_x number float
---@param center_x_ratio number? float
---@return nil
function M.SetScrollFromPosX_Float(local_x,center_x_ratio)
    center_x_ratio = center_x_ratio or 0.5
    return lib.igSetScrollFromPosX_Float(local_x,center_x_ratio)
end
---@param window ffi.ct* ImGuiWindow*
---@param local_x number float
---@param center_x_ratio number float
---@return nil
function M.SetScrollFromPosX_WindowPtr(window,local_x,center_x_ratio)
    return lib.igSetScrollFromPosX_WindowPtr(window,local_x,center_x_ratio)
end
function M.SetScrollFromPosX(a1,a2,a3) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollFromPosX_Float(a1,a2) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollFromPosX_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetScrollFromPosX could not find overloaded'
end
---@param local_y number float
---@param center_y_ratio number? float
---@return nil
function M.SetScrollFromPosY_Float(local_y,center_y_ratio)
    center_y_ratio = center_y_ratio or 0.5
    return lib.igSetScrollFromPosY_Float(local_y,center_y_ratio)
end
---@param window ffi.ct* ImGuiWindow*
---@param local_y number float
---@param center_y_ratio number float
---@return nil
function M.SetScrollFromPosY_WindowPtr(window,local_y,center_y_ratio)
    return lib.igSetScrollFromPosY_WindowPtr(window,local_y,center_y_ratio)
end
function M.SetScrollFromPosY(a1,a2,a3) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollFromPosY_Float(a1,a2) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollFromPosY_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetScrollFromPosY could not find overloaded'
end
---@param center_x_ratio number? float
---@return nil
function M.SetScrollHereX(center_x_ratio)
    center_x_ratio = center_x_ratio or 0.5
    return lib.igSetScrollHereX(center_x_ratio)
end
---@param center_y_ratio number? float
---@return nil
function M.SetScrollHereY(center_y_ratio)
    center_y_ratio = center_y_ratio or 0.5
    return lib.igSetScrollHereY(center_y_ratio)
end
---@param scroll_x number float
---@return nil
function M.SetScrollX_Float(scroll_x)
    return lib.igSetScrollX_Float(scroll_x)
end
---@param window ffi.ct* ImGuiWindow*
---@param scroll_x number float
---@return nil
function M.SetScrollX_WindowPtr(window,scroll_x)
    return lib.igSetScrollX_WindowPtr(window,scroll_x)
end
function M.SetScrollX(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollX_Float(a1) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollX_WindowPtr(a1,a2) end
    print(a1,a2)
    error'M.SetScrollX could not find overloaded'
end
---@param scroll_y number float
---@return nil
function M.SetScrollY_Float(scroll_y)
    return lib.igSetScrollY_Float(scroll_y)
end
---@param window ffi.ct* ImGuiWindow*
---@param scroll_y number float
---@return nil
function M.SetScrollY_WindowPtr(window,scroll_y)
    return lib.igSetScrollY_WindowPtr(window,scroll_y)
end
function M.SetScrollY(a1,a2) -- generic version
    if (ffi.istype('float',a1) or type(a1)=='number') then return M.SetScrollY_Float(a1) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetScrollY_WindowPtr(a1,a2) end
    print(a1,a2)
    error'M.SetScrollY could not find overloaded'
end
---@param key_chord number ImGuiKeyChord
---@param owner_id number ImGuiID
---@param flags InputFlags?
---@return boolean
function M.SetShortcutRouting(key_chord,owner_id,flags)
    flags = flags or 0
    return lib.igSetShortcutRouting(key_chord,owner_id,flags)
end
---@param storage ffi.ct* ImGuiStorage*
---@return nil
function M.SetStateStorage(storage)
    return lib.igSetStateStorage(storage)
end
---@param tab_or_docked_window_label string
---@return nil
function M.SetTabItemClosed(tab_or_docked_window_label)
    return lib.igSetTabItemClosed(tab_or_docked_window_label)
end
---@param fmt string
---@return nil
function M.SetTooltip(fmt,...)
    return lib.igSetTooltip(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.SetTooltipV(fmt,args)
    return lib.igSetTooltipV(fmt,args)
end
---@param window ffi.ct* ImGuiWindow*
---@param clip_rect ImRect
---@return nil
function M.SetWindowClipRectBeforeSetChannel(window,clip_rect)
    return lib.igSetWindowClipRectBeforeSetChannel(window,clip_rect)
end
---@param collapsed boolean
---@param cond Cond?
---@return nil
function M.SetWindowCollapsed_Bool(collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_Bool(collapsed,cond)
end
---@param name string
---@param collapsed boolean
---@param cond Cond?
---@return nil
function M.SetWindowCollapsed_Str(name,collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_Str(name,collapsed,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param collapsed boolean
---@param cond Cond?
---@return nil
function M.SetWindowCollapsed_WindowPtr(window,collapsed,cond)
    cond = cond or 0
    return lib.igSetWindowCollapsed_WindowPtr(window,collapsed,cond)
end
function M.SetWindowCollapsed(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a1) or type(a1)=='boolean') then return M.SetWindowCollapsed_Bool(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowCollapsed_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowCollapsed_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowCollapsed could not find overloaded'
end
---@param window ffi.ct* ImGuiWindow*
---@param dock_id number ImGuiID
---@param cond Cond
---@return nil
function M.SetWindowDock(window,dock_id,cond)
    return lib.igSetWindowDock(window,dock_id,cond)
end
---@return nil
function M.SetWindowFocus_Nil()
    return lib.igSetWindowFocus_Nil()
end
---@param name string
---@return nil
function M.SetWindowFocus_Str(name)
    return lib.igSetWindowFocus_Str(name)
end
function M.SetWindowFocus(a1) -- generic version
    if a1==nil then return M.SetWindowFocus_Nil() end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowFocus_Str(a1) end
    print(a1)
    error'M.SetWindowFocus could not find overloaded'
end
---@param scale number float
---@return nil
function M.SetWindowFontScale(scale)
    return lib.igSetWindowFontScale(scale)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.SetWindowHiddenAndSkipItemsForCurrentFrame(window)
    return lib.igSetWindowHiddenAndSkipItemsForCurrentFrame(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param pos ImVec2
---@param size ImVec2
---@return nil
function M.SetWindowHitTestHole(window,pos,size)
    return lib.igSetWindowHitTestHole(window,pos,size)
end
---@param window ffi.ct* ImGuiWindow*
---@param parent_window ffi.ct* ImGuiWindow*
---@return nil
function M.SetWindowParentWindowForFocusRoute(window,parent_window)
    return lib.igSetWindowParentWindowForFocusRoute(window,parent_window)
end
---@param pos ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowPos_Vec2(pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_Vec2(pos,cond)
end
---@param name string
---@param pos ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowPos_Str(name,pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_Str(name,pos,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param pos ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowPos_WindowPtr(window,pos,cond)
    cond = cond or 0
    return lib.igSetWindowPos_WindowPtr(window,pos,cond)
end
function M.SetWindowPos(a1,a2,a3) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.SetWindowPos_Vec2(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowPos_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowPos_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowPos could not find overloaded'
end
---@param size ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowSize_Vec2(size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_Vec2(size,cond)
end
---@param name string
---@param size ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowSize_Str(name,size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_Str(name,size,cond)
end
---@param window ffi.ct* ImGuiWindow*
---@param size ImVec2
---@param cond Cond?
---@return nil
function M.SetWindowSize_WindowPtr(window,size,cond)
    cond = cond or 0
    return lib.igSetWindowSize_WindowPtr(window,size,cond)
end
function M.SetWindowSize(a1,a2,a3) -- generic version
    if ffi.istype('const ImVec2',a1) then return M.SetWindowSize_Vec2(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.SetWindowSize_Str(a1,a2,a3) end
    if (ffi.istype('ImGuiWindow*',a1) or ffi.istype('ImGuiWindow',a1) or ffi.istype('ImGuiWindow[]',a1)) then return M.SetWindowSize_WindowPtr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.SetWindowSize could not find overloaded'
end
---@param window ffi.ct* ImGuiWindow*
---@param viewport ffi.ct* ImGuiViewportP*
---@return nil
function M.SetWindowViewport(window,viewport)
    return lib.igSetWindowViewport(window,viewport)
end
---@param draw_list ffi.ct* ImDrawList*
---@param vert_start_idx number int
---@param vert_end_idx number int
---@param gradient_p0 ImVec2
---@param gradient_p1 ImVec2
---@param col0 number ImU32
---@param col1 number ImU32
---@return nil
function M.ShadeVertsLinearColorGradientKeepAlpha(draw_list,vert_start_idx,vert_end_idx,gradient_p0,gradient_p1,col0,col1)
    return lib.igShadeVertsLinearColorGradientKeepAlpha(draw_list,vert_start_idx,vert_end_idx,gradient_p0,gradient_p1,col0,col1)
end
---@param draw_list ffi.ct* ImDrawList*
---@param vert_start_idx number int
---@param vert_end_idx number int
---@param a ImVec2
---@param b ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param clamp boolean
---@return nil
function M.ShadeVertsLinearUV(draw_list,vert_start_idx,vert_end_idx,a,b,uv_a,uv_b,clamp)
    return lib.igShadeVertsLinearUV(draw_list,vert_start_idx,vert_end_idx,a,b,uv_a,uv_b,clamp)
end
---@param draw_list ffi.ct* ImDrawList*
---@param vert_start_idx number int
---@param vert_end_idx number int
---@param pivot_in ImVec2
---@param cos_a number float
---@param sin_a number float
---@param pivot_out ImVec2
---@return nil
function M.ShadeVertsTransformPos(draw_list,vert_start_idx,vert_end_idx,pivot_in,cos_a,sin_a,pivot_out)
    return lib.igShadeVertsTransformPos(draw_list,vert_start_idx,vert_end_idx,pivot_in,cos_a,sin_a,pivot_out)
end
---@param key_chord number ImGuiKeyChord
---@param owner_id number? ImGuiID
---@param flags InputFlags?
---@return boolean
function M.Shortcut(key_chord,owner_id,flags)
    flags = flags or 0
    owner_id = owner_id or 0
    return lib.igShortcut(key_chord,owner_id,flags)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowAboutWindow(p_open)
    p_open = p_open or nil
    return lib.igShowAboutWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowDebugLogWindow(p_open)
    p_open = p_open or nil
    return lib.igShowDebugLogWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowDemoWindow(p_open)
    p_open = p_open or nil
    return lib.igShowDemoWindow(p_open)
end
---@param atlas ffi.ct* ImFontAtlas*
---@return nil
function M.ShowFontAtlas(atlas)
    return lib.igShowFontAtlas(atlas)
end
---@param label string
---@return nil
function M.ShowFontSelector(label)
    return lib.igShowFontSelector(label)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowIDStackToolWindow(p_open)
    p_open = p_open or nil
    return lib.igShowIDStackToolWindow(p_open)
end
---@param p_open ffi.ct*? bool*
---@return nil
function M.ShowMetricsWindow(p_open)
    p_open = p_open or nil
    return lib.igShowMetricsWindow(p_open)
end
---@param ref ffi.ct*? ImGuiStyle*
---@return nil
function M.ShowStyleEditor(ref)
    ref = ref or nil
    return lib.igShowStyleEditor(ref)
end
---@param label string
---@return boolean
function M.ShowStyleSelector(label)
    return lib.igShowStyleSelector(label)
end
---@return nil
function M.ShowUserGuide()
    return lib.igShowUserGuide()
end
---@param items ffi.ct* ImGuiShrinkWidthItem*
---@param count number int
---@param width_excess number float
---@return nil
function M.ShrinkWidths(items,count,width_excess)
    return lib.igShrinkWidths(items,count,width_excess)
end
---@return nil
function M.Shutdown()
    return lib.igShutdown()
end
---@param label string
---@param v_rad ffi.ct* float*
---@param v_degrees_min number? float
---@param v_degrees_max number? float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderAngle(label,v_rad,v_degrees_min,v_degrees_max,format,flags)
    flags = flags or 0
    format = format or "%.0f deg"
    v_degrees_max = v_degrees_max or 360.0
    v_degrees_min = v_degrees_min or -360.0
    return lib.igSliderAngle(label,v_rad,v_degrees_min,v_degrees_max,format,flags)
end
---@param bb ImRect
---@param id number ImGuiID
---@param data_type DataType
---@param p_v ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string
---@param flags SliderFlags
---@param out_grab_bb ffi.ct* ImRect*
---@return boolean
function M.SliderBehavior(bb,id,data_type,p_v,p_min,p_max,format,flags,out_grab_bb)
    return lib.igSliderBehavior(bb,id,data_type,p_v,p_min,p_max,format,flags,out_grab_bb)
end
---@param label string
---@param v ffi.ct* float*
---@param v_min number float
---@param v_max number float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderFloat(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[2]
---@param v_min number float
---@param v_max number float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderFloat2(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat2(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[3]
---@param v_min number float
---@param v_max number float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderFloat3(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat3(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* float[4]
---@param v_min number float
---@param v_max number float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderFloat4(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igSliderFloat4(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int*
---@param v_min number int
---@param v_max number int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderInt(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[2]
---@param v_min number int
---@param v_max number int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderInt2(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt2(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[3]
---@param v_min number int
---@param v_max number int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderInt3(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt3(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param v ffi.ct* int[4]
---@param v_min number int
---@param v_max number int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderInt4(label,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igSliderInt4(label,v,v_min,v_max,format,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderScalar(label,data_type,p_data,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igSliderScalar(label,data_type,p_data,p_min,p_max,format,flags)
end
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param components number int
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.SliderScalarN(label,data_type,p_data,components,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igSliderScalarN(label,data_type,p_data,components,p_min,p_max,format,flags)
end
---@param label string
---@return boolean
function M.SmallButton(label)
    return lib.igSmallButton(label)
end
---@return nil
function M.Spacing()
    return lib.igSpacing()
end
---@param bb ImRect
---@param id number ImGuiID
---@param axis Axis
---@param size1 ffi.ct* float*
---@param size2 ffi.ct* float*
---@param min_size1 number float
---@param min_size2 number float
---@param hover_extend number? float
---@param hover_visibility_delay number? float
---@param bg_col number? ImU32
---@return boolean
function M.SplitterBehavior(bb,id,axis,size1,size2,min_size1,min_size2,hover_extend,hover_visibility_delay,bg_col)
    bg_col = bg_col or 0
    hover_extend = hover_extend or 0.0
    hover_visibility_delay = hover_visibility_delay or 0.0
    return lib.igSplitterBehavior(bb,id,axis,size1,size2,min_size1,min_size2,hover_extend,hover_visibility_delay,bg_col)
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.StartMouseMovingWindow(window)
    return lib.igStartMouseMovingWindow(window)
end
---@param window ffi.ct* ImGuiWindow*
---@param node ffi.ct* ImGuiDockNode*
---@param undock boolean
---@return nil
function M.StartMouseMovingWindowOrNode(window,node,undock)
    return lib.igStartMouseMovingWindowOrNode(window,node,undock)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsClassic(dst)
    dst = dst or nil
    return lib.igStyleColorsClassic(dst)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsDark(dst)
    dst = dst or nil
    return lib.igStyleColorsDark(dst)
end
---@param dst ffi.ct*? ImGuiStyle*
---@return nil
function M.StyleColorsLight(dst)
    dst = dst or nil
    return lib.igStyleColorsLight(dst)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab_flags TabItemFlags
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.TabBarAddTab(tab_bar,tab_flags,window)
    return lib.igTabBarAddTab(tab_bar,tab_flags,window)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return nil
function M.TabBarCloseTab(tab_bar,tab)
    return lib.igTabBarCloseTab(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return ffi.ct* ImGuiTabItem*
function M.TabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar)
    return lib.igTabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab_id number ImGuiID
---@return ffi.ct* ImGuiTabItem*
function M.TabBarFindTabByID(tab_bar,tab_id)
    return lib.igTabBarFindTabByID(tab_bar,tab_id)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param order number int
---@return ffi.ct* ImGuiTabItem*
function M.TabBarFindTabByOrder(tab_bar,order)
    return lib.igTabBarFindTabByOrder(tab_bar,order)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return ffi.ct* ImGuiTabItem*
function M.TabBarGetCurrentTab(tab_bar)
    return lib.igTabBarGetCurrentTab(tab_bar)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return string
function M.TabBarGetTabName(tab_bar,tab)
    return ffi.string(lib.igTabBarGetTabName(tab_bar,tab))
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return number int
function M.TabBarGetTabOrder(tab_bar,tab)
    return lib.igTabBarGetTabOrder(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@return boolean
function M.TabBarProcessReorder(tab_bar)
    return lib.igTabBarProcessReorder(tab_bar)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@return nil
function M.TabBarQueueFocus(tab_bar,tab)
    return lib.igTabBarQueueFocus(tab_bar,tab)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@param offset number int
---@return nil
function M.TabBarQueueReorder(tab_bar,tab,offset)
    return lib.igTabBarQueueReorder(tab_bar,tab,offset)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab ffi.ct* ImGuiTabItem*
---@param mouse_pos ImVec2
---@return nil
function M.TabBarQueueReorderFromMousePos(tab_bar,tab,mouse_pos)
    return lib.igTabBarQueueReorderFromMousePos(tab_bar,tab,mouse_pos)
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param tab_id number ImGuiID
---@return nil
function M.TabBarRemoveTab(tab_bar,tab_id)
    return lib.igTabBarRemoveTab(tab_bar,tab_id)
end
---@param draw_list ffi.ct* ImDrawList*
---@param bb ImRect
---@param flags TabItemFlags
---@param col number ImU32
---@return nil
function M.TabItemBackground(draw_list,bb,flags,col)
    return lib.igTabItemBackground(draw_list,bb,flags,col)
end
---@param label string
---@param flags TabItemFlags?
---@return boolean
function M.TabItemButton(label,flags)
    flags = flags or 0
    return lib.igTabItemButton(label,flags)
end
---@param label string
---@param has_close_button_or_unsaved_marker boolean
---@return nil
function M.TabItemCalcSize_Str(label,has_close_button_or_unsaved_marker)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igTabItemCalcSize_Str(nonUDT_out,label,has_close_button_or_unsaved_marker)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@return nil
function M.TabItemCalcSize_WindowPtr(window)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igTabItemCalcSize_WindowPtr(nonUDT_out,window)
    return nonUDT_out
end
function M.TabItemCalcSize(a2,a3) -- generic version
    if (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.TabItemCalcSize_Str(a2,a3) end
    if (ffi.istype('ImGuiWindow*',a2) or ffi.istype('ImGuiWindow',a2) or ffi.istype('ImGuiWindow[]',a2)) then return M.TabItemCalcSize_WindowPtr(a2) end
    print(a2,a3)
    error'M.TabItemCalcSize could not find overloaded'
end
---@param tab_bar ffi.ct* ImGuiTabBar*
---@param label string
---@param p_open ffi.ct* bool*
---@param flags TabItemFlags
---@param docked_window ffi.ct* ImGuiWindow*
---@return boolean
function M.TabItemEx(tab_bar,label,p_open,flags,docked_window)
    return lib.igTabItemEx(tab_bar,label,p_open,flags,docked_window)
end
---@param draw_list ffi.ct* ImDrawList*
---@param bb ImRect
---@param flags TabItemFlags
---@param frame_padding ImVec2
---@param label string
---@param tab_id number ImGuiID
---@param close_button_id number ImGuiID
---@param is_contents_visible boolean
---@param out_just_closed ffi.ct* bool*
---@param out_text_clipped ffi.ct* bool*
---@return nil
function M.TabItemLabelAndCloseButton(draw_list,bb,flags,frame_padding,label,tab_id,close_button_id,is_contents_visible,out_just_closed,out_text_clipped)
    return lib.igTabItemLabelAndCloseButton(draw_list,bb,flags,frame_padding,label,tab_id,close_button_id,is_contents_visible,out_just_closed,out_text_clipped)
end
---@return nil
function M.TableAngledHeadersRow()
    return lib.igTableAngledHeadersRow()
end
---@param angle number float
---@param max_label_width number? float
---@return nil
function M.TableAngledHeadersRowEx(angle,max_label_width)
    max_label_width = max_label_width or 0.0
    return lib.igTableAngledHeadersRowEx(angle,max_label_width)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableBeginApplyRequests(table)
    return lib.igTableBeginApplyRequests(table)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number int
---@return nil
function M.TableBeginCell(table,column_n)
    return lib.igTableBeginCell(table,column_n)
end
---@param table ffi.ct* ImGuiTable*
---@return boolean
function M.TableBeginContextMenuPopup(table)
    return lib.igTableBeginContextMenuPopup(table)
end
---@param table ffi.ct* ImGuiTable*
---@param columns_count number int
---@return nil
function M.TableBeginInitMemory(table,columns_count)
    return lib.igTableBeginInitMemory(table,columns_count)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableBeginRow(table)
    return lib.igTableBeginRow(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableDrawBorders(table)
    return lib.igTableDrawBorders(table)
end
---@param table ffi.ct* ImGuiTable*
---@param flags_for_section_to_display TableFlags
---@return nil
function M.TableDrawDefaultContextMenu(table,flags_for_section_to_display)
    return lib.igTableDrawDefaultContextMenu(table,flags_for_section_to_display)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableEndCell(table)
    return lib.igTableEndCell(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableEndRow(table)
    return lib.igTableEndRow(table)
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiTable*
function M.TableFindByID(id)
    return lib.igTableFindByID(id)
end
---@param table ffi.ct* ImGuiTable*
---@param column ffi.ct* ImGuiTableColumn*
---@return nil
function M.TableFixColumnSortDirection(table,column)
    return lib.igTableFixColumnSortDirection(table,column)
end
---@return nil
function M.TableGcCompactSettings()
    return lib.igTableGcCompactSettings()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableGcCompactTransientBuffers_TablePtr(table)
    return lib.igTableGcCompactTransientBuffers_TablePtr(table)
end
---@param table ffi.ct* ImGuiTableTempData*
---@return nil
function M.TableGcCompactTransientBuffers_TableTempDataPtr(table)
    return lib.igTableGcCompactTransientBuffers_TableTempDataPtr(table)
end
function M.TableGcCompactTransientBuffers(a1) -- generic version
    if (ffi.istype('ImGuiTable*',a1) or ffi.istype('ImGuiTable',a1) or ffi.istype('ImGuiTable[]',a1)) then return M.TableGcCompactTransientBuffers_TablePtr(a1) end
    if (ffi.istype('ImGuiTableTempData*',a1) or ffi.istype('ImGuiTableTempData',a1) or ffi.istype('ImGuiTableTempData[]',a1)) then return M.TableGcCompactTransientBuffers_TableTempDataPtr(a1) end
    print(a1)
    error'M.TableGcCompactTransientBuffers could not find overloaded'
end
---@param table ffi.ct* ImGuiTable*
---@return ffi.ct* ImGuiTableSettings*
function M.TableGetBoundSettings(table)
    return lib.igTableGetBoundSettings(table)
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number int
---@return nil
function M.TableGetCellBgRect(table,column_n)
    local nonUDT_out = ffi.new("ImRect")
    lib.igTableGetCellBgRect(nonUDT_out,table,column_n)
    return nonUDT_out
end
---@return number int
function M.TableGetColumnCount()
    return lib.igTableGetColumnCount()
end
---@param column_n number? int
---@return TableColumnFlags
function M.TableGetColumnFlags(column_n)
    column_n = column_n or -1
    return lib.igTableGetColumnFlags(column_n)
end
---@return number int
function M.TableGetColumnIndex()
    return lib.igTableGetColumnIndex()
end
---@param column_n number? int
---@return string
function M.TableGetColumnName_Int(column_n)
    column_n = column_n or -1
    return ffi.string(lib.igTableGetColumnName_Int(column_n))
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number int
---@return string
function M.TableGetColumnName_TablePtr(table,column_n)
    return ffi.string(lib.igTableGetColumnName_TablePtr(table,column_n))
end
function M.TableGetColumnName(a1,a2) -- generic version
    if ((ffi.istype('int32_t',a1) or type(a1)=='number') or type(a1)=='nil') then return M.TableGetColumnName_Int(a1) end
    if (ffi.istype('const ImGuiTable*',a1) or ffi.istype('const ImGuiTable',a1) or ffi.istype('const ImGuiTable[]',a1)) then return M.TableGetColumnName_TablePtr(a1,a2) end
    print(a1,a2)
    error'M.TableGetColumnName could not find overloaded'
end
---@param column ffi.ct* ImGuiTableColumn*
---@return SortDirection
function M.TableGetColumnNextSortDirection(column)
    return lib.igTableGetColumnNextSortDirection(column)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number int
---@param instance_no number? int
---@return number ImGuiID
function M.TableGetColumnResizeID(table,column_n,instance_no)
    instance_no = instance_no or 0
    return lib.igTableGetColumnResizeID(table,column_n,instance_no)
end
---@param table ffi.ct* ImGuiTable*
---@param column ffi.ct* ImGuiTableColumn*
---@return number float
function M.TableGetColumnWidthAuto(table,column)
    return lib.igTableGetColumnWidthAuto(table,column)
end
---@return number float
function M.TableGetHeaderAngledMaxLabelWidth()
    return lib.igTableGetHeaderAngledMaxLabelWidth()
end
---@return number float
function M.TableGetHeaderRowHeight()
    return lib.igTableGetHeaderRowHeight()
end
---@return number int
function M.TableGetHoveredColumn()
    return lib.igTableGetHoveredColumn()
end
---@return number int
function M.TableGetHoveredRow()
    return lib.igTableGetHoveredRow()
end
---@param table ffi.ct* ImGuiTable*
---@param instance_no number int
---@return ffi.ct* ImGuiTableInstanceData*
function M.TableGetInstanceData(table,instance_no)
    return lib.igTableGetInstanceData(table,instance_no)
end
---@param table ffi.ct* ImGuiTable*
---@param instance_no number int
---@return number ImGuiID
function M.TableGetInstanceID(table,instance_no)
    return lib.igTableGetInstanceID(table,instance_no)
end
---@param table ffi.ct* const ImGuiTable*
---@param column_n number int
---@return number float
function M.TableGetMaxColumnWidth(table,column_n)
    return lib.igTableGetMaxColumnWidth(table,column_n)
end
---@return number int
function M.TableGetRowIndex()
    return lib.igTableGetRowIndex()
end
---@return ffi.ct* ImGuiTableSortSpecs*
function M.TableGetSortSpecs()
    return lib.igTableGetSortSpecs()
end
---@param label string
---@return nil
function M.TableHeader(label)
    return lib.igTableHeader(label)
end
---@return nil
function M.TableHeadersRow()
    return lib.igTableHeadersRow()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableLoadSettings(table)
    return lib.igTableLoadSettings(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableMergeDrawChannels(table)
    return lib.igTableMergeDrawChannels(table)
end
---@return boolean
function M.TableNextColumn()
    return lib.igTableNextColumn()
end
---@param row_flags TableRowFlags?
---@param min_row_height number? float
---@return nil
function M.TableNextRow(row_flags,min_row_height)
    min_row_height = min_row_height or 0.0
    row_flags = row_flags or 0
    return lib.igTableNextRow(row_flags,min_row_height)
end
---@param column_n number? int
---@return nil
function M.TableOpenContextMenu(column_n)
    column_n = column_n or -1
    return lib.igTableOpenContextMenu(column_n)
end
---@return nil
function M.TablePopBackgroundChannel()
    return lib.igTablePopBackgroundChannel()
end
---@return nil
function M.TablePushBackgroundChannel()
    return lib.igTablePushBackgroundChannel()
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableRemove(table)
    return lib.igTableRemove(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableResetSettings(table)
    return lib.igTableResetSettings(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSaveSettings(table)
    return lib.igTableSaveSettings(table)
end
---@param target TableBgTarget
---@param color number ImU32
---@param column_n number? int
---@return nil
function M.TableSetBgColor(target,color,column_n)
    column_n = column_n or -1
    return lib.igTableSetBgColor(target,color,column_n)
end
---@param column_n number int
---@param v boolean
---@return nil
function M.TableSetColumnEnabled(column_n,v)
    return lib.igTableSetColumnEnabled(column_n,v)
end
---@param column_n number int
---@return boolean
function M.TableSetColumnIndex(column_n)
    return lib.igTableSetColumnIndex(column_n)
end
---@param column_n number int
---@param sort_direction SortDirection
---@param append_to_sort_specs boolean
---@return nil
function M.TableSetColumnSortDirection(column_n,sort_direction,append_to_sort_specs)
    return lib.igTableSetColumnSortDirection(column_n,sort_direction,append_to_sort_specs)
end
---@param column_n number int
---@param width number float
---@return nil
function M.TableSetColumnWidth(column_n,width)
    return lib.igTableSetColumnWidth(column_n,width)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSetColumnWidthAutoAll(table)
    return lib.igTableSetColumnWidthAutoAll(table)
end
---@param table ffi.ct* ImGuiTable*
---@param column_n number int
---@return nil
function M.TableSetColumnWidthAutoSingle(table,column_n)
    return lib.igTableSetColumnWidthAutoSingle(table,column_n)
end
---@return nil
function M.TableSettingsAddSettingsHandler()
    return lib.igTableSettingsAddSettingsHandler()
end
---@param id number ImGuiID
---@param columns_count number int
---@return ffi.ct* ImGuiTableSettings*
function M.TableSettingsCreate(id,columns_count)
    return lib.igTableSettingsCreate(id,columns_count)
end
---@param id number ImGuiID
---@return ffi.ct* ImGuiTableSettings*
function M.TableSettingsFindByID(id)
    return lib.igTableSettingsFindByID(id)
end
---@param label string
---@param flags TableColumnFlags?
---@param init_width_or_weight number? float
---@param user_id number? ImGuiID
---@return nil
function M.TableSetupColumn(label,flags,init_width_or_weight,user_id)
    flags = flags or 0
    init_width_or_weight = init_width_or_weight or 0.0
    user_id = user_id or 0
    return lib.igTableSetupColumn(label,flags,init_width_or_weight,user_id)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSetupDrawChannels(table)
    return lib.igTableSetupDrawChannels(table)
end
---@param cols number int
---@param rows number int
---@return nil
function M.TableSetupScrollFreeze(cols,rows)
    return lib.igTableSetupScrollFreeze(cols,rows)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSortSpecsBuild(table)
    return lib.igTableSortSpecsBuild(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableSortSpecsSanitize(table)
    return lib.igTableSortSpecsSanitize(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateBorders(table)
    return lib.igTableUpdateBorders(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateColumnsWeightFromWidth(table)
    return lib.igTableUpdateColumnsWeightFromWidth(table)
end
---@param table ffi.ct* ImGuiTable*
---@return nil
function M.TableUpdateLayout(table)
    return lib.igTableUpdateLayout(table)
end
---@param pos ImVec2
---@return nil
function M.TeleportMousePos(pos)
    return lib.igTeleportMousePos(pos)
end
---@param id number ImGuiID
---@return boolean
function M.TempInputIsActive(id)
    return lib.igTempInputIsActive(id)
end
---@param bb ImRect
---@param id number ImGuiID
---@param label string
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param format string
---@param p_clamp_min ffi.ct*? const void*
---@param p_clamp_max ffi.ct*? const void*
---@return boolean
function M.TempInputScalar(bb,id,label,data_type,p_data,format,p_clamp_min,p_clamp_max)
    p_clamp_max = p_clamp_max or nil
    p_clamp_min = p_clamp_min or nil
    return lib.igTempInputScalar(bb,id,label,data_type,p_data,format,p_clamp_min,p_clamp_max)
end
---@param bb ImRect
---@param id number ImGuiID
---@param label string
---@param buf ffi.ct* char*
---@param buf_size number int
---@param flags InputTextFlags
---@return boolean
function M.TempInputText(bb,id,label,buf,buf_size,flags)
    return lib.igTempInputText(bb,id,label,buf,buf_size,flags)
end
---@param key Key
---@param owner_id number ImGuiID
---@return boolean
function M.TestKeyOwner(key,owner_id)
    return lib.igTestKeyOwner(key,owner_id)
end
---@param key_chord number ImGuiKeyChord
---@param owner_id number ImGuiID
---@return boolean
function M.TestShortcutRouting(key_chord,owner_id)
    return lib.igTestShortcutRouting(key_chord,owner_id)
end
---@param fmt string
---@return nil
function M.Text(fmt,...)
    return lib.igText(fmt,...)
end
---@param col ffi.ct* const ImVec4
---@param fmt string
---@return nil
function M.TextColored(col,fmt,...)
    return lib.igTextColored(col,fmt,...)
end
---@param col ffi.ct* const ImVec4
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextColoredV(col,fmt,args)
    return lib.igTextColoredV(col,fmt,args)
end
---@param fmt string
---@return nil
function M.TextDisabled(fmt,...)
    return lib.igTextDisabled(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextDisabledV(fmt,args)
    return lib.igTextDisabledV(fmt,args)
end
---@param text string
---@param text_end string?
---@param flags TextFlags?
---@return nil
function M.TextEx(text,text_end,flags)
    flags = flags or 0
    text_end = text_end or nil
    return lib.igTextEx(text,text_end,flags)
end
---@param text string
---@param text_end string?
---@return nil
function M.TextUnformatted(text,text_end)
    text_end = text_end or nil
    return lib.igTextUnformatted(text,text_end)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextV(fmt,args)
    return lib.igTextV(fmt,args)
end
---@param fmt string
---@return nil
function M.TextWrapped(fmt,...)
    return lib.igTextWrapped(fmt,...)
end
---@param fmt string
---@param args ffi.ct* va_list
---@return nil
function M.TextWrappedV(fmt,args)
    return lib.igTextWrappedV(fmt,args)
end
---@param viewport ffi.ct* ImGuiViewportP*
---@param old_pos ImVec2
---@param new_pos ImVec2
---@return nil
function M.TranslateWindowsInViewport(viewport,old_pos,new_pos)
    return lib.igTranslateWindowsInViewport(viewport,old_pos,new_pos)
end
---@param label string
---@return boolean
function M.TreeNode_Str(label)
    return lib.igTreeNode_Str(label)
end
---@param str_id string
---@param fmt string
---@return boolean
function M.TreeNode_StrStr(str_id,fmt,...)
    return lib.igTreeNode_StrStr(str_id,fmt,...)
end
---@param ptr_id ffi.ct* const void*
---@param fmt string
---@return boolean
function M.TreeNode_Ptr(ptr_id,fmt,...)
    return lib.igTreeNode_Ptr(ptr_id,fmt,...)
end
function M.TreeNode(a1,a2,...) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a2==nil then return M.TreeNode_Str(a1) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a2) or ffi.istype('char[]',a2) or type(a2)=='string') then return M.TreeNode_StrStr(a1,a2,...) end
    if ffi.istype('void *',a1) then return M.TreeNode_Ptr(a1,a2,...) end
    print(a1,a2,...)
    error'M.TreeNode could not find overloaded'
end
---@param id number ImGuiID
---@param flags TreeNodeFlags
---@param label string
---@param label_end string?
---@return boolean
function M.TreeNodeBehavior(id,flags,label,label_end)
    label_end = label_end or nil
    return lib.igTreeNodeBehavior(id,flags,label,label_end)
end
---@param label string
---@param flags TreeNodeFlags?
---@return boolean
function M.TreeNodeEx_Str(label,flags)
    flags = flags or 0
    return lib.igTreeNodeEx_Str(label,flags)
end
---@param str_id string
---@param flags TreeNodeFlags
---@param fmt string
---@return boolean
function M.TreeNodeEx_StrStr(str_id,flags,fmt,...)
    return lib.igTreeNodeEx_StrStr(str_id,flags,fmt,...)
end
---@param ptr_id ffi.ct* const void*
---@param flags TreeNodeFlags
---@param fmt string
---@return boolean
function M.TreeNodeEx_Ptr(ptr_id,flags,fmt,...)
    return lib.igTreeNodeEx_Ptr(ptr_id,flags,fmt,...)
end
function M.TreeNodeEx(a1,a2,a3,...) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and a3==nil then return M.TreeNodeEx_Str(a1,a2) end
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') and (ffi.istype('const char*',a3) or ffi.istype('char[]',a3) or type(a3)=='string') then return M.TreeNodeEx_StrStr(a1,a2,a3,...) end
    if ffi.istype('void *',a1) then return M.TreeNodeEx_Ptr(a1,a2,a3,...) end
    print(a1,a2,a3,...)
    error'M.TreeNodeEx could not find overloaded'
end
---@param str_id string
---@param flags TreeNodeFlags
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeExV_Str(str_id,flags,fmt,args)
    return lib.igTreeNodeExV_Str(str_id,flags,fmt,args)
end
---@param ptr_id ffi.ct* const void*
---@param flags TreeNodeFlags
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeExV_Ptr(ptr_id,flags,fmt,args)
    return lib.igTreeNodeExV_Ptr(ptr_id,flags,fmt,args)
end
function M.TreeNodeExV(a1,a2,a3,a4) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreeNodeExV_Str(a1,a2,a3,a4) end
    if ffi.istype('void *',a1) then return M.TreeNodeExV_Ptr(a1,a2,a3,a4) end
    print(a1,a2,a3,a4)
    error'M.TreeNodeExV could not find overloaded'
end
---@param id number ImGuiID
---@param open boolean
---@return nil
function M.TreeNodeSetOpen(id,open)
    return lib.igTreeNodeSetOpen(id,open)
end
---@param id number ImGuiID
---@param flags TreeNodeFlags
---@return boolean
function M.TreeNodeUpdateNextOpen(id,flags)
    return lib.igTreeNodeUpdateNextOpen(id,flags)
end
---@param str_id string
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeV_Str(str_id,fmt,args)
    return lib.igTreeNodeV_Str(str_id,fmt,args)
end
---@param ptr_id ffi.ct* const void*
---@param fmt string
---@param args ffi.ct* va_list
---@return boolean
function M.TreeNodeV_Ptr(ptr_id,fmt,args)
    return lib.igTreeNodeV_Ptr(ptr_id,fmt,args)
end
function M.TreeNodeV(a1,a2,a3) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreeNodeV_Str(a1,a2,a3) end
    if ffi.istype('void *',a1) then return M.TreeNodeV_Ptr(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.TreeNodeV could not find overloaded'
end
---@return nil
function M.TreePop()
    return lib.igTreePop()
end
---@param str_id string
---@return nil
function M.TreePush_Str(str_id)
    return lib.igTreePush_Str(str_id)
end
---@param ptr_id ffi.ct* const void*
---@return nil
function M.TreePush_Ptr(ptr_id)
    return lib.igTreePush_Ptr(ptr_id)
end
function M.TreePush(a1) -- generic version
    if (ffi.istype('const char*',a1) or ffi.istype('char[]',a1) or type(a1)=='string') then return M.TreePush_Str(a1) end
    if ffi.istype('void *',a1) then return M.TreePush_Ptr(a1) end
    print(a1)
    error'M.TreePush could not find overloaded'
end
---@param id number ImGuiID
---@return nil
function M.TreePushOverrideID(id)
    return lib.igTreePushOverrideID(id)
end
---@param req ffi.ct* ImGuiTypingSelectRequest*
---@param items_count number int
---@param get_item_name_func ffi.ct* const char*(*)(void*,int)
---@param user_data ffi.ct* void*
---@return number int
function M.TypingSelectFindBestLeadingMatch(req,items_count,get_item_name_func,user_data)
    return lib.igTypingSelectFindBestLeadingMatch(req,items_count,get_item_name_func,user_data)
end
---@param req ffi.ct* ImGuiTypingSelectRequest*
---@param items_count number int
---@param get_item_name_func ffi.ct* const char*(*)(void*,int)
---@param user_data ffi.ct* void*
---@param nav_item_idx number int
---@return number int
function M.TypingSelectFindMatch(req,items_count,get_item_name_func,user_data,nav_item_idx)
    return lib.igTypingSelectFindMatch(req,items_count,get_item_name_func,user_data,nav_item_idx)
end
---@param req ffi.ct* ImGuiTypingSelectRequest*
---@param items_count number int
---@param get_item_name_func ffi.ct* const char*(*)(void*,int)
---@param user_data ffi.ct* void*
---@param nav_item_idx number int
---@return number int
function M.TypingSelectFindNextSingleCharMatch(req,items_count,get_item_name_func,user_data,nav_item_idx)
    return lib.igTypingSelectFindNextSingleCharMatch(req,items_count,get_item_name_func,user_data,nav_item_idx)
end
---@param indent_w number? float
---@return nil
function M.Unindent(indent_w)
    indent_w = indent_w or 0.0
    return lib.igUnindent(indent_w)
end
---@return nil
function M.UpdateHoveredWindowAndCaptureFlags()
    return lib.igUpdateHoveredWindowAndCaptureFlags()
end
---@param trickle_fast_inputs boolean
---@return nil
function M.UpdateInputEvents(trickle_fast_inputs)
    return lib.igUpdateInputEvents(trickle_fast_inputs)
end
---@return nil
function M.UpdateMouseMovingWindowEndFrame()
    return lib.igUpdateMouseMovingWindowEndFrame()
end
---@return nil
function M.UpdateMouseMovingWindowNewFrame()
    return lib.igUpdateMouseMovingWindowNewFrame()
end
---@return nil
function M.UpdatePlatformWindows()
    return lib.igUpdatePlatformWindows()
end
---@param window ffi.ct* ImGuiWindow*
---@param flags WindowFlags
---@param parent_window ffi.ct* ImGuiWindow*
---@return nil
function M.UpdateWindowParentAndRootLinks(window,flags,parent_window)
    return lib.igUpdateWindowParentAndRootLinks(window,flags,parent_window)
end
---@param label string
---@param size ImVec2
---@param v ffi.ct* float*
---@param v_min number float
---@param v_max number float
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.VSliderFloat(label,size,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%.3f"
    return lib.igVSliderFloat(label,size,v,v_min,v_max,format,flags)
end
---@param label string
---@param size ImVec2
---@param v ffi.ct* int*
---@param v_min number int
---@param v_max number int
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.VSliderInt(label,size,v,v_min,v_max,format,flags)
    flags = flags or 0
    format = format or "%d"
    return lib.igVSliderInt(label,size,v,v_min,v_max,format,flags)
end
---@param label string
---@param size ImVec2
---@param data_type DataType
---@param p_data ffi.ct* void*
---@param p_min ffi.ct* const void*
---@param p_max ffi.ct* const void*
---@param format string?
---@param flags SliderFlags?
---@return boolean
function M.VSliderScalar(label,size,data_type,p_data,p_min,p_max,format,flags)
    flags = flags or 0
    format = format or nil
    return lib.igVSliderScalar(label,size,data_type,p_data,p_min,p_max,format,flags)
end
---@param prefix string
---@param b boolean
---@return nil
function M.Value_Bool(prefix,b)
    return lib.igValue_Bool(prefix,b)
end
---@param prefix string
---@param v number int
---@return nil
function M.Value_Int(prefix,v)
    return lib.igValue_Int(prefix,v)
end
---@param prefix string
---@param v number unsigned int
---@return nil
function M.Value_Uint(prefix,v)
    return lib.igValue_Uint(prefix,v)
end
---@param prefix string
---@param v number float
---@param float_format string?
---@return nil
function M.Value_Float(prefix,v,float_format)
    float_format = float_format or nil
    return lib.igValue_Float(prefix,v,float_format)
end
function M.Value(a1,a2,a3) -- generic version
    if (ffi.istype('bool',a2) or type(a2)=='boolean') then return M.Value_Bool(a1,a2) end
    if (ffi.istype('int32_t',a2) or type(a2)=='number') then return M.Value_Int(a1,a2) end
    if (ffi.istype('uint32_t',a2) or type(a2)=='number') then return M.Value_Uint(a1,a2) end
    if (ffi.istype('float',a2) or type(a2)=='number') then return M.Value_Float(a1,a2,a3) end
    print(a1,a2,a3)
    error'M.Value could not find overloaded'
end
---@param window ffi.ct* ImGuiWindow*
---@param p ImVec2
---@return nil
function M.WindowPosRelToAbs(window,p)
    local nonUDT_out = ffi.new("ImVec2")
    lib.igWindowPosRelToAbs(nonUDT_out,window,p)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@param r ImRect
---@return nil
function M.WindowRectAbsToRel(window,r)
    local nonUDT_out = ffi.new("ImRect")
    lib.igWindowRectAbsToRel(nonUDT_out,window,r)
    return nonUDT_out
end
---@param window ffi.ct* ImGuiWindow*
---@param r ImRect
---@return nil
function M.WindowRectRelToAbs(window,r)
    local nonUDT_out = ffi.new("ImRect")
    lib.igWindowRectRelToAbs(nonUDT_out,window,r)
    return nonUDT_out
end
----------END_AUTOGENERATED_LUA-----------------------------

return M